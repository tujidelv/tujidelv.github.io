<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>通过Cloudflare Worker搭建永久免费节点</title>
      <link href="/2024/05/18/st-cf-worker.html"/>
      <url>/2024/05/18/st-cf-worker.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">准备工作</a></li><li><a href="#edgetunnel">edgetunnel</a></li><li><a href="#epeius">epeius</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote><p>何为 Cloudflare Worker ?<br>Cloudflare Worker 是 Cloudflare 提供的一种服务，它允许开发者在全球分布的边缘服务器上运行自定义的 JavaScript 代码。 Cloudflare Worker 可以用来处理 HTTP 请求，从而允许开发者通过编写 JavaScript 代码来实现各种功能，例如路由请求、修改请求和响应、执行身份验证、实现缓存策略等。</p></blockquote><h3 id="注册Cloudflare账号"><a href="#注册Cloudflare账号" class="headerlink" title="注册Cloudflare账号"></a><code>注册Cloudflare账号</code></h3><ol><li>推荐使用新注册的账号来部署服务，打开注册地址：<a href="https://dash.cloudflare.com/sign-up">点击注册</a>。</li><li>输入邮箱地址和密码，点击注册。</li><li>添加网站或应用程序，然后点击”返回到 XXX’s account”，点击上方的”请验证您的电子邮件地址”，去验证电子邮件，注册成功。</li></ol><h3 id="注册域名"><a href="#注册域名" class="headerlink" title="注册域名"></a><code>注册域名</code></h3><blockquote><p>虽说可以不使用域名，但是推荐大家还是购买自己的域名，毕竟不贵，一年才10元RMB。<br>推荐在Namesilo进行购买，因为他的WHOIS隐私是免费的，可以适当的进行一下隐私保护，而且域名还都挺便宜的。</p></blockquote><ol><li>购买地址：<a href="https://www.namesilo.com/">点击访问</a> （1.49刀&#x2F;年起，选择.buzz|.sbs|.cfd会更便宜）。</li><li>点击网页右上角的头像注册一个会员，输入用户名、邮箱地址、密码，点击”Create Account”，然后开始注册我们的域名。</li><li>输入”lvzhiqiang.icu”，加入购物车，点击”Checkout”结账，会弹出一个窗口默认即可，继续”Checkout”，支付方式根据自己的需求进行选择，然后点击”PAY”。</li><li>支付成功跳转到<a href="https://www.namesilo.com/account/">Dashboard</a>，点击”Active Domains”下面的”Manage”，填写个人资料保存，点击左边的”Domain Manager”就能看到我们注册的域名。</li><li>进入域名子页面，点击”Domain will be suspended soon due to the lack of email verification”验证邮箱。</li><li>注意域名的到期时间及时续费。</li></ol><h3 id="托管域名到Cloudflare"><a href="#托管域名到Cloudflare" class="headerlink" title="托管域名到Cloudflare"></a><code>托管域名到Cloudflare</code></h3><blockquote><p>将上面注册的域名托管到CF，也就是让它解析在CF中完成，这样的话解析的速度也会更快一些，也为了支持我们等一下的自定义域。</p></blockquote><ol><li>点击CF中的”开始使用”，输入刚注册的域名-》Free-》开始快速扫描-》继续，将CF分配的2组名称服务器填写到域名注册商当中去。</li><li>去到域名注册商的域名子页面，编辑NameServer，更新成上一步骤的2组名称服务器，点击SUBMIT，可以在”Domain Manager”列表中”NameServers”看到CF分配的2组名称服务器。</li><li>等待激活之后，之后这个域名的所有解析操作都可以在CF中完成。</li><li>点击”DNS”，将其中2条系统自带的记录删掉。</li></ol><h2 id="edgetunnel"><a href="#edgetunnel" class="headerlink" title="edgetunnel"></a>edgetunnel</h2><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a><code>项目介绍</code></h3><ul><li>免费的节点，解锁ChatGPT以及全解锁Netflix，最快的时候电信千兆网络跑youtube一度给干到了26w+。</li><li>早在2020年的双12，zizifn大佬在github创立了edgetunnel项目，翻译过来就是边缘隧道，原理就是使用cloudflare worker的部署方式可以实现vless节点的免费搭建，也就是大家所说的薅羊毛。</li><li>时隔4年有余，原先的项目已经更新迭代了不少次，也被Fork修改了很多内容，加入了不少的功能，那其中以CM大佬Fork修改的项目最为代表性，以下为搭建原版（初级）和修改版（高级）的步骤。</li></ul><h3 id="搭建初级VLESS节点"><a href="#搭建初级VLESS节点" class="headerlink" title="搭建初级VLESS节点"></a><code>搭建初级VLESS节点</code></h3><blockquote><p>原作者GitHub，源项目地址：<a href="https://github.com/zizifn/edgetunnel">点击访问</a></p></blockquote><ol><li>点击Cloudflare左上角图标来到<a href="https://dash.cloudflare.com/">首页</a>，点击”Workers和Pages”，创建Worker，自定义名称，然后部署！</li><li>Worker 部署 VLESS。<ul><li>点击”编辑代码”，清除原先代码，填入如下代码：<a href="https://github.com/V2RaySSR/Free-VLESS/">点击访问</a>，代码修改完毕以后，点击右边的”部署”-》”保存并部署”，然后点击左边的箭头返回。</li><li>因为原项目里面的代码proxyIP为空，所以在访问套了CF等站点会无法打开，这是CF的机制，所以我们需要通过其他一些IP进行转发，所以就有了以下的代码。</li><li><a href="https://1024tools.com/uuid">点击这里</a>，在线生成一个UUID，用于替换下面代码中第七行的UUID，也就是我们VLESS节点的密钥。（或是用V2rayN生成一个）</li><li>关于proxyIP，是用于转发CF的一些流量，所以若是存在套了CF的一些网站无法打开或者无法解锁GPT或者奈飞，请更换其中的其他网址，也就是第九行中的部分网址！</li></ul></li><li>设置自定义域。<ul><li>找到设置-》触发器，添加自定义域，输入<code>没使用过</code>的<code>已经托管在CF上面</code>的二级域名（xxx.xxx.xxx）。</li><li>博主托管在CF上面的域名是<code>lvzhiqiang.icu</code>，随便指定一个二级域名的前缀：cf-vless（名字随意），所以就有了二级域名 <code>cf-vless.lvzhiqiang.icu</code>。</li><li>输入完成，若是输入框变为绿色，证明格式正确，点击添加自定义域。</li><li>域证书会显示：正在初始化，等待证书生效，或是直接访问<a href="cf-vless.lvzhiqiang.icu">该域名</a>，网页显示有内容，证明部署完毕。</li></ul></li><li>访问 https:&#x2F;&#x2F;二级域名&#x2F;UUID ，即可看到节点信息，里面包含了订阅链接。<ul><li>至此，节点部署完毕，复制VLESS的订阅链接粘贴到V2rayN里面，解锁了ChatGPT、Netflix ，是不是很 Happy。</li><li>以上就是 VLESS Work 原作者的部署策略。</li></ul></li></ol><h3 id="节点IP优选"><a href="#节点IP优选" class="headerlink" title="节点IP优选"></a><code>节点IP优选</code></h3><ul><li>若是速度不理想，可以自行优选CF IP来进行提速。CF优选IP Windows工具：<a href="https://github.com/badafans/better-cloudflare-ip">点击下载</a></li><li>运行IP优选的时候请关闭代理，这样会更准确，记得不要使用TLS优选。</li><li>在V2rayN中选择节点编辑服务器，该把优选的IP直接填入到地址就可以使用了。</li></ul><h3 id="搭建高级VLESS节点"><a href="#搭建高级VLESS节点" class="headerlink" title="搭建高级VLESS节点"></a><code>搭建高级VLESS节点</code></h3><blockquote><p>高级版的部署其实和初级的部署大同小异，只是多了很多功能，比如自动生成SUB CLASH、SURGE订阅地址、自动优选IP等。<br><a href="https://github.com/cmliu">CM</a>基于<a href="https://github.com/zizifn">zizifn</a>的项目进行了二次创作，GitHub地址：<a href="https://github.com/cmliu/edgetunnel">点击访问</a>（功能还是很多的）</p></blockquote><ol><li>点击Cloudflare左上角图标来到<a href="https://dash.cloudflare.com/">首页</a>，点击”创建应用程序”-》”Pages”-》”上传资产”。</li><li>Pages 部署 VLESS。<ul><li>为项目创建一个名字，点击创建项目。</li><li>上传刚才下载下来的worker.zip （从计算机中选择-》上传压缩文件），然后点击”部署站点”-》”继续处理项目”。</li><li>回到刚才的项目，找到”设置”-》”环境变量”-》”添加变量”，变量名称：UUID，变量值为刚才生成的UUID，点击保存。</li></ul></li><li>设置自定义域。<ul><li>找到”自定义域”-》”设置自定义域”，输入<code>没使用过</code>的<code>已经托管在CF上面</code>的二级域名（xxx.xxx.xxx）。</li><li>博主托管在CF上面的域名是<code>lvzhiqiang.icu</code>，随便指定一个二级域名的前缀：cf-vless2（名字随意），所以就有了二级域名 <code>cf-vless2.lvzhiqiang.icu</code>。</li><li>输入完成，点击”激活域”。</li></ul></li><li>重新部署 Pages。<ul><li>回到项目，找到”部署”，点击下面的”创建新部署”，再次上传刚才的worker.zip文件，保存并部署。</li><li>继续处理项目，回到”自定义域”，可以看到<code>cf-vless2.lvzhiqiang.icu</code>已经生效，SSL已启用。</li><li>回到”部署”-》”访问站点”，若是有内容出现，证明部署成功。</li></ul></li><li>访问 https:&#x2F;&#x2F;二级域名&#x2F;UUID ，即可看到节点信息，里面包含了订阅链接。<ul><li>至此，节点部署完毕，我们导入”快速自适应订阅地址”到相对于的客户端软件，进行节点的订阅。</li><li>这些订阅地址也就是CM大佬基于原项目增加的一些功能，例如”快速自适应订阅地址”要比我们机场的订阅地址更可靠，它可以自适应我们的一些客户端。</li><li>订阅完成会多了很多节点，其实都是一个节点，只是用了不同的IP，原理和刚才初级部署是一样的，只是CM大佬为我们自动进行了IP的优选，还是很方便的。</li></ul></li></ol><h2 id="epeius"><a href="#epeius" class="headerlink" title="epeius"></a>epeius</h2><h3 id="项目介绍-1"><a href="#项目介绍-1" class="headerlink" title="项目介绍"></a><code>项目介绍</code></h3><ul><li>ca110us大佬了解了CF封禁VLESS代码1101后，担心鸡蛋都放在同一个篮子里，所以基于zizifn大佬的VLESS协议代码开发出来的Trojan协议的代码。</li><li>这是一个基于 Cloudflare Worker 平台的脚本，在原版的基础上修改了显示 Trojan 配置信息转换为订阅内容。使用该脚本，你可以方便地将 Trojan 配置信息使用在线配置转换到 Clash 或 Singbox 等工具中。</li></ul><h3 id="免折腾版"><a href="#免折腾版" class="headerlink" title="免折腾版"></a><code>免折腾版</code></h3><ol><li>点击Cloudflare左上角图标来到<a href="https://dash.cloudflare.com/">首页</a>，点击”Workers和Pages”，创建Worker，自定义名称，然后部署！</li><li>Worker 部署 TROJAN。<ul><li>点击”编辑代码”，清除原先代码，填入如下代码：<a href="https://github.com/cmliu/epeius/blob/main/_worker.js">点击访问</a>，代码修改完毕以后，点击右边的”部署”-》”保存并部署”，然后点击左边的箭头返回。</li></ul></li><li>设置自定义域。<ul><li>找到设置-》触发器，添加自定义域，输入<code>没使用过</code>的<code>已经托管在CF上面</code>的二级域名（xxx.xxx.xxx）。</li><li>博主托管在CF上面的域名是<code>lvzhiqiang.icu</code>，随便指定一个二级域名的前缀：cf-trojan（名字随意），所以就有了二级域名 <code>cf-trojan.lvzhiqiang.icu</code>。</li><li>输入完成，若是输入框变为绿色，证明格式正确，点击添加自定义域。</li><li>域证书会显示：正在初始化，等待证书生效，或是直接访问<a href="cf-trojan.lvzhiqiang.icu">该域名</a>，网页显示有内容，证明部署完毕。</li></ul></li><li>设置密码（一定要修改，不然节点会被别人拿去跑了）。<ul><li>回到刚才的项目，找到”设置”-》”变量”-》”添加变量”，变量名称：PASSWORD，变量值可以取任意值，点击部署。</li></ul></li><li>设置优选订阅生成器地址。<ul><li>回到刚才的项目，找到”设置”-》”变量”-》”添加变量”，变量名称：SUB，变量值trojan.fxxk.dedyn.io，点击部署。</li></ul></li><li>访问https:&#x2F;&#x2F;二级域名&#x2F;password ，即可看到节点信息，里面包含了订阅链接。<ul><li>至此，节点部署完毕，我们导入”快速自适应订阅地址”到相对于的客户端软件，进行节点的订阅。</li></ul></li></ol><h3 id="折腾版"><a href="#折腾版" class="headerlink" title="折腾版"></a><code>折腾版</code></h3><ol><li>去掉”SUB”变量，添加”ADD”变量，值为本地优选域名&#x2F;优选IP(支持多元素之间,或换行作间隔)。 <pre><code class="hljs plaintext">bestcf.onecf.eu.org#官方优选域名-Mingyu大佬提供维护bestproxy.onecf.eu.org#反代优选域名-Mingyu大佬提供维护cfip.xxxxxxxx.tk#官方优选域名-OTC大佬提供维护proxy.xxxxxxxx.tk#反代优选域名-OTC大佬提供维护acjp2.cloudflarest.link:2053#反代优选域名-KJKKK大佬提供维护acsg.cloudflarest.link:2053#反代优选域名-KJKKK大佬提供维护acsg3.cloudflarest.link:2053#反代优选域名-KJKKK大佬提供维护xn--b6gac.eu.org#↗↘↗.eu.org官方优选域名cdn-all.xn--b6gac.eu.org#cdn-all.↗↘↗.eu.org官方优选域名cdn-b100.xn--b6gac.eu.org#cdn-b100.↗↘↗.eu.org反代优选域名time.cloudflare.comshopify.comtime.isicook.hkicook.twip.sbjapan.commalaysia.comrussia.comsingapore.comskk.moewww.visa.comwww.visa.com.sgwww.visa.com.hkwww.visa.com.twwww.visa.co.jpwww.visakorea.comwww.gco.gov.qawww.gov.sewww.gov.uawww.digitalocean.comwww.csgo.comwww.shopify.comwww.whoer.netwww.whatismyip.comwww.ipget.netwww.hugedomains.comwww.udacity.comwww.4chan.orgwww.okcupid.comwww.glassdoor.comwww.udemy.comalejandracaiccedo.comnc.gocada.colog.bpminecraft.comwww.boba88slot.comgur.gov.uawww.zsu.gov.uawww.iakeys.comwww.d-555.comfbi.gov</code></pre></li><li>添加”PROXYIP”变量，值为备选作为访问CloudFlareCDN站点的代理节点(支持多ProxyIP, ProxyIP之间使用,或换行作间隔)。 <pre><code class="hljs plaintext">workers.cloudflare.cyoumy-telegram-is-herocore.onecf.eu.org</code></pre></li><li>添加”ADDAPI”变量，值为Mingyu大佬的优先IP的API，可自己维护。 <pre><code class="hljs plaintext">https://ipdb.api.030101.xyz/?type=bestproxy&amp;country=true</code></pre></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://v2rayssr.com/worker-vless.html">https://v2rayssr.com/worker-vless.html</a><br><a href="https://github.com/zizifn/edgetunnel">https://github.com/zizifn/edgetunnel</a><br><a href="https://github.com/cmliu/edgetunnel">https://github.com/cmliu/edgetunnel</a><br><a href="https://github.com/ca110us/epeius">https://github.com/ca110us/epeius</a><br><a href="https://github.com/cmliu/epeius">https://github.com/cmliu/epeius</a></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> 科学上网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPS搭建无人值守推流服务器</title>
      <link href="/2024/05/07/st-vps-live.html"/>
      <url>/2024/05/07/st-vps-live.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#VPS%E6%90%AD%E5%BB%BA%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E6%8E%A8%E6%B5%81%E6%9C%8D%E5%8A%A1%E5%99%A8">VPS搭建无人值守推流服务器</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="搭建无人值守推流服务器"><a href="#搭建无人值守推流服务器" class="headerlink" title="搭建无人值守推流服务器"></a>搭建无人值守推流服务器</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Youtube、哔哩哔哩、抖音、Tik Tok如何实现7×24小时在线直播进阶版，实现多平台无人直播，VPS搭建无人值守7×24小时推流服务器，轻松赚收益。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>安装依赖包 <pre><code class="hljs bash"><span class="hljs-comment"># Ubuntu/Debian系统安装</span>apt update -y &amp;&amp; apt install vim screen -y<span class="hljs-comment"># Centos系统安装</span>yum update -y &amp;&amp; yum install vim screen -y</code></pre></li><li>安装ffmpeg <pre><code class="hljs bash"><span class="hljs-comment"># Ubuntu/Ddian系统安装ffmpeg</span>apt install ffmpeg<span class="hljs-comment"># Centos系统安装ffmpeg</span>yum install epel-releaserpm -v --import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.rorpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-5.el7.nux.noarch.rpmyum install ffmpeg ffmpeg-devel<span class="hljs-comment"># 检查是否安装成功</span>ffmpeg -version</code></pre></li><li>上传推流脚本和上传直播视频<ul><li>推流脚本作者地址：【<a href="https://lala.im/4816.html">点击进入</a>】</li><li>下载推流脚本：【<a href="https://drive.google.com/file/d/1mLEK-og-T6pGLoqqTl6DoKOju73f7fp-/view?usp=drive_link">点击进入</a>】</li><li>把想要做直播的视频和推流脚本上传到root目录下</li><li>注意：目前支持循环推流mp4格式的视频，视频文件的名字不能含有空格或其他特殊符号。</li></ul></li><li>执行运行命令（注意：这里执行的是脚本的文件名，如果文件名更改，后面的stream.sh要改为对应的文件名） <pre><code class="hljs plaintext"># 1.新打开一个窗口（注意：这个点很关键）screen -S stream# 2.执行脚本，选择2，输入上一步的推流地址，尽量在finalshell中间的输入框输入直播网址+直播码，/号拼接；然后输入直播视频所在文件路径，这样就成功直播了。bash stream.sh</code></pre></li><li>远程分离后台运行 <pre><code class="hljs plaintext"># 1.新打开一个页面，查找IDscreen -ls# 2.然后远程detachscreen -d id</code></pre></li><li>停止推流 <pre><code class="hljs plaintext"># 关闭对应的窗口screen -X -S id quit# 重新打开对应窗口screen -r id# 强制停止推流pkill -f &quot;ffmpeg&quot;</code></pre></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://naiyous.com/4511.html">https://naiyous.com/4511.html</a></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> 科学上网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主流应用Account注册</title>
      <link href="/2024/04/26/st-register-account.html"/>
      <url>/2024/04/26/st-register-account.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#Google%E8%B4%A6%E5%8F%B7%E6%B3%A8%E5%86%8C">Google账号注册</a></li><li><a href="#%E6%B3%A8%E5%86%8C%E7%BE%8E%E5%8C%BAAppleID">注册美区 AppleID</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="Google账号"><a href="#Google账号" class="headerlink" title="Google账号"></a>Google账号</h2><h3 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a><code>注册账号</code></h3><p>以下方式均可在无痕模式下进行</p><ul><li>方法1：链接跳板（免费）<ol><li>在谷歌支持页面有一个<a href="https://support.google.com/accounts/answer/27441?hl=zh-Hans">创建账号</a>的入口，如果你的网络环境足够干净的话，直接点注册账号是有一定的概率是可以绕过这个手机验证直接注册成功的。</li><li>可通过以下方式检测网络环境是否足够干净<ul><li>检测IP伪装度(分数越高，伪装程度越好，可通过更详细去调整使分数更高)：【<a href="https://whoer.net/">点击进入</a>】</li><li>检测IP地址类型(定位到JSON中company-&gt;type，ISP是住宅IP，hosting或者business是机房IP)：【<a href="https://ipinfo.io/">点击进入</a>】</li><li>检查IP欺诈值(风险值越高，这个IP成功率越低)：【<a href="https://scamalytics.com/">点击进入</a>】</li></ul></li></ol></li><li>方法2：接码平台（付费）<ol><li>打开接码平台<a href="https://sms-activate.org/cn">sms-activate</a>|<a href="https://5sim.net/">5sim</a>，找到”Google,youtube,Gmail”，选择一些比较偏僻或者稍微贵一些的的国家，能接收到验证码的几率大些；购买后会跳转到接收短信的页面。</li><li>打开谷歌主页，依次点击登录-》创建账号-》个人用途，输入姓名+出生年月+性别+邮箱+密码，进入下一步手机验证，输入上一步选中的手机号，然后填入收到的验证码，填入辅助邮箱，即可完成注册。</li></ol></li></ul><h3 id="安全设置"><a href="#安全设置" class="headerlink" title="安全设置"></a><code>安全设置</code></h3><ul><li>用接码平台手机注册，可能会由于手机号不干净导致有一定的安全隐患，但因为我们绑定了自己的邮箱，如果账号出现被盗或者被封的情况，谷歌会发邮件通知我们的，有一定概率可以通过该邮箱找回账号。</li><li>账号注册成功之后，我们需要在这个电脑上挂大概一个星期左右，然后将这个账号绑定到自己的手机号上。可通过”安全性-》辅助电话号码-》添加手机号码”完成。</li><li>绑定手机号后，可通过”安全性-》两步验证”把两步验证打开，这样账号就相对安全了。</li><li>至于多个邮箱用同一个中国手机号，注册的时候好像不行会提示超限或者收不到验证码，但是注册成功之后换绑或者添加号码是可以无限制并且能收到验证码的。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><code>注意事项</code></h3><p>用接码平台注册的话要注意以下几点</p><ol><li><strong>账号最好不要作为主账号去使用</strong>。比如说注册谷歌账号的目的是要用到谷歌邮箱，这个邮箱主要用来接收一些其他网站注册的邮件就可以了，但是不要注册一些特别重要的东西例如支付宝、电商平台等涉及到资金管理的一些东西。</li><li><strong>如果被封先试着申诉</strong>。账号被封以后，辅助邮箱会收到邮件并附带申诉的链接，主要的理由就是这个账号就是我本人的，没有借过任何人，一直是我自己在使用，大概就是这个意思，然后等消息，是有一定概率找回的。</li><li><strong>使用时间越长账号越稳定</strong>。如果必须要作为一个比较重要的账号的话，可以在本地先用上一段时间例如一个月、半年、1年等等，然后再绑定一些比较重要的东西，</li></ol><h2 id="谷歌云"><a href="#谷歌云" class="headerlink" title="谷歌云"></a>谷歌云</h2><p>谷歌云服务器通过其先进的技术基础设施、灵活的服务和强大的安全性功能，为用户提供了一个可靠、高效的云计算平台。并且新用户注册就送300美金，这个羊毛必须要薅！</p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a><code>注册</code></h3><ol><li>准备一个自己搭建的节点或者一个好的机场节点、一张外币信用卡（理论上同一张信用卡可多次注册谷歌云账号）、一个提前注册好的谷歌账号（不要用刚注册好的谷歌账号）。</li><li>打开无痕模式，打开谷歌官网-》搜索谷歌云-》找到云计算服务-》点击进入；也可直接进入【<a href="https://cloud.google.com/?hl=zh-cn">谷歌云官网</a>】。</li><li>点击免费开始使用-》输入注册好的谷歌邮箱+密码-》建议措施选择以后再说-》国家和地区选择默认识别出来的，最好选择跟谷歌邮箱注册地或者梯子节点地区一致。</li><li>进入付款信息验证，账号类型选择个人-》付款方式里输入信用卡卡号，账单邮寄地址可通过<a href="https://www.meiguodizhi.com/">美国地址生成器</a>生成-》点击免费开始使用，即申请成功。</li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a><code>使用</code></h3><ul><li>进入<a href="https://console.cloud.google.com/welcome/new">谷歌云控制台</a></li><li>创建防火墙规则。导航栏菜单-》VPC网络-》防火墙，启用Compute Engine API。<ul><li>入站规则。流量方向：入站；目标：网络中的所有实例；来源IPv4范围：0.0.0.0&#x2F;0；协议和端口：全部允许；</li><li>出站规则。流量方向：出站；目标：网络中的所有实例；目标IPv4范围：0.0.0.0&#x2F;0；协议和端口：全部允许；</li></ul></li><li>创建Google Cloud新实例。导航栏菜单-》Compute Engine-》虚拟机实例。<ul><li>点击创建实例，左边选择机器的配置，右边可以看到每月估算费用。</li><li>区域建议选择离得比较近的亚太地区，这样速度比较快；可用区随便选择就行；启动磁盘根据自己需要选择；访问权限范围选择授予对所有 Cloud API 的完整访问权限；防火墙选择允许 HTTP 流量和允许 HTTPS 流量。</li></ul></li><li>修改root密码。  <pre><code class="hljs plaintext"># 1、切换到root用户sudo -i# 2、修改SSH配置文件，找到PermitRootLogin和PasswordAuthentication 默认为no修改为yesvi /etc/ssh/sshd_config# 3、重启SSH服务/etc/init.d/ssh restart 【Debian &amp; Ubuntu】/bin/systemctl restart sshd.service【CentOS】# 4、设置root账户密码passwd root</code></pre></li></ul><h3 id="转移结算账号"><a href="#转移结算账号" class="headerlink" title="转移结算账号"></a><code>转移结算账号</code></h3><p>把新的结算账号转移到旧的结算账号上面去，这样就可以一直用旧的结算账号，相对来说会方便一些。</p><ul><li>新谷歌云账号：导航栏菜单-》结算-》管理结算账号-》重命名结算账号（自定义一个好区分的）-》点击添加主账号-》输入老谷歌云账号（就是老谷歌云账号的邮箱）-》角色选择：Billing Account Administrator-》点击保存。</li><li>老谷歌云账号：导航栏菜单-》结算-》管理结算账号-》这时可以看到两个结算账号—》回到新谷歌云账号，把新的角色&#x2F;成员移除，移除后回到老谷歌云账号-》点击我的项目-》找到正在使用的项目，在操作那里点开，点击更改结算信息，选择新的结算账号-》点击设置账号。</li><li>关闭老谷歌云账号：导航栏菜单-》结算-》管理结算账号-》点击关闭结算账号。</li></ul><h2 id="美区AppleID"><a href="#美区AppleID" class="headerlink" title="美区AppleID"></a>美区AppleID</h2><h3 id="美区ID的好处"><a href="#美区ID的好处" class="headerlink" title="美区ID的好处"></a><code>美区ID的好处</code></h3><ul><li>软件下载<ul><li>美区的苹果应用商店可以下载到其他国家应用商店下载不到的一些APP，例如Google全家桶、TikTok、NetFlix、小火箭、圈 X等等。</li></ul></li><li>数据隐私<ul><li>美区账号的数据是放在美国本土服务器上，而国内账号的数据是放在云上贵州；如果你很注重隐私，美区 ID 是一个不错的选择。</li></ul></li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><code>准备工作</code></h3><ol><li>干净的邮箱：一个从未注册过 AppleID 的邮箱，最好使用常用的电子邮箱，以免忘记，不要使用临时邮箱，可以使用QQ邮箱、outlook邮箱等。</li><li>手机号码：国内外的手机号码都可以，虚拟号码也可，同一个手机号码注册苹果 ID 不要超过 2 次。</li><li>浏览器：推荐使用手机浏览器注册，建议开无痕模式，电脑注册，可能会遇到无法注册(此时无法创建你的账户)的情况。</li></ol><h3 id="开始注册"><a href="#开始注册" class="headerlink" title="开始注册"></a><code>开始注册</code></h3><ol><li>首先启用科学上网软件（手机电脑均可），选择美国节点，选择代理&#x2F;全局模式，使目前网络使用了美国代理。</li><li>打开此网站创建您的AppleID：<a href="https://appleid.apple.com/account#!&amp;page=create">https://appleid.apple.com/account#!&amp;page=create</a>。</li><li>可以是中文界面，但注意的是国家或地区，必须选择【美国】。按要求填写完整，自己务必记住就行，找回密码或者解锁账号会用到这些问题答案。<ul><li>美国地址信息生成：<a href="https://www.meiguodizhi.com/">https://www.meiguodizhi.com/</a>、<a href="https://www.fakepersongenerator.com/">https://www.fakepersongenerator.com/</a></li><li>美国免税州地址：阿拉斯加州（Alaska）特拉华州（Delaware）蒙大拿州（Montana）新罕布什尔州（New Hampshire）俄勒冈州（Oregon）</li></ul></li><li>然后会给你注册邮箱发一个6位数的验证码，输入后就完成了注册。若你是用来共享的账户，登陆后不推荐启用两步验证，这个共享的话会很麻烦，每次都需要进行登陆验证。</li></ol><hr><p>注：以前注册的账号也可以去该网站修改国家或地区：<a href="https://appleid.apple.com/account/manage">https://appleid.apple.com/account/manage</a>。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.youtube.com/watch?v=C1vwxHwRqqo">https://www.youtube.com/watch?v=C1vwxHwRqqo</a><br><a href="https://github.com/bannedbook/fanqiang/blob/master/ios/AppleID.md">https://github.com/bannedbook/fanqiang/blob/master/ios/AppleID.md</a><br><a href="https://qiushuizy.com/1659.html">https://qiushuizy.com/1659.html</a></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> 科学上网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPS监控：哪吒监控</title>
      <link href="/2024/04/23/st-monitoring-nezha.html"/>
      <url>/2024/04/23/st-monitoring-nezha.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%AE%89%E8%A3%85">安装</a></li><li><a href="#%E7%AE%A1%E7%90%86%E9%9D%A2%E6%9D%BF%E9%85%8D%E7%BD%AE">管理面板配置</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>开源、轻量、易用的服务器监控、运维工具。</li><li>一键安装：支持一键安装面板和监控服务，使用方便。主流系统包括Linux、Windows、MacOS、OpenWRT以及群晖均受支持。</li><li>实时监控：支持同时监控多个服务器的状态，提供历史延迟图表，并可监控网页、端口可用性和SSL证书状态。支持故障和流量等状态告警，可通过Telegram、邮件、微信等多种通知方式进行提醒。</li><li>轻松运维：可使用API获取服务器状态，支持WebSSH、DDNS和流量监控，可设置定时和触发任务并批量执行服务器任务。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>哪吒监控接入 Github、Gitlab、Gitee 作为后台管理员账号。</p></blockquote><h3 id="获取-Github-的-Client-ID-和密钥"><a href="#获取-Github-的-Client-ID-和密钥" class="headerlink" title="获取 Github 的 Client ID 和密钥"></a>获取 Github 的 Client ID 和密钥</h3><ol><li>打开<a href="https://github.com/settings/developers">Developer Settings</a>，依次选择OAuth Apps - New OAuth App 新建授权应用。</li><li>填写应用信息。<ul><li>Application name - 随意填写。</li><li>Homepage URL - 填写面板的访问域名，如：”<a href="https://monitor.lvzhiqiang.top" . ">https://monitor.lvzhiqiang.top&quot;。</a></li><li>Authorization callback URL- 填写回调地址，如：”<a href="https://monitor.lvzhiqiang.top/oauth2/callback%22%E3%80%82">https://monitor.lvzhiqiang.top/oauth2/callback&quot;。</a></li></ul></li><li>Register application 注册应用。</li><li>保存页面中的 Client ID，然后点击 “Generate a new client secret“，创建一个新的 Client Secret，新建的密钥仅会显示一次，请妥善保存。</li></ol><h3 id="运行面板安装脚本"><a href="#运行面板安装脚本" class="headerlink" title="运行面板安装脚本"></a>运行面板安装脚本</h3><pre><code class="hljs bash"><span class="hljs-comment"># GitHub 源</span>curl -L https://raw.githubusercontent.com/naiba/nezha/master/script/install.sh  -o nezha.sh &amp;&amp; <span class="hljs-built_in">chmod</span> +x nezha.sh &amp;&amp; sudo ./nezha.sh<span class="hljs-comment"># Gitee 源</span>curl -L https://gitee.com/naibahq/nezha/raw/master/script/install.sh -o nezha.sh &amp;&amp; <span class="hljs-built_in">chmod</span> +x nezha.sh &amp;&amp; sudo CN=<span class="hljs-literal">true</span> ./nezha.sh</code></pre><ol><li>填写相关信息<ul><li>请输入 OAuth2 提供商(github&#x2F;gitlab&#x2F;gitee，默认 github): - 直接回车，默认github。</li><li>请输入 Oauth2 应用的 Client ID: - 之前保存的 Client ID。</li><li>请输入 Oauth2 应用的 Client Secret: - 之前保存的密钥。</li><li>请输入 GitHub&#x2F;Gitee 登录名作为管理员，多个以逗号隔开: - 填写你的用户名，不是你登陆的账号或者自定义的别名。</li><li>请输入站点标题: - 随意。</li><li>输入站点访问端口: (默认 8008) - 服务面板的访问端口，可自定义。</li><li>请输入用于 Agent 接入的 RPC 端口: (默认 5555) - 客户端和服务面板的通讯端口。</li></ul></li><li>配置反向代理<ul><li>在宝塔面板中新建一个站点，域名填写公开访问域名，如 “monitor.lvzhiqiang.top”。</li><li>然后点击”设置”进入站点设置选项，选择“反向代理” - “添加反向代理”。</li><li>自定义一个代理名称，在下方”目标 URL”中填入 <a href="http://127.0.0.1/">http://127.0.0.1</a> 然后点击”保存”。</li><li>打开刚刚新建的反向代理右边的“配置文件”，将配置文件替换为以下内容： <pre><code class="hljs plaintext">#PROXY-START/location / &#123;   proxy_pass http://127.0.0.1:8008;   proxy_set_header Host $http_host;   proxy_set_header      Upgrade $http_upgrade;&#125;location ~ ^/(ws|terminal/.+)$  &#123;   proxy_pass http://127.0.0.1:8008;   proxy_http_version 1.1;   proxy_set_header Upgrade $http_upgrade;   proxy_set_header Connection &quot;Upgrade&quot;;   proxy_set_header Host $http_host;&#125;#PROXY-END/</code></pre></li></ul></li><li>此时可以直接使用域名，如：”<a href="http://monitor.lvzhiqiang.top/">http://monitor.lvzhiqiang.top</a>“ 来访问面板。</li><li>将来如果需要再次运行脚本来打开管理脚本 ，可以运行：<code>bash ./nezha.sh</code>。</li></ol><h2 id="管理面板配置"><a href="#管理面板配置" class="headerlink" title="管理面板配置"></a>管理面板配置</h2><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><blockquote><p>服务器区域负责管理 Agent，是哪吒探针中最基础的区域，也是其他功能的基础。</p></blockquote><ol><li>新增服务器<ul><li>第一步是新增服务器，可以自定义名称、分组、排序和备注。</li><li>拥有相同分组的服务器会在受支持的主题中划分到一起进行显示，备注仅会在后台显示，无需担心泄露信息。</li></ul></li><li>安装 Agent<ul><li>点击新添加的服务器旁，绿色的 Linux 图标按钮，复制一键安装命令。</li><li>在被控端服务器中运行复制的一键安装命令，等待安装完成后返回到 Dashboard 主页查看服务器是否上线。</li></ul></li></ol><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><blockquote><p>服务区域是设置 Agent 监控外部网站或服务器的功能设置区，设置好的服务监控可以在主页中的 “服务” 页查看过去 30 天的可用性监控结果。</p></blockquote><ol><li><p>添加监控</p><ul><li>名称 - 自定义一个名称，例如上海电信。</li><li>类型 - 选择一个监控类型，目前哪吒监控支持三种监控类型，分别是 “HTTP-GET”、“ICMP-Ping” 和 “TCP-Ping”。</li><li>目标 - 根据你选择的类型不同，目标的设置方法也不同 <pre><code class="hljs plaintext">HTTP-GET: 选择此类型，你应该输入一个URL作为目标，URL需添加 http:// 或 https:// 如果你的目标URL是 https:// ,将会同时监控该URL的SSL证书，当SSL证书到期或发生变更，会触发提醒。ICMP-Ping: 选择此类型时，你应该输入一个域名或IP，不含端口号，例如：1.1.1.1 或 example.comTCP-Ping: 选择此类型时，你应该输入一个域名或IP并包含端口号，例如：1.1.1.1:80 或 example.com:22</code></pre></li><li>请求间隔： 设定 Agent 每次请求目标的时间间隔，以秒为单位。</li><li>覆盖范围： 选择一条规则来确定要使用哪些 Agent 来请求目标。</li><li>特定服务器： 配合覆盖范围使用，选择规则内需要排除的 Agent。</li><li>通知方式组： 选择你已经在 “告警” 页设置好的通知方式，点击这里了解详情。</li><li>启用故障通知： 根据需要选择是否接收目标故障通知，默认为不勾选。</li></ul></li><li><p>延迟监控</p><table><thead><tr><th>地区</th><th>电信</th><th>移动</th><th>联通</th><th>教育</th></tr></thead><tbody><tr><td>上海</td><td>202.96.209.133</td><td>183.194.219.220</td><td>210.22.97.1</td><td>202.120.2.119</td></tr><tr><td>北京</td><td>49.7.37.74</td><td>112.34.111.194</td><td>111.206.209.44</td><td>166.111.4.100</td></tr><tr><td>广州</td><td>183.47.126.35</td><td>120.233.18.250</td><td>157.148.58.29</td><td>202.116.64.8</td></tr><tr><td>河北</td><td>27.185.242.215</td><td>111.62.229.100</td><td>61.182.138.156</td><td></td></tr><tr><td>山西</td><td>1.71.157.41</td><td>183.201.244.91</td><td>60.221.18.41</td><td></td></tr><tr><td>辽宁</td><td>123.184.58.41</td><td>36.131.156.145</td><td>218.61.211.132</td><td></td></tr><tr><td>吉林</td><td>123.172.127.217</td><td>111.27.127.176</td><td>122.143.8.41</td><td></td></tr><tr><td>黑龙江</td><td>42.101.84.132</td><td>111.42.190.25</td><td>113.7.211.140</td><td></td></tr><tr><td>江苏</td><td>58.215.210.220</td><td>36.156.92.132</td><td>122.96.235.165</td><td></td></tr><tr><td>浙江</td><td>115.220.14.91</td><td>117.147.213.41</td><td>101.69.194.224</td><td></td></tr><tr><td>安徽</td><td>223.247.108.251</td><td>112.29.198.100</td><td>112.132.208.41</td><td></td></tr><tr><td>福建</td><td>106.126.10.28</td><td>112.50.96.88</td><td>36.248.48.139</td><td></td></tr><tr><td>江西</td><td>106.227.22.132</td><td>117.168.150.249</td><td>116.153.69.224</td><td></td></tr><tr><td>山东</td><td>144.123.160.140</td><td>120.220.145.91</td><td>112.240.56.143</td><td></td></tr><tr><td>河南</td><td>171.15.110.220</td><td>111.7.99.220</td><td>123.6.65.101</td><td></td></tr><tr><td>湖北</td><td>111.170.8.60</td><td>111.47.131.101</td><td>122.189.226.138</td><td></td></tr><tr><td>湖南</td><td>113.240.117.108</td><td>120.226.192.91</td><td>116.162.28.220</td><td></td></tr><tr><td>广东</td><td>183.36.23.111</td><td>183.240.65.191</td><td>112.90.211.100</td><td></td></tr><tr><td>海南</td><td>124.225.43.220</td><td>111.29.29.219</td><td>153.0.226.35</td><td></td></tr><tr><td>四川</td><td>118.123.218.220</td><td>183.220.151.41</td><td>101.206.163.49</td><td></td></tr><tr><td>贵州</td><td>58.42.61.132</td><td>61.243.18.220</td><td>117.187.254.132</td><td></td></tr><tr><td>云南</td><td>222.221.102.220</td><td>36.147.44.219</td><td>14.204.150.41</td><td></td></tr><tr><td>陕西</td><td>124.115.14.100</td><td>111.19.148.100</td><td>123.139.127.132</td><td></td></tr><tr><td>甘肃</td><td>118.182.228.91</td><td>117.157.16.41</td><td>59.81.94.53</td><td></td></tr><tr><td>青海</td><td>223.221.216.219</td><td>111.12.152.170</td><td>116.177.237.137</td><td></td></tr><tr><td>内蒙古</td><td>110.76.186.70</td><td>117.161.76.41</td><td>116.114.98.41</td><td></td></tr><tr><td>广西</td><td>222.217.93.55</td><td>36.136.112.41</td><td>171.39.5.51</td><td></td></tr><tr><td>西藏</td><td>113.62.176.89</td><td>117.180.234.41</td><td>43.242.165.35</td><td></td></tr><tr><td>宁夏</td><td>222.75.44.220</td><td>111.51.155.214</td><td>116.129.226.28</td><td></td></tr><tr><td>新疆</td><td>110.157.243.45</td><td>36.189.208.164</td><td>116.178.77.40</td><td></td></tr><tr><td>天津</td><td>42.81.98.35</td><td>111.31.236.35</td><td>116.78.119.56</td><td></td></tr><tr><td>重庆</td><td>119.84.131.101</td><td>221.178.81.101</td><td>113.207.69.190</td><td></td></tr></tbody></table></li></ol><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><blockquote><ol><li>在任务区域中，可以设置计划任务，触发任务，多服务器批量执行任务。</li><li>哪吒监控支持推送命令到 Agent 执行，因此此功能非常灵活，使用此功能可以定期结合 restic、rclone 给服务器备份，定期重启某项服务来重置网络连接。也可以配合告警通知，在触发告警时执行某项任务，如 CPU 在长时期处于高占用的情况下运行某个脚本。</li></ol></blockquote><ul><li>添加计划任务<ul><li>名称 - 自定义一个任务名称。</li><li>任务类型 - 选择任务的类型。<br>   计划任务 - 按下方设置的计划时间，周期性执行任务。<br>   触发任务 - 仅被 API 或告警规则触发的任务，每次触发执行一次。</li><li>计划 - （使用触发任务类型时不生效）设置计划时间，时间的格式为： * * * * * * 分别对应 秒 分 时 天 月 星期，详情见<a href="https://pkg.go.dev/github.com/robfig/cron/v3#hdr-CRON_Expression_Format">计划表达式格式</a>。<br>   如：0 0 3 * * * 对应为 每天3点。</li><li>命令 - 你可以在这里设置需要执行的命令，就像写 Shell&#x2F;Bat 脚本一样，但是不推荐换行，多个命令使用 &amp;&amp;&#x2F;&amp; 连接。<br>   例如执行定期重启命令，可以在这里输入 reboot。</li><li>覆盖范围 和 特定服务器 - 跟“服务”页中的设置类似，选择规则来确定哪些 Agent 执行计划任务。<br>   使用触发任务类型时，可选择由触发的服务器执行。</li><li>通知方式组 - 选择你已经在 “告警” 页设置好的通知方式。</li><li>推送成功的消息 - 勾选此项，任务执行成功后会触发消息通知。</li></ul></li></ul><h3 id="告警"><a href="#告警" class="headerlink" title="告警"></a>告警</h3><blockquote><p>哪吒监控支持对服务器的负载、CPU、内存、硬盘、流量、月流量、进程数、连接数进行监控，并在其中某项达到用户设定值时发送告警通知。</p></blockquote><ul><li><p>基本规则</p><pre><code class="hljs plaintext">- type：可选取一个或多个类型，如在一个规则中选择了多个类型，需要同时满足所有选择的类型才会触发通知（可参考后面的示例）    - cpu、memory、swap、disk    - net_in_speed 入站网速、net_out_speed 出站网速、net_all_speed 双向网速、transfer_in 入站流量、transfer_out 出站流量、transfer_all 双向流量    - offline 离线监控    - load1、load5、load15 负载    - process_count 进程数 目前取线程数占用资源太多，暂时不支持    - tcp_conn_count、udp_conn_count 连接数- duration：持续数秒，数秒内采样记录 30% 以上触发阈值才会报警（防数据插针）- min 或 max：    - 流量、网速类数值 为字节（1KB=1024B，1MB = 1024*1024B）    - 内存、硬盘、CPU 以占用百分比计数    - 离线监控无需设置此项- cover：    - 0 监控所有，通过 ignore 忽略特定服务器    - 1 忽略所有，通过 ignore 监控特定服务器    - 例如：[&#123;&quot;type&quot;:&quot;offline&quot;,&quot;duration&quot;:10, &quot;cover&quot;:0, &quot;ignore&quot;:&#123;&quot;5&quot;: true&#125;&#125;]- ignore: 选择忽略特定服务器，搭配 cover 使用，内容为服务器 id 和布尔值，例如：&#123;&quot;1&quot;: true, &quot;2&quot;:false&#125;</code></pre></li><li><p>流量监控规则</p><pre><code class="hljs plaintext">- type:  - transfer_in_cycle 周期内的入站流量  - transfer_out_cycle 周期内的出站流量  - transfer_all_cycle 周期内双向流量和- cycle_start： 统计周期开始日期（可以是你机器计费周期的开始日期），时间格式为RFC3339，例如北京时间为2022-01-11T08:00:00.00+08:00- cycle_interval：每隔多少个周期单位（例如，周期单位为天，该值为 7，则代表每隔 7 天统计一次）- cycle_unit： 统计周期单位，默认hour,可选(hour, day, week, month, year)- min/max、cover、ignore 参考基本规则配置</code></pre></li></ul><hr><ul><li>通知方式<ul><li>API接口<pre><code class="hljs plaintext">名称：企业微信-javURL：https://jav.lvzhiqiang.top/coin/serverMonitorAlarm请求方式: POST请求类型: JSONBody: &#123;&quot;内容&quot;: &quot;#NEZHA#&quot;&#125;</code></pre></li><li>企业微信<pre><code class="hljs plaintext">名称：企业微信-群聊机器人URL：https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxxxx请求方式: POST请求类型: JSONBody: &#123;&quot;msgtype&quot;:&quot;markdown&quot;,&quot;markdown&quot;:&#123;&quot;content&quot;:&quot;# 哪吒通知消息\n\n\&quot;#NEZHA#\&quot;&quot;&#125;&#125;</code></pre></li></ul></li><li>告警规则<ul><li>离线通知<ul><li>[{“type”:”offline”,”duration”:10}]</li></ul></li><li>流量告警<ul><li>[{“type”:”transfer_all_cycle”,”max”:1099511627776,”cycle_start”:”2024-04-14T00:00:00+08:00”,”cycle_interval”:1,”cycle_unit”:”month”,”cover”:1,”ignore”:{“1”:true}}]</li></ul></li><li>网速报警<ul><li>[{“type”:”net_out_speed”,”max”:5242880,”duration”:10,”ignore”:{“3”:true}}]</li></ul></li><li>CPU100%<ul><li>[{“type”:”cpu”,”max”:98,”duration”:10}]</li></ul></li><li>CPU+内存<ul><li>CPU 持续 10s 超过 50% 且 内存持续 20s 占用低于 20% 的报警</li><li>[{“type”:”cpu”,”max”:50,”duration”:10},{“type”:”memory”,”min”:20,”duration”:20}]</li></ul></li></ul></li></ul><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><ol><li>未接入 CDN 的面板服务器域名&#x2F;IP<ul><li>设置好通信域名，此域名不可以接入CDN，这里以示例通信域名 “monitor-data.lvzhiqiang.top” 来做演示。</li><li>进入后台管理面板，转到“设置”页，在“未接入 CDN 的面板服务器域名&#x2F;IP”项中填入通信域名，然后点击”保存”。</li></ul></li><li>调整最大TCPPing值<ul><li>修改文件：&#x2F;nezha&#x2F;data&#x2F;config.yaml，调整MaxTCPPingValue值。</li></ul></li><li>隐藏服务中的状态文字<pre><code class="hljs css">&lt;style&gt;<span class="hljs-selector-class">.service-status</span> <span class="hljs-selector-class">.delay-today-text</span>&#123;<span class="hljs-attribute">display</span>: none;<span class="hljs-attribute">visibility</span>: hidden;&#125;&lt;/style&gt;</code></pre></li><li>设置页面宽度<pre><code class="hljs css">&lt;style&gt;<span class="hljs-selector-class">.container</span> &#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">1540px</span>;&#125;&lt;/style&gt;</code></pre></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://bigdata.icu/tools/soft/nezha.html">https://bigdata.icu/tools/soft/nezha.html</a><br><a href="https://nezha.wiki/">https://nezha.wiki</a></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式协调工具之 Zookeeper</title>
      <link href="/2020/07/29/af-zookeeper.html"/>
      <url>/2020/07/29/af-zookeeper.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式协调工具之-Zookeeper"><a href="#分布式协调工具之-Zookeeper" class="headerlink" title="分布式协调工具之 Zookeeper"></a>分布式协调工具之 Zookeeper</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E5%85%A5%E9%97%A8">入门</a></li><li><a href="#%E5%AE%89%E8%A3%85">安装</a></li><li><a href="#%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86">内部原理</a></li><li><a href="#%E5%AE%9E%E6%88%98">实战</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>Zookeeper是一个开源分布式的为分布式应用提供协调服务的Apache项目。</li><li>Zookeeper &#x3D; 文件系统 + 通知机制。</li><li>工作机制  <pre><code class="hljs plaintext">从设计模式角度理解，它是一个基于观察者模式设计的分布式服务管理框架。它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，它就负责通知已经在zk上注册的那些观察者做出相应的反应。</code></pre></li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>一个领导者（leader）多个跟随者（follower）组成的集群。</li><li>集群中只要有<strong>半数以上（不包括半数）</strong>节点存活，zk集群就能正常服务。</li><li>全局唯一性，每个server保存一份相同的数据副本，client无论连接到哪个server，数据都是一致的。</li><li>顺序性，来自同一个client的更新请求按其发送顺序依次执行。</li><li>原子性，一次数据更新要么成功，要么失败。</li><li>实时性，在一定时间范围内，client能读到最新数据。</li></ol><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>zk的数据模型的结构与<code>unix文件系统很类似</code>，整体上可以看作是一棵树，每个节点称作一个ZNode。<br>每一个ZNode默认能够存储<code>1MB</code>的数据，每个ZNode都可以<code>通过其路径唯一标识</code>。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。</p><pre><code class="hljs plaintext">1.统一命名服务    在分布式环境下，经常需要对应用/服务进行统一命名，便于识别。    例如IP不容易记住，而域名容易记住。2. 统一配置管理    1）分布式环境下，配置文件同步非常常见。        1）一般要求一个集群中，所有节点的配置信息是一致的，比如kafka集群。        2）对配置文件修改后，希望能够快速同步到各个节点上。    2）配置管理可交由zk实现。        1）可将配置信息写入zk上的一个ZNode。        2）各个客户端服务器监听这个ZNode。        3）一旦ZNode中的数据被修改，zk将通知各个客户端服务器。3. 统一集群管理    1）分布式环境中，实时掌握每个节点的状态是必要的。        1）可根据节点实时状态做出一些调整。    2）zk可以实现实时监控节点状态变化。        1）可将节点信息写入zk上的一个ZNode。        2）监听这个ZNode可获取它的实时状态变化。4. 服务器节点动态上下线    1）服务器启动时去注册信息（创建都是临时节点）。    2）客户端获取到当前在线服务器列表，并且注册监听。    3）服务器节点下线。    4）zk将服务器节点上下线事件通知给客户端。    5）客户端重新再去获取服务器列表，并注册监听。5. 软负载均衡    在zk中记录每台服务器列表的访问数，让访问数最少的服务器去处理最新的客户端请求。</code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>地址：<a href="https://zookeeper.apache.org/">https://zookeeper.apache.org</a></p><h3 id="本地安装模式"><a href="#本地安装模式" class="headerlink" title="本地安装模式"></a>本地安装模式</h3><ol><li>安装前准备<ul><li>安装jdk</li><li>下载解压：tar -zxvf zookeeper-3.4.10.tar.gz -C &#x2F;usr&#x2F;program</li></ul></li><li>配置修改<ul><li>将conf目录的zoo_sample.cfg修改为zoo.cfg</li><li>打开zoo.cfg文件，修改dataDir路径，最好放在zk目录下且目录必须事先存在</li></ul></li><li>操作zk<ul><li>启动服务端：bin&#x2F;zkServer.sh start</li><li>查看状态：bin&#x2F;zkServer.sh status</li><li>停止服务端：bin&#x2F;zkServer.sh stop</li><li>启动客户端：bin&#x2F;zkCli.sh</li><li>退出客户端：quit</li></ul></li></ol><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><ol><li>tickTime&#x3D;2000 <pre><code class="hljs plaintext">通信心跳数，Zookeeper服务器与客户端心跳时间，单位毫秒。Zookeeper使用的基本时间，服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳，时间单位为毫秒。它用于心跳机制，并且设置最小的session超时时间为两倍心跳时间。(session的最小超时时间是2*tickTime)</code></pre></li><li>initLimit&#x3D;10 <pre><code class="hljs plaintext">Leader与Follower初始通信时限。集群中的Follower与Leader之间初始连接时能容忍的最多心跳数（tickTime的数量），用它来限定集群中的Zookeeper服务器连接到Leader的时限。</code></pre></li><li>syncLimit&#x3D;5 <pre><code class="hljs plaintext">Leader与Follower启动之后的同步通信时限。集群中Leader与Follower之间的最大响应时间单位，假如响应超过syncLimit * tickTime，Leader认为Follwer死掉，从服务器列表中删除Follwer。</code></pre></li><li>dataDir <pre><code class="hljs plaintext">数据文件目录+数据持久化路径。主要用于保存Zookeeper中的数据。</code></pre></li><li>clientPort&#x3D;2181 <pre><code class="hljs plaintext">客户端连接端口。监听客户端连接的端口。</code></pre></li></ol><h3 id="分布式安装模式"><a href="#分布式安装模式" class="headerlink" title="分布式安装模式"></a>分布式安装模式</h3><pre><code class="hljs plaintext">1．集群规划    在hadoop102、hadoop103和hadoop104三个节点上部署Zookeeper。2．解压安装   （1）解压Zookeeper安装包到/usr/program/目录下   （2）同步/usr/program/zookeeper-3.4.10目录内容到hadoop103、hadoop1043．配置服务器编号   （1）在/usr/program/zookeeper-3.4.10/这个目录下创建zkData   （2）在/usr/program/zookeeper-3.4.10/zkData目录下创建一个myid的文件   （3）编辑myid文件，在文件中添加与server对应的编号：2   （4）拷贝配置好的zookeeper到其他机器上，并分别在hadoop102、hadoop103上修改myid文件中内容为3、44．配置zoo.cfg文件   （1）重命名/usr/program/zookeeper-3.4.10/conf这个目录下的zoo_sample.cfg为zoo.cfg   （2）打开zoo.cfg文件        修改数据存储路径配置        dataDir=/usr/program/zookeeper-3.4.10/zkData        增加如下配置        #######################cluster##########################        server.2=hadoop102:2888:3888        server.3=hadoop103:2888:3888        server.4=hadoop104:2888:3888   （3）同步zoo.cfg配置文件   （4）配置参数解读        server.A=B:C:D。        A是一个数字，表示这个是第几号服务器；            集群模式下配置一个文件myid，这个文件在dataDir目录下，这个文件里面有一个数据就是A的值，            Zookeeper启动时读取此文件，拿到里面的数据与zoo.cfg里面的配置信息比较从而判断到底是哪个server。        B是这个服务器的ip地址；        C是这个服务器与集群中的Leader服务器交换信息的端口；        D是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。5. 集群操作   （1）分别启动Zookeeper        [hadoop102 zookeeper-3.4.10]$ bin/zkServer.sh start        [hadoop103 zookeeper-3.4.10]$ bin/zkServer.sh start        [hadoop104 zookeeper-3.4.10]$ bin/zkServer.sh start   （2）查看状态        [hadoop102 zookeeper-3.4.10]$ bin/zkServer.sh status        [hadoop103 zookeeper-3.4.10]$ bin/zkServer.sh status        [hadoop104 zookeeper-3.4.10]$ bin/zkServer.sh status</code></pre><h3 id="客户端命令行操作"><a href="#客户端命令行操作" class="headerlink" title="客户端命令行操作"></a>客户端命令行操作</h3><table><thead><tr><th align="left">命令基本语法</th><th align="left">功能描述</th></tr></thead><tbody><tr><td align="left">bin&#x2F;zkCli.sh</td><td align="left">启动客户端</td></tr><tr><td align="left">help</td><td align="left">显示所有操作命令</td></tr><tr><td align="left">ls path [watch]</td><td align="left">查看当前znode中所包含的内容（子节点）</td></tr><tr><td align="left">ls2 path [watch]</td><td align="left">查看当前节点详细数据（包括更新次数等数据）</td></tr><tr><td align="left">create path 节点内容</td><td align="left">创建节点，-s 含有序列 -e 临时（重启或者超时消失）</td></tr><tr><td align="left">get path [watch]</td><td align="left">获得节点的值</td></tr><tr><td align="left">set path 节点内容</td><td align="left">修改节点数据值</td></tr><tr><td align="left">stat path</td><td align="left">查看节点状态</td></tr><tr><td align="left">delete path</td><td align="left">删除节点</td></tr><tr><td align="left">rmr path</td><td align="left">递归删除节点</td></tr></tbody></table><pre><code class="hljs plaintext">1. 创建带序号的节点时，如果原来没有序号节点，序号从0开始依次递增。如果原节点下已有2个节点，则再排序时从2开始，以此类推。2. watch代表监听，可以监听节点值的变化、节点的子节点变化（路径变化）等。</code></pre><h2 id="内部原理"><a href="#内部原理" class="headerlink" title="内部原理"></a>内部原理</h2><h3 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a><code>选举机制</code></h3><ol><li><strong>半数机制</strong>：集群中半数以上机器存活，集群可用，所以ZK适合安装奇数台服务器。</li><li>ZK虽然在配置文件中并没有指定Master和Slave，但是ZK工作时，是有一个节点为Leader，其他则为Follower，Leader是通过内部的选举机制临时产生的。</li></ol><p><img src="/2020/07/29/af-zookeeper/af-zookeeper-001.png" alt="抱歉,图片休息了"></p><pre><code class="hljs plaintext">（1）服务器1启动，此时只有它一台服务器启动了，它发出去的报文没有任何响应，所以它的选举状态一直是LOOKING状态。（2）服务器2启动，它与最开始启动的服务器1进行通信，互相交换自己的选举结果，由于两者都没有历史数据，所以id值较大的服务器2胜出，但是由于没有达到超过半数以上的服务器都同意选举它(这个例子中的半数以上是3)，所以服务器1、2还是继续保持LOOKING状态。（3）服务器3启动，根据前面的理论分析，服务器3成为服务器1、2、3中的老大，而与上面不同的是，此时有三台服务器选举了它，所以它成为了这次选举的Leader。（4）服务器4启动，根据前面的分析，理论上服务器4应该是服务器1、2、3、4中最大的，但是由于前面已经有半数以上的服务器选举了服务器3，所以它只能接收当小弟的命了。（5）服务器5启动，同4一样当小弟。</code></pre><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><p><img src="/2020/07/29/af-zookeeper/af-zookeeper-002.png" alt="抱歉,图片休息了"></p><h3 id="Stat结构体"><a href="#Stat结构体" class="headerlink" title="Stat结构体"></a>Stat结构体</h3><pre><code class="hljs plaintext">1）czxid - 创建节点的事务zxid    每次修改ZooKeeper状态都会收到一个zxid形式的时间戳，也就是ZooKeeper事务ID。    事务ID是ZooKeeper中所有修改总的次序。每个修改都有唯一的zxid，如果zxid1小于zxid2，那么zxid1在zxid2之前发生。2）ctime - znode被创建的毫秒数(从1970年开始)3）mzxid - znode最后更新的事务zxid4）mtime - znode最后修改的毫秒数(从1970年开始)5）pZxid - znode最后更新的子节点zxid6）cversion - znode子节点变化号，znode子节点修改次数7）dataversion - znode数据变化号8）aclVersion - znode访问控制列表的变化号9）ephemeralOwner - 如果是临时节点，这个是znode拥有者的session id。如果不是临时节点则是0。10）dataLength - znode的数据长度11）numChildren - znode子节点数量</code></pre><h3 id="监听器原理"><a href="#监听器原理" class="headerlink" title="监听器原理"></a><code>监听器原理</code></h3><p><img src="/2020/07/29/af-zookeeper/af-zookeeper-003.png" alt="抱歉,图片休息了"></p><h3 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h3><p><img src="/2020/07/29/af-zookeeper/af-zookeeper-004.png" alt="抱歉,图片休息了"></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="API应用"><a href="#API应用" class="headerlink" title="API应用"></a>API应用</h3><ul><li>创建ZooKeeper客户端  <pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">connectString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hadoop102:2181,hadoop103:2181,hadoop104:2181&quot;</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">sessionTimeout</span> <span class="hljs-operator">=</span> <span class="hljs-number">2000</span>;<span class="hljs-keyword">private</span> <span class="hljs-type">ZooKeeper</span> <span class="hljs-variable">zkClient</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-meta">@Before</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;    zkClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(connectString, sessionTimeout, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent event)</span> &#123;            <span class="hljs-comment">// 收到事件通知后的回调函数（用户的业务逻辑）</span>            System.out.println(event.getType() + <span class="hljs-string">&quot;--&quot;</span> + event.getPath());            <span class="hljs-comment">// 再次启动监听</span>            <span class="hljs-keyword">try</span> &#123;                zkClient.getChildren(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-literal">true</span>);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;);&#125;</code></pre></li><li>创建子节点  <pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;    <span class="hljs-comment">// 参数1：要创建的节点的路径； 参数2：节点数据 ； 参数3：节点权限 ；参数4：节点的类型</span>    <span class="hljs-type">String</span> <span class="hljs-variable">nodeCreated</span> <span class="hljs-operator">=</span> zkClient.create(<span class="hljs-string">&quot;/aa&quot;</span>, <span class="hljs-string">&quot;jinlian&quot;</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);&#125;</code></pre></li><li>获取子节点并监听节点变化  <pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getChildren</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;    List&lt;String&gt; children = zkClient.getChildren(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-literal">true</span>);    <span class="hljs-keyword">for</span> (String child : children) &#123;        System.out.println(child);    &#125;    <span class="hljs-comment">// 延时阻塞</span>    Thread.sleep(Long.MAX_VALUE);&#125;</code></pre></li><li>判断Znode是否存在  <pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exist</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;    <span class="hljs-type">Stat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> zkClient.exists(<span class="hljs-string">&quot;/eclipse&quot;</span>, <span class="hljs-literal">false</span>);    System.out.println(stat == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;not exist&quot;</span> : <span class="hljs-string">&quot;exist&quot;</span>);&#125;</code></pre></li></ul><h3 id="监听服务器节点动态上下线"><a href="#监听服务器节点动态上下线" class="headerlink" title="监听服务器节点动态上下线"></a>监听服务器节点动态上下线</h3><p><img src="/2020/07/29/af-zookeeper/af-zookeeper-005.png" alt="抱歉,图片休息了"></p><ul><li>在集群上创建&#x2F;servers节点  <pre><code class="hljs plaintext">[zk: localhost:2181(CONNECTED) 10] create /servers &quot;servers&quot;</code></pre></li><li>服务器端向ZK注册并写入信息<pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> org.apache.zookeeper.CreateMode;<span class="hljs-keyword">import</span> org.apache.zookeeper.WatchedEvent;<span class="hljs-keyword">import</span> org.apache.zookeeper.Watcher;<span class="hljs-keyword">import</span> org.apache.zookeeper.ZooKeeper;<span class="hljs-keyword">import</span> org.apache.zookeeper.ZooDefs.Ids;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistributeServer</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">connectString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hadoop102:2181,hadoop103:2181,hadoop104:2181&quot;</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">sessionTimeout</span> <span class="hljs-operator">=</span> <span class="hljs-number">2000</span>;    <span class="hljs-keyword">private</span> <span class="hljs-type">ZooKeeper</span> <span class="hljs-variable">zk</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">parentNode</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/servers&quot;</span>;        <span class="hljs-comment">// 创建到zk的客户端连接</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getConnect</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException&#123;        zk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(connectString, sessionTimeout, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent event)</span> &#123;            &#125;        &#125;);    &#125;    <span class="hljs-comment">// 注册服务器</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registServer</span><span class="hljs-params">(String hostname)</span> <span class="hljs-keyword">throws</span> Exception&#123;        <span class="hljs-type">String</span> <span class="hljs-variable">create</span> <span class="hljs-operator">=</span> zk.create(parentNode + <span class="hljs-string">&quot;/server&quot;</span>, hostname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);        System.out.println(hostname +<span class="hljs-string">&quot; is online &quot;</span>+ create);    &#125;    <span class="hljs-comment">// 业务功能</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">business</span><span class="hljs-params">(String hostname)</span> <span class="hljs-keyword">throws</span> Exception&#123;        System.out.println(hostname+<span class="hljs-string">&quot; is working ...&quot;</span>);        Thread.sleep(Long.MAX_VALUE);    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 1获取zk连接</span>        <span class="hljs-type">DistributeServer</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistributeServer</span>();        server.getConnect();        <span class="hljs-comment">// 2 利用zk连接注册服务器信息</span>        server.registServer(args[<span class="hljs-number">0</span>]);        <span class="hljs-comment">// 3 启动业务功能</span>        server.business(args[<span class="hljs-number">0</span>]);    &#125;&#125;</code></pre></li><li>客户端向ZK注册并监听<pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> org.apache.zookeeper.WatchedEvent;<span class="hljs-keyword">import</span> org.apache.zookeeper.Watcher;<span class="hljs-keyword">import</span> org.apache.zookeeper.ZooKeeper;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistributeClient</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">connectString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hadoop102:2181,hadoop103:2181,hadoop104:2181&quot;</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">sessionTimeout</span> <span class="hljs-operator">=</span> <span class="hljs-number">2000</span>;    <span class="hljs-keyword">private</span> <span class="hljs-type">ZooKeeper</span> <span class="hljs-variable">zk</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">parentNode</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/servers&quot;</span>;    <span class="hljs-comment">// 创建到zk的客户端连接</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getConnect</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;        zk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(connectString, sessionTimeout, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent event)</span> &#123;                <span class="hljs-comment">// 再次启动监听</span>                <span class="hljs-keyword">try</span> &#123;                    getServerList();                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;);    &#125;    <span class="hljs-comment">// 获取服务器列表信息</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getServerList</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 1获取服务器子节点信息，并且对父节点进行监听</span>        List&lt;String&gt; children = zk.getChildren(parentNode, <span class="hljs-literal">true</span>);        <span class="hljs-comment">// 2存储服务器信息列表</span>        ArrayList&lt;String&gt; servers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-comment">// 3遍历所有节点，获取节点中的主机名称信息</span>        <span class="hljs-keyword">for</span> (String child : children) &#123;            <span class="hljs-type">byte</span>[] data = zk.getData(parentNode + <span class="hljs-string">&quot;/&quot;</span> + child, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);            servers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data));        &#125;        <span class="hljs-comment">// 4打印服务器列表信息</span>        System.out.println(servers);    &#125;    <span class="hljs-comment">// 业务功能</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">business</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;        System.out.println(<span class="hljs-string">&quot;client is working ...&quot;</span>);        Thread.sleep(Long.MAX_VALUE);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 1获取zk连接</span>        <span class="hljs-type">DistributeClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistributeClient</span>();        client.getConnect();        <span class="hljs-comment">// 2获取servers的子节点信息，从中获取服务器信息列表</span>        client.getServerList();        <span class="hljs-comment">// 3业务进程启动</span>        client.business();    &#125;&#125;</code></pre></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NoSQL数据库之HBase</title>
      <link href="/2020/05/26/af-nosql-hbase.html"/>
      <url>/2020/05/26/af-nosql-hbase.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8">快速入门</a></li><li><a href="#HBase%E8%BF%9B%E9%98%B6">HBase进阶</a></li><li><a href="#HBaseAPI">HBaseAPI</a></li><li><a href="#HBase%E4%BC%98%E5%8C%96">HBase优化</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>定义  <pre><code class="hljs plaintext">HBase是一种分布式、可扩展、支持海量数据存储的NoSQL数据库。数据量大的时候适合此选型，能做到几十亿条数据秒级查询。反之优势不是很明显，比较耗资源。</code></pre></li><li>数据模型  <pre><code class="hljs plaintext">逻辑上，HBase的数据模型同关系型数据库很类似，数据存储在一张表中，有行有列。但从 HBase的底层物理存储结构（K-V）来看，HBase更像是一个multi-dimensional map。</code></pre></li><li>逻辑结构</li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h2 id="HBase进阶"><a href="#HBase进阶" class="headerlink" title="HBase进阶"></a>HBase进阶</h2><h2 id="HBaseAPI"><a href="#HBaseAPI" class="headerlink" title="HBaseAPI"></a>HBaseAPI</h2><h2 id="HBase优化"><a href="#HBase优化" class="headerlink" title="HBase优化"></a>HBase优化</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> BigData </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BigData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件之 Kafka</title>
      <link href="/2020/04/21/af-mq-kafka.html"/>
      <url>/2020/04/21/af-mq-kafka.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8">快速入门</a></li><li><a href="#%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%85%A5">架构深入</a></li><li>[kafka API](#kafka API)</li><li><a href="#kafka%E7%9B%91%E6%8E%A7">kafka 监控</a></li><li><a href="#flume%E5%AF%B9%E6%8E%A5kafka">flume对接kafka</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>定义</p>  <pre><code class="hljs plaintext">Apache开源的使用Scala和Java编写的基于发布/订阅模式的以队列为模型的分布式消息中间件，主要应用于大数据实时处理领域。</code></pre></li><li><p>维基百科</p><blockquote><p><strong>K</strong>afka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。该项目的目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。<strong>其</strong>持久化层本质上是一个“按照分布式事务日志架构的大规模发布&#x2F;订阅消息队列”，这使它作为企业级基础设施来处理流式数据非常有价值。<strong>此</strong>外，Kafka可以通过Kafka Connect连接到外部系统（用于数据输入&#x2F;输出），并提供了Kafka Streams——一个Java流式处理库。  </p></blockquote></li><li><p>发展历史</p>  <pre><code class="hljs plaintext">1. Kafka最初是由领英开发，并随后于2011年初开源，并于2012年10月23日由Apache Incubator孵化出站。2. 2014年11月，几个曾在领英为Kafka工作的工程师，创建了名为Confluent的新公司，并着眼于Kafka。3. 根据2014年Quora的帖子，Jay Kreps似乎已经将它以作家弗朗茨·卡夫卡命名。4. Kreps选择将该系统以一个作家命名是因为，它是“一个用于优化写作的系统”，而且他很喜欢卡夫卡的作品。</code></pre></li><li><p>消息队列的2种模式</p>  <pre><code class="hljs plaintext">1.点对点模式（一对一，消费者主动拉取数据，消息收到后消息清除）    消息生产者生产消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息。    消息被消费以后，queue中不再有存储，所以消息消费者不可能消费到已经被消费的消息。    Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。2.发布/订阅模式（一对多，消费者消费数据之后不会清除消息）    消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。    和点对点方式不同，发布到topic的消息会被所有订阅者消费。</code></pre></li><li><p>基础架构<br>  <img src="/2020/04/21/af-mq-kafka/af-mq-kafka-001.png" alt="抱歉,图片休息了"></p>  <pre><code class="hljs plaintext">1. Producer ： 消息生产者，向kafka broker发消息的客户端；2. Consumer ： 消息消费者，向kafka broker取消息的客户端；3. Consumer Group（CG）： 消费者组，由多个consumer组成。    消费者组内每个消费者负责消费不同分区的数据，同一时刻一个分区只能由一个组内消费者消费，消费者组之间互不影响。    所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。    消费者组的引用提高了消费能力。4. Broker ： 消息中转角色，负责接收、存储、转发消息，在JMS规范中称为Provider。    一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic。5. Topic ： 消息主题(逻辑分类)，可以理解为一个队列，生产者和消费者面向的都是一个topic；6. Partition： 分区，提高topic的负载均衡能力及扩展性。    一个非常大的topic可以分布到多个broker（即服务器）上，一个topic可以分为多个partition，每个partition是一个有序的队列；7. Replica： 副本，提高冗余能力及高可用性。    为保证集群中的某个节点发生故障时该节点上的partition数据不丢失，且kafka仍然能够继续工作，kafka提供了副本机制，一个topic的每个分区都有若干个副本，即一个leader和若干个follower。8. leader： 每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是leader。9. follower： 每个分区多个副本中的“从”，实时从leader中同步数据，保持和leader数据的同步。leader发生故障时，某个follower会成为新的leader。</code></pre></li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a><code>安装部署</code></h3><pre><code class="hljs plaintext">集群规划：一台VPS上部署2个broker，组成集群软件依赖：jdk,kafka防火墙设置：如果是开发环境,直接关闭防火墙；如果是生产环境,就需要配置防火墙，增加端口规则</code></pre><hr><ol><li>安装JDK并配置环境变量（省略）</li><li>下载<a href="http://kafka.apache.org/downloads.html">kafka程序包</a> <pre><code class="hljs plaintext"># wget -P /opt/setups https://mirrors.tuna.tsinghua.edu.cn/apache/kafka/2.5.0/kafka_2.12-2.5.0.tgz</code></pre></li><li>解压到指定目录 <pre><code class="hljs plaintext"># mkdir -pv /usr/program# tar -zxvf kafka_2.12-2.5.0.tgz -C /usr/program/</code></pre></li><li>配置环境变量 <pre><code class="hljs plaintext">[root@144 ~]# vim /etc/profile.d/my.sh# kafkaKAFKA_HOME=/usr/program/kafka_2.12-2.5.0PATH=$KAFKA_HOME/bin:$PATHexport KAFKA_HOMEexport PATH[root@144 ~]# source /etc/profile.d/my.sh</code></pre></li><li>创建相关日志文件夹 <pre><code class="hljs plaintext"># mkdir -pv /tmp/kafka-logs/&#123;1,2&#125;# mkdir -pv /tmp/zookeeper-logs</code></pre></li><li>配置集群参数 <pre><code class="hljs plaintext">[root@144 ~]# cp $&#123;KAFKA_HOME&#125;/config/server.properties $&#123;KAFKA_HOME&#125;/config/server-1.properties[root@144 ~]# vim $&#123;KAFKA_HOME&#125;/config/server-1.properties#broker的全局唯一编号，不能重复broker.id=1#服务端口号listeners=PLAINTEXT://:9093#是否开启删除topic功能，否则只是标记删除delete.topic.enable=true#处理网络请求的线程数量num.network.threads=3#处理磁盘IO的线程数量num.io.threads=8#发送套接字的缓冲区大小socket.send.buffer.bytes=102400#接收套接字的缓冲区大小socket.receive.buffer.bytes=102400#请求套接字的缓冲区大小socket.request.max.bytes=104857600#kafka存放暂存数据的路径，并非日志目录log.dirs=/tmp/kafka-logs/1#自动创建topic时默认的分区个数，默认为1个分区1个副本num.partitions=1#用来恢复和清理data下数据的线程数量num.recovery.threads.per.data.dir=1#segment文件保留的最长时间，超时将被删除，默认7天log.retention.hours=168# The maximum size of a log segment file. When this size is reached a new log segment will be created.log.segment.bytes=1073741824#配置连接Zookeeper集群地址，多个用逗号分隔zookeeper.connect=localhost:2181</code></pre> <pre><code class="hljs plaintext">[root@144 ~]# cp $&#123;KAFKA_HOME&#125;/config/server-1.properties $&#123;KAFKA_HOME&#125;/config/server-2.properties[root@144 ~]# vim $&#123;KAFKA_HOME&#125;/config/server-2.properties#broker的全局唯一编号，不能重复broker.id=2#服务端口号listeners=PLAINTEXT://:9094#kafka运行日志存放的路径log.dirs=/tmp/kafka-logs/2...</code></pre></li><li>启动集群 <pre><code class="hljs plaintext">[root@144 ~]# cd $&#123;KAFKA_HOME&#125;/bin[root@144 bin]# zookeeper-server-start.sh -daemon ../config/zookeeper.properties[root@144 bin]# kafka-server-start.sh -daemon ../config/server-1.properties[root@144 bin]# kafka-server-start.sh -daemon ../config/server-2.properties</code></pre></li><li>关闭集群 <pre><code class="hljs plaintext">[root@144 bin]# kafka-server-stop.sh stop</code></pre></li><li>群起脚本(附加) <pre><code class="hljs plaintext">#!/bin/bashcase $1 in&quot;start&quot;)&#123;for i in hadoop102 hadoop103 hadoop104do    echo &quot;*************$i*************&quot;    ssh $i &quot;/usr/program/kafka/bin/kafka-server-start.sh -daemon /usr/program/kafka/config/server.properties&quot;done&#125;;;&quot;stop&quot;)&#123;for i in hadoop102 hadoop103 hadoop104do    echo &quot;*************$i*************&quot;    ssh $i &quot;/usr/program/kafka/bin/kafka-server-stop.sh /usr/program/kafka/config/server.properties&quot;done&#125;;;esac</code></pre></li></ol><h3 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a><code>命令行操作</code></h3><ul><li>查看当前服务器中的所有topic  <pre><code class="hljs plaintext">[root@144 bin]# kafka-topics.sh --zookeeper 127.0.0.1:2181 --list</code></pre></li><li>创建topic  <pre><code class="hljs plaintext"># 副本数不能大于当前可用broker数量# 副本数是leader和follower加起来的总数，即副本包括leader和follower[root@144 bin]# kafka-topics.sh --zookeeper 127.0.0.1:2181 --create --replication-factor 2 --partitions 2 --topic test</code></pre></li><li>查看某个topic详情  <pre><code class="hljs plaintext">[root@144 bin]# kafka-topics.sh --zookeeper 127.0.0.1:2181 --describe --topic test</code></pre></li><li>删除topic  <pre><code class="hljs plaintext">[root@144 bin]# kafka-topics.sh --zookeeper 127.0.0.1:2181 --delete --topic test</code></pre></li><li>修改分区数  <pre><code class="hljs plaintext">[root@144 bin]# kafka-topics.sh --zookeeper 127.0.0.1:2181 --alter --topic test --partitions 3</code></pre></li><li>发送消息  <pre><code class="hljs plaintext">[root@144 bin]# kafka-console-producer.sh --broker-list 127.0.0.1:9093,127.0.0.1:9094 --topic test</code></pre></li><li>消费消息  <pre><code class="hljs plaintext">[root@144 bin]# kafka-console-consumer.sh --bootstrap-server 127.0.0.1:9093 --topic test --from-beginning</code></pre>  <pre><code class="hljs plaintext"># 0.9版本之后就过时了，而且新版本也删除了这种启动方式[root@144 bin]# kafka-console-consumer.sh --zookeeper 127.0.0.1:2181 --topic test --from-beginning</code></pre></li></ul><h2 id="架构深入"><a href="#架构深入" class="headerlink" title="架构深入"></a>架构深入</h2><h3 id="工作流程及文件存储机制"><a href="#工作流程及文件存储机制" class="headerlink" title="工作流程及文件存储机制"></a><code>工作流程及文件存储机制</code></h3><ul><li><strong>kafka工作流程</strong></li></ul><p><img src="/2020/04/21/af-mq-kafka/af-mq-kafka-002.png" alt="抱歉,图片休息了"></p><pre><code class="hljs plaintext">Kafka中的消息是以topic进行分类的，生产者生产消息，消费者消费消息，都是面向topic的。topic是逻辑上的概念，而partition是物理上的概念，每个partition对应于一个log文件，该log文件中存储的就是producer生产的数据。 Producer生产的数据会被不断追加到该log文件末端，且每条数据都有自己的offset。即kafka只能保证区内有序，并不能保证全局有序。消费者组中的每个消费者，都会实时记录自己消费到了哪个offset，以便出错恢复时，从上次的位置继续消费。</code></pre><ul><li><strong>kafka文件存储机制</strong></li></ul><p><img src="/2020/04/21/af-mq-kafka/af-mq-kafka-003.png" alt="抱歉,图片休息了"></p><pre><code class="hljs plaintext">由于生产者生产的消息会不断追加到log文件末尾，为防止log文件过大导致数据定位效率低下，Kafka采取了分片和索引机制，将每个partition分为多个segment。每个segment对应两个文件——“.index”文件和“.log”文件。这些文件位于一个文件夹下，该文件夹的命名规则为：topic名称+分区序号。例如，test这个topic有2个分区，则其对应的文件夹为test-0,test-1。index和log文件以当前segment的第一条消息的offset命名。---00000000000000000000.index00000000000000000000.log00000000000000170410.index00000000000000170410.log00000000000000239430.index00000000000000239430.log</code></pre><p><img src="/2020/04/21/af-mq-kafka/af-mq-kafka-004.png" alt="抱歉,图片休息了"></p><pre><code class="hljs plaintext">index文件存储大量的索引信息，log文件存储大量的数据，索引文件中的元数据指向对应数据文件中message的物理偏移地址。</code></pre><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a><code>生产者</code></h3><ul><li>分区策略  <pre><code class="hljs plaintext">1.分区的原因    a.方便在集群中扩展，每个Partition可以通过调整以适应它所在的机器，而一个topic又可以有多个Partition组成，因此整个集群就可以适应任意大小的数据了；    b.可以提高并发，因为可以以Partition为单位读写了。2.分区的原则    我们需要将producer发送的数据封装成一个ProducerRecord对象。    a.指明partition的情况下，直接将指明的值直接作为partiton值；    b.没有指明partition值但有key的情况下，将key的hash值与topic的partition数进行取余得到partition值；    c.既没有partition值又没有key值的情况下，第一次调用时随机生成一个整数（后面每次调用在这个整数上自增），将这个值与topic可用的partition总数取余得到partition值，也就是常说的round-robin算法。</code></pre></li><li>数据可靠性保证<ul><li>副本数据同步策略  <pre><code class="hljs plaintext">为保证producer发送的数据，能可靠的发送到指定的topic，topic的每个partition收到producer发送的数据后，都需要向producer发送ack（acknowledgement确认收到），如果producer收到ack，就会进行下一轮的发送，否则重新发送数据。---何时发送ack?确保有follower与leader同步完成，leader再发送ack，这样才能保证leader挂掉之后，能在follower中选举出新的leader。---多少个follower同步完成后发送ack?一种方案是半数以上的follower同步完成，即可发送ack。优点是延迟低；缺点是选举新的leader时，容忍n台节点的故障，需要2n+1个副本另一种方案是全部的follower同步完成，才可以发送ack。优点是选举新的leader时，容忍n台节点的故障，需要n+1个副本；缺点是延迟高---Kafka选择了第二种方案，原因如下：1.同样为了容忍n台节点的故障，第一种方案需要2n+1个副本，而第二种方案只需要n+1个副本，而Kafka的每个分区都有大量的数据，第一种方案会造成大量数据的冗余。2.虽然第二种方案的网络延迟会比较高，但网络延迟对Kafka的影响较小。</code></pre></li><li>ISR  <pre><code class="hljs plaintext">采用第二种方案之后，设想以下情景：leader收到数据，所有follower都开始同步数据，但有一个follower，因为某种故障，迟迟不能与leader进行同步，那leader就要一直等下去，直到它完成同步，才能发送ack。这个问题怎么解决呢？Leader维护了一个动态的in-sync replica set(ISR)，意为和leader保持同步的follower集合。当ISR中的follower完成数据的同步之后，leader就会给producer发送ack。如果follower长时间未向leader同步数据，则该follower将被踢出ISR，该时间阈值由replica.lag.time.max.ms参数设定。 Leader发生故障之后，就会从ISR中选举新的leader。</code></pre></li><li>ack应答机制  <pre><code class="hljs plaintext">对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失，所以没必要等ISR中的follower全部接收成功。所以Kafka为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡，对acks参数配置。---0：producer不等待broker的ack，这一操作提供了一个最低的延迟，broker一接收到还没有写入磁盘就已经返回，当broker故障时有可能丢失数据；1：producer等待broker的ack，partition的leader落盘成功后返回ack，如果在follower同步成功之前leader故障，那么将会丢失数据；-1（all）：producer等待broker的ack，partition的leader和follower(ISR)全部落盘成功后才返回ack。但是如果在follower同步完成后，broker发送ack之前，leader发生故障，那么会造成数据重复。</code></pre></li><li>故障处理细节<br>  <img src="/2020/04/21/af-mq-kafka/af-mq-kafka-006.png" alt="抱歉,图片休息了">  <pre><code class="hljs plaintext">LEO：指的是每个副本最大的offset；HW：指的是消费者能见到的最大的offset，ISR队列中最小的LEO。只能保证消费者消费数据的一致性，生产者生产数据的一致性由ack来保证。---1. follower故障    follower发生故障后会被临时踢出ISR，待该follower恢复后，follower会读取本地磁盘记录的上次的HW，并将log文件高于HW的部分截取掉，    从HW开始向leader进行同步。等该follower的LEO大于等于该Partition的HW，即follower追上leader之后，就可以重新加入ISR了。2. leader故障    leader发生故障之后，会从ISR中选出一个新的leader，为保证多个副本之间的数据存储一致性，其余的follower会先将各自的log文件    高于HW的部分截掉，然后从新的leader同步数据。这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</code></pre></li></ul></li><li>Exactly Once语义  <pre><code class="hljs plaintext">将服务器的ACK级别设置为-1，可以保证Producer到Server之间不会丢失数据，即AtLeast Once(最少一次)语义。相对的，将服务器ACK级别设置为0，可以保证生产者每条消息只会被发送一次，即AtMost Once(最多一次)语义。---AtLeast Once可以保证数据不丢失，但是不能保证数据不重复；相对的，AtLeast Once可以保证数据不重复，但是不能保证数据不丢失。但是，对于一些非常重要的信息，比如说交易数据，下游数据消费者要求数据既不重复也不丢失，即Exactly Once(精准一次性)语义。在0.11版本以前的Kafka，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。---0.11版本的Kafka，引入了一项重大特性：幂等性。所谓的幂等性就是指Producer不论向Server发送多少次重复数据，Server端都只会持久化一条。幂等性结合AtLeast Once语义，就构成了Kafka的Exactly Once语义。即：AtLeast Once + 幂等性 = Exactly Once---要启用幂等性，只需要将Producer的参数中enable.idompotence设置为true即可。Kafka的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的Producer在初始化的时候会被分配一个PID，发往同一Partition的消息会附带Sequence Number。而Broker端会对&lt;PID, Partition, SeqNumber&gt;做缓存，当具有相同主键的消息提交时，Broker只会持久化一条。---但是PID重启就会变化，同时不同的Partition也具有不同主键，所以幂等性无法保证跨分区跨会话的Exactly Once。</code></pre></li></ul><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a><code>消费者</code></h3><ul><li>消费方式  <pre><code class="hljs plaintext">发布订阅模式有推送和拉取2种消费方法，kafka consumer采用pull（拉）模式从broker中读取数据。---push（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。它的目标是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。---pull（拉）模式则可以根据consumer的消费能力以适当的速率消费消息。不足之处是kafka消费者需要维护一个长轮询，比较耗资源。如果没有数据，消费者可能会陷入循环中，一直返回空数据。针对这一点，Kafka的消费者在消费数据时会传入一个时长参数timeout，如果当前没有数据可供消费，consumer会等待一段时间之后再返回，这段时长即为timeout。</code></pre></li><li>分区分配策略  <pre><code class="hljs plaintext">一个consumer group中有多个consumer，一个topic有多个partition，所以必然会涉及到partition的分配问题，即确定哪个partition由哪个consumer来消费。Kafka有两种分配策略，一是RoundRobin(轮询)，一是Range(范围，默认)。---一个分区同一时刻只能被同一个消费者组（ConsumerGroup）内的一个消费者消费，消费者组之间互不影响。当消费者组中的消费者个数发生变化时(增多或减少)或者Topic分区发生变化时，都会触发分区重新分配。</code></pre>  <img src="/2020/04/21/af-mq-kafka/af-mq-kafka-009.png" alt="抱歉,图片休息了"></li><li>offset的维护  <pre><code class="hljs plaintext">由于consumer在消费过程中可能会出现断电宕机等故障，consumer恢复后，需要从故障前的位置的继续消费，所以consumer需要实时记录自己消费到了哪个offset，以便故障恢复后继续消费。所以offset的维护是Consumer消费数据是必须考虑的问题。kafka根据(Consumer Group+Topic+Partition)来确定唯一一个offset。---Kafka 0.9版本之前，consumer默认将offset保存在Zookeeper中，从0.9版本开始，consumer默认将offset保存在Kafka一个内置的topic中，该topic为__consumer_offsets，默认有50个分区1个副本，分散在各个broker中。无论哪种方式,都只在消费者启动的时候访问一次。</code></pre>  <pre><code class="hljs plaintext">1）修改配置文件consumer.properties,让普通消费者可以消费系统的Topicexclude.internal.topics=false2）读取 offset0.11.0.0 之前版本:bin/kafka-console-consumer.sh --topic __consumer_offsets --zookeeper localhost:2181 --formatter&quot;kafka.coordinator.GroupMetadataManager\$OffsetsMessageFormatter&quot;--consumer.config config/consumer.properties --from-beginning0.11.0.0 之后版本(含):bin/kafka-console-consumer.sh --topic __consumer_offsets --zookeeper localhost:2181 --formatter&quot;kafka.coordinator.group.GroupMetadataManager\$OffsetsMessageFormatter&quot; --consumer.config config/consumer.properties --frombeginning</code></pre>  <img src="/2020/04/21/af-mq-kafka/af-mq-kafka-007.png" alt="抱歉,图片休息了"></li></ul><h3 id="高效读写数据"><a href="#高效读写数据" class="headerlink" title="高效读写数据"></a><code>高效读写数据</code></h3><pre><code class="hljs plaintext">1. 顺序写磁盘    Kafka的producer生产数据，要写入到log文件中，写的过程是一直追加到文件末端，为顺序写。     官网有数据表明，同样的磁盘，顺序写能到600M/s，而随机写只有100K/s。这与磁盘的机械机构有关，顺序写之所以快，是因为其省去了大量磁头寻址的时间。2. 零拷贝技术</code></pre><h3 id="zk的作用"><a href="#zk的作用" class="headerlink" title="zk的作用"></a><code>zk的作用</code></h3><pre><code class="hljs plaintext">Kafka集群中有一个broker会被选举为Controller，负责管理集群broker的上下线，所有topic的分区副本分配和leader选举等工作。Controller的管理工作都是依赖于Zookeeper的。</code></pre><p><img src="/2020/04/21/af-mq-kafka/af-mq-kafka-008.png" alt="抱歉,图片休息了"></p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a><code>事务</code></h3><pre><code class="hljs plaintext">Kafka从0.11版本开始引入了事务支持。事务可以保证Kafka在Exactly Once语义的基础上，生产和消费可以跨分区和会话，要么全部成功，要么全部失败。---Producer事务为了实现跨分区跨会话的事务，需要引入一个全局唯一的Transaction ID，并将Producer获得的PID和Transaction ID绑定。这样当Producer重启后就可以通过正在进行的Transaction ID获得原来的 PID。为了管理Transaction，Kafka引入了一个新的组件Transaction Coordinator。Producer就是通过和Transaction Coordinator交互获得Transaction ID对应的任务状态。TransactionCoordinator还负责将事务所有写入Kafka的一个内部Topic，这样即使整个服务重启，由于事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。---Consumer事务上述事务机制主要是从Producer方面考虑，对于Consumer而言，事务的保证就会相对较弱，尤其是无法保证Commit的信息被精确消费。这是由于Consumer可以通过offset访问任意信息，而且不同的Segment File生命周期不同，同一事务的消息可能会出现重启后被删除的情况。</code></pre><h2 id="kafka-API"><a href="#kafka-API" class="headerlink" title="kafka API"></a>kafka API</h2><h3 id="Producer-API"><a href="#Producer-API" class="headerlink" title="Producer API"></a><code>Producer API</code></h3><ul><li>消息发送流程  <pre><code class="hljs plaintext">Kafka的Producer发送消息采用的是异步发送的方式。在消息发送的过程中，涉及到了两个线程——main线程和Sender线程，以及一个线程共享变量——RecordAccumulator。main线程将消息发送给RecordAccumulator，Sender线程不断从RecordAccumulator中拉取消息发送到Kafka broker。---batch.size： 只有数据积累到batch.size之后，sender才会发送数据。linger.ms： 如果数据迟迟未达到batch.size，sender等待linger.time之后就会发送数据。</code></pre>  <img src="/2020/04/21/af-mq-kafka/af-mq-kafka-005.png" alt="抱歉,图片休息了"></li><li>异步发送API  <pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Procuder</span> &#123;    <span class="hljs-comment">// 带回调函数的API</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);        <span class="hljs-comment">// 1.读取kafka生产者的配置信息 具体配置参数可参考ProducerConfig,CommonClientConfigs</span>        <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();        props.load(ClassLoader.getSystemResourceAsStream(<span class="hljs-string">&quot;newProducer.properties&quot;</span>));        <span class="hljs-comment">// 1.1自定义分区拦截器,可选</span>        props.put(ProducerConfig.PARTITIONER_CLASS_CONFIG, <span class="hljs-string">&quot;top.lvzhiqiang.testnewapi.CustomPartitioner&quot;</span>);        <span class="hljs-comment">// 2.创建producer对象</span>        KafkaProducer&lt;String, String&gt; producer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaProducer</span>&lt;&gt;(props);        <span class="hljs-comment">// 3.发送数据</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;testnewapi&quot;</span> + i;            <span class="hljs-comment">// 每条数据都要封装成一个ProducerRecord对象</span>            producer.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;&gt;(<span class="hljs-string">&quot;test&quot;</span>, value), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>() &#123;                <span class="hljs-comment">// 回调函数，该方法会在Producer收到ack时调用，为异步调用。</span>                <span class="hljs-comment">// 该方法有两个参数，分别是RecordMetadata和Exception，如果Exception为null，说明消息发送成功，反之说明消息发送失败。</span>                <span class="hljs-comment">// 注：消息发送失败会自动重试，不需要我们在回调函数中手动重试。</span>                <span class="hljs-meta">@Override</span>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCompletion</span><span class="hljs-params">(RecordMetadata recordMetadata, Exception e)</span> &#123;                    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == e) &#123;                        log.info(<span class="hljs-string">&quot;分区:&#123;&#125;,偏移量:&#123;&#125;,值:&#123;&#125;&quot;</span>, recordMetadata.partition(), recordMetadata.offset(), value);                    &#125; <span class="hljs-keyword">else</span> &#123;                        log.error(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sdf.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()), e);                    &#125;                &#125;            &#125;);        &#125;        <span class="hljs-comment">// 4.关闭资源 会做一些资源的回收(包括拦截器，分区器等资源的收尾处理)，同时防止没达到send的要求时数据发送不出去</span>        producer.close();    &#125;&#125;</code></pre>  <pre><code class="hljs properties"><span class="hljs-comment"># 指定连接的kafka集群，broker-list</span><span class="hljs-attr">bootstrap.servers</span>=<span class="hljs-string">hexo.lvzhiqiang.top:9093,hexo.lvzhiqiang.top:9094</span><span class="hljs-comment"># ack应答级别</span><span class="hljs-attr">acks</span>=<span class="hljs-string">-1</span><span class="hljs-comment"># 重试次数</span><span class="hljs-attr">retries</span>=<span class="hljs-string">3</span><span class="hljs-comment"># 批次大小，默认16k，只有数据积累到batch.size之后，sender才会发送数据</span><span class="hljs-attr">batch.size</span>=<span class="hljs-string">16384</span><span class="hljs-comment"># 等待时间，默认1毫秒，如果数据迟迟未达到batch.size，sender等待linger.time之后就会发送数据</span><span class="hljs-attr">linger.ms</span>=<span class="hljs-string">1</span><span class="hljs-comment"># RecordAccumulator缓冲区大小，默认32M</span><span class="hljs-attr">buffer.memory</span>=<span class="hljs-string">33554432</span><span class="hljs-comment"># key,value的序列化类</span><span class="hljs-attr">key.serializer</span>=<span class="hljs-string">org.apache.kafka.common.serialization.StringSerializer</span><span class="hljs-attr">value.serializer</span>=<span class="hljs-string">org.apache.kafka.common.serialization.StringSerializer</span></code></pre></li><li>同步发送API  <pre><code class="hljs plaintext">同步发送的意思就是，Sender线程在工作发送消息时，同时阻塞main线程，直至Sender线程返回ack来通知main线程继续执行。由于send方法返回的是一个Future对象，根据Futrue对象的特点，我们只需再调用Future对象的get方法即可实现同步发送的效果。</code></pre></li></ul><h3 id="Consumer-API"><a href="#Consumer-API" class="headerlink" title="Consumer API"></a><code>Consumer API</code></h3><ul><li>offset维护  <pre><code class="hljs plaintext">Consumer消费数据时的可靠性是很容易保证的，因为数据在Kafka中是持久化的，故不用担心数据丢失问题。为了使我们能够专注于自己的业务逻辑，Kafka提供了自动提交offset的功能。---虽然自动提交offset十分简洁便利，但由于其是基于时间提交的，开发人员难以把握offset提交的时机。因此Kafka还提供了手动提交offset的API。手动提交offset的方法有两种：分别是commitSync（同步提交）和commitAsync（异步提交）。两者的相同点是，都会将本次poll的一批数据最高的偏移量提交；不同点是，commitSync阻塞当前线程，一直到提交成功，并且会自动失败重试（由不可控因素导致，也会出现提交失败）；而commitAsync则没有失败重试机制，故有可能提交失败。---虽然同步提交offset有失败重试机制，更可靠一些，但是由于其会阻塞当前线程，直到提交成功。因此吞吐量会收到很大的影响。因此更多的情况下，会选用异步提交offset的方式。---无论是同步提交还是异步提交offset，都有可能会造成数据的漏消费或者重复消费。先提交offset后消费，有可能造成数据的漏消费；而先消费后提交offset，有可能会造成数据的重复消费。</code></pre></li><li>自动提交offset  <pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);        <span class="hljs-comment">// 1.读取kafka消费者的配置信息 具体配置参数可参考ConsumerConfig,CommonClientConfigs</span>        <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();        props.load(ClassLoader.getSystemResourceAsStream(<span class="hljs-string">&quot;newConsumer.properties&quot;</span>));        <span class="hljs-comment">// 1.1重置消费者的offset,可选earliest(最早的)和latest(最新的,默认)    换组(没有初始偏移量)或者offset过期(数据被删除)时该属性会生效</span>        <span class="hljs-comment">// earliest:当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费</span>        <span class="hljs-comment">// latest:当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据</span>        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="hljs-string">&quot;earliest&quot;</span>);        <span class="hljs-comment">// 2.创建consumer对象</span>        KafkaConsumer&lt;String, String&gt; consumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaConsumer</span>&lt;&gt;(props);        <span class="hljs-comment">// 3.订阅主题</span>        consumer.subscribe(Collections.singletonList(<span class="hljs-string">&quot;test&quot;</span>));        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-comment">// 4.拉取数据</span>            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="hljs-number">1000L</span>));            <span class="hljs-comment">// 4.1消费数据</span>            <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;                log.info(<span class="hljs-string">&quot;分区:&#123;&#125;,偏移量:&#123;&#125;,值:&#123;&#125;&quot;</span>, record.partition(), record.offset(), record.value());            &#125;        &#125;    &#125;&#125;</code></pre>  <pre><code class="hljs properties"><span class="hljs-comment"># 指定连接的kafka集群，broker-list</span><span class="hljs-attr">bootstrap.servers</span>=<span class="hljs-string">144.34.207.84:9093,144.34.207.84:9094</span><span class="hljs-comment"># 消费者组，只要group.id相同，就属于同一个消费者组</span><span class="hljs-attr">group.id</span>=<span class="hljs-string">test</span><span class="hljs-comment"># 是否开启自动提交offset功能,默认true</span><span class="hljs-attr">enable.auto.commit</span>=<span class="hljs-string">true</span><span class="hljs-comment"># 自动提交offset的时间间隔,默认1S</span><span class="hljs-attr">auto.commit.interval.ms</span>=<span class="hljs-string">1000</span><span class="hljs-comment"># key,value反序列化类</span><span class="hljs-attr">key.deserializer</span>=<span class="hljs-string">org.apache.kafka.common.serialization.StringDeserializer</span><span class="hljs-attr">value.deserializer</span>=<span class="hljs-string">org.apache.kafka.common.serialization.StringDeserializer</span></code></pre></li><li>手动提交offset  <pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ManuallySubmitConsumer</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);        <span class="hljs-comment">// 1.读取kafka消费者的配置信息 具体配置参数可参考ConsumerConfig,CommonClientConfigs</span>        <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();        props.load(ClassLoader.getSystemResourceAsStream(<span class="hljs-string">&quot;newConsumer.properties&quot;</span>));        <span class="hljs-comment">// 1.1重置消费者的offset,可选earliest(最早的)和latest(最新的,默认)</span>        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="hljs-string">&quot;earliest&quot;</span>);        <span class="hljs-comment">// 1.2关闭自动提交offset</span>        props.put(<span class="hljs-string">&quot;enable.auto.commit&quot;</span>, <span class="hljs-string">&quot;false&quot;</span>);        <span class="hljs-comment">// 2.创建consumer对象</span>        KafkaConsumer&lt;String, String&gt; consumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaConsumer</span>&lt;&gt;(props);        <span class="hljs-comment">// 3.订阅主题</span>        consumer.subscribe(Arrays.asList(<span class="hljs-string">&quot;test&quot;</span>));        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-comment">// 4.拉取数据</span>            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="hljs-number">1000L</span>));            <span class="hljs-comment">// 4.1消费数据</span>            <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;                log.info(<span class="hljs-string">&quot;分区:&#123;&#125;,偏移量:&#123;&#125;,值:&#123;&#125;&quot;</span>, record.partition(), record.offset(), record.value());            &#125;            <span class="hljs-comment">// 4.2.a同步提交，当前线程会阻塞直到offset提交成功(重试)才会拉取新的数据</span>            consumer.commitSync();            <span class="hljs-comment">// 4.2.b异步提交</span>            consumer.commitAsync(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OffsetCommitCallback</span>() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onComplete</span><span class="hljs-params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception)</span> &#123;                    <span class="hljs-keyword">if</span> (exception != <span class="hljs-literal">null</span>) &#123;                        log.error(<span class="hljs-string">&quot;Commit failed for &#123;&#125;&quot;</span>, offsets, exception);                    &#125;                &#125;            &#125;);        &#125;    &#125;&#125;</code></pre></li><li>自定义存储offset  <pre><code class="hljs plaintext">offset除了可以存储在zookeeper或者内置的topic中。Kafka还可以选择自定义存储offset。---offset的维护是相当繁琐的，因为需要考虑到消费者的Rebalace。当有新的消费者加入消费者组、已有的消费者退出消费者组或者所订阅的主题的分区发生变化，就会触发到分区的重新分配，重新分配的过程叫做Rebalance。---消费者发生Rebalance之后，每个消费者消费的分区就会发生变化。因此消费者要首先获取到自己被重新分配到的分区，并且定位到每个分区最近提交的offset位置继续消费。要实现自定义存储offset，需要借助ConsumerRebalanceListener，以下为示例代码，其中提交和获取offset的方法，需要根据所选的offset存储系统自行实现。</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomOffsetConsumer</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;TopicPartition, Long&gt; currentOffset = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);        <span class="hljs-comment">// 1.读取kafka消费者的配置信息 具体配置参数可参考ConsumerConfig,CommonClientConfigs</span>        <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();        props.load(ClassLoader.getSystemResourceAsStream(<span class="hljs-string">&quot;newConsumer.properties&quot;</span>));        <span class="hljs-comment">// 1.1重置消费者的offset,可选earliest(最早的)和latest(最新的,默认)</span>        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="hljs-string">&quot;earliest&quot;</span>);        <span class="hljs-comment">// 1.2关闭自动提交offset</span>        props.put(<span class="hljs-string">&quot;enable.auto.commit&quot;</span>, <span class="hljs-string">&quot;false&quot;</span>);        <span class="hljs-comment">// 2.创建consumer对象</span>        KafkaConsumer&lt;String, String&gt; consumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaConsumer</span>&lt;&gt;(props);        <span class="hljs-comment">// 3.订阅主题</span>        consumer.subscribe(Arrays.asList(<span class="hljs-string">&quot;test&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsumerRebalanceListener</span>() &#123;            <span class="hljs-comment">//该方法会在Rebalance之前调用</span>            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPartitionsRevoked</span><span class="hljs-params">(Collection&lt;TopicPartition&gt; partitions)</span> &#123;                commitOffset(currentOffset);            &#125;            <span class="hljs-comment">//该方法会在Rebalance之后调用</span>            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPartitionsAssigned</span><span class="hljs-params">(Collection&lt;TopicPartition&gt; partitions)</span> &#123;                currentOffset.clear();                <span class="hljs-keyword">for</span> (TopicPartition partition : partitions) &#123;                    <span class="hljs-comment">//定位到最近提交的offset位置继续消费</span>                    consumer.seek(partition, getOffset(partition));                &#125;            &#125;        &#125;);        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-comment">// 4.拉取数据</span>            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="hljs-number">1000L</span>));            <span class="hljs-comment">// 4.1消费数据</span>            <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;                log.info(<span class="hljs-string">&quot;分区:&#123;&#125;,偏移量:&#123;&#125;,值:&#123;&#125;&quot;</span>, record.partition(), record.offset(), record.value());            &#125;            <span class="hljs-comment">// 4.2.b异步提交</span>            consumer.commitAsync(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OffsetCommitCallback</span>() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onComplete</span><span class="hljs-params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception)</span> &#123;                    <span class="hljs-keyword">if</span> (exception != <span class="hljs-literal">null</span>) &#123;                        log.error(<span class="hljs-string">&quot;Commit failed for &#123;&#125;&quot;</span>, offsets, exception);                    &#125;                &#125;            &#125;);        &#125;    &#125;    <span class="hljs-comment">//获取某分区的最新offset</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getOffset</span><span class="hljs-params">(TopicPartition partition)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">//提交该消费者所有分区的offset</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commitOffset</span><span class="hljs-params">(Map&lt;TopicPartition, Long&gt; currentOffset)</span> &#123;    &#125;&#125;</code></pre></li></ul><h3 id="自定义Interceptor"><a href="#自定义Interceptor" class="headerlink" title="自定义Interceptor"></a><code>自定义Interceptor</code></h3><ul><li>拦截器原理  <pre><code class="hljs plaintext">Producer拦截器(interceptor)是在 Kafka0.10版本被引入的，主要用于实现clients端的定制化控制逻辑。对于producer而言，interceptor使得用户在消息发送前以及producer回调逻辑前有机会对消息做一些定制化需求，比如修改消息等。同时，producer允许用户指定多个interceptor按序作用于同一条消息从而形成一个拦截链(interceptor chain)。Intercetpor的实现接口是org.apache.kafka.clients.producer.ProducerInterceptor，其定义的方法包括：---(1)configure(configs)：获取配置信息和初始化数据时调用。(2)onSend(ProducerRecord)：该方法封装进KafkaProducer.send方法中，即它运行在用户主线程中。Producer确保在消息被序列化以及计算分区前调用该方法。 用户可以在该方法中对消息做任何操作，但最好保证不要修改消息所属的topic和分区，否则会影响目标分区的计算。(3)onAcknowledgement(RecordMetadata, Exception)：该方法会在消息从RecordAccumulator成功发送到Kafka Broker之后，或者在发送过程中失败时调用。并且通常都是在producer回调逻辑触发之前。onAcknowledgement运行在producer的IO线程中，因此不要在该方法中放入很重的逻辑，否则会拖慢producer的消息发送效率。(4)close：关闭interceptor，主要用于执行一些资源清理工作。</code></pre>  <pre><code class="hljs plaintext">如前所述，interceptor可能被运行在多个线程中，因此在具体实现时用户需要自行确保线程安全。另外倘若指定了多个interceptor，则producer将按照指定顺序调用它们。并仅仅是捕获每个interceptor可能抛出的异常记录到错误日志中而非在向上传递。</code></pre></li><li>案例  <pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProducerInterceptor</span>&lt;String, String&gt; &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">errorCounter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">successCounter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> ProducerRecord <span class="hljs-title function_">onSend</span><span class="hljs-params">(ProducerRecord producerRecord)</span> &#123;        <span class="hljs-comment">// 创建一个新的record，把时间戳写入消息体的最前部</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>(producerRecord.topic(),                producerRecord.partition(),                producerRecord.timestamp(),                producerRecord.key(),                System.currentTimeMillis() + <span class="hljs-string">&quot;,&quot;</span> + producerRecord.value().toString());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAcknowledgement</span><span class="hljs-params">(RecordMetadata recordMetadata, Exception e)</span> &#123;        <span class="hljs-comment">// 统计成功和失败的次数</span>        <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;            successCounter++;        &#125; <span class="hljs-keyword">else</span> &#123;            errorCounter++;        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// 保存结果</span>        log.error(<span class="hljs-string">&quot;Successful sent: &#123;&#125;&quot;</span>, successCounter);        log.error(<span class="hljs-string">&quot;Failed sent: &#123;&#125;&quot;</span>, errorCounter);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(Map&lt;String, ?&gt; map)</span> &#123;    &#125;&#125;</code></pre>  <pre><code class="hljs java">    <span class="hljs-meta">@Slf4j</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterceptorProducer</span> &#123;        <span class="hljs-comment">// 带回调函数的API</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;            <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);            <span class="hljs-comment">// 1.读取kafka生产者的配置信息 具体配置参数可参考ProducerConfig,CommonClientConfigs</span>            <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();            props.load(ClassLoader.getSystemResourceAsStream(<span class="hljs-string">&quot;newProducer.properties&quot;</span>));            <span class="hljs-comment">// 1.1自定义分区器,可选</span>            props.put(ProducerConfig.PARTITIONER_CLASS_CONFIG, <span class="hljs-string">&quot;top.lvzhiqiang.testnewapi.CustomPartitioner&quot;</span>);            <span class="hljs-comment">// 1.2自定义拦截器链,可选</span>            List&lt;String&gt; interceptors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();            interceptors.add(<span class="hljs-string">&quot;top.lvzhiqiang.testnewapi.CustomInterceptor&quot;</span>);            props.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, interceptors);            <span class="hljs-comment">// 2.创建producer对象</span>            KafkaProducer&lt;String, String&gt; producer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaProducer</span>&lt;&gt;(props);            <span class="hljs-comment">// 3.发送数据</span>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;testnewapi&quot;</span> + i;                <span class="hljs-comment">// 每条数据都要封装成一个ProducerRecord对象</span>                producer.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;&gt;(<span class="hljs-string">&quot;test&quot;</span>, value), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>() &#123;                    <span class="hljs-comment">// 回调函数，该方法会在Producer收到ack时调用，为异步调用。</span>                    <span class="hljs-comment">// 该方法有两个参数，分别是RecordMetadata和Exception，如果Exception为null，说明消息发送成功，反之说明消息发送失败。</span>                    <span class="hljs-comment">// 注：消息发送失败会自动重试，不需要我们在回调函数中手动重试。</span>                    <span class="hljs-meta">@Override</span>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCompletion</span><span class="hljs-params">(RecordMetadata recordMetadata, Exception e)</span> &#123;                        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == e) &#123;                            log.info(<span class="hljs-string">&quot;分区:&#123;&#125;,偏移量:&#123;&#125;,值:&#123;&#125;&quot;</span>, recordMetadata.partition(), recordMetadata.offset(), value);                        &#125; <span class="hljs-keyword">else</span> &#123;                            log.error(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sdf.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()), e);                        &#125;                    &#125;                &#125;);            &#125;            <span class="hljs-comment">// 4.关闭资源 一定要关闭producer，这样才会调用interceptor的close方法</span>            producer.close();        &#125;    &#125;    ```  ## kafka监控<span class="hljs-number">1.</span> 修改kafka启动命令</code></pre>  修改kafka-server-start.sh命令中<br>  if [ “x$KAFKA_HEAP_OPTS” &#x3D; “x” ]; then<br>      export KAFKA_HEAP_OPTS&#x3D;”-Xmx512m -Xms512m”<br>  fi<br>  为<br>  if [ “x$KAFKA_HEAP_OPTS” &#x3D; “x” ]; then<br>      #export KAFKA_HEAP_OPTS&#x3D;”-Xmx512m -Xms512m”<br>      export KAFKA_HEAP_OPTS&#x3D;”-server -Xms512m -Xmx512m -XX:PermSize&#x3D;128m -XX:+UseG1GC -XX:MaxGCPauseMillis&#x3D;200 -XX:ParallelGCThreads&#x3D;8 -XX:ConcGCThreads&#x3D;5 -XX:InitiatingHeapOccupancyPercent&#x3D;70”<br>      export JMX_PORT&#x3D;”9999”<br>  fi  <pre><code class="hljs plaintext">2. 下载[kafka-eagle](http://download.kafka-eagle.org)程序包</code></pre>  wget -P &#x2F;opt&#x2F;setups -O kafka-eagle-1.4.7.tar.gz <a href="https://github.com/smartloli/kafka-eagle-bin/archive/v1.4.7.tar.gz">https://github.com/smartloli/kafka-eagle-bin/archive/v1.4.7.tar.gz</a>  <pre><code class="hljs plaintext">3. 解压到指定目录</code></pre><h1 id="mkdir-pv-usr-program"><a href="#mkdir-pv-usr-program" class="headerlink" title="mkdir -pv &#x2F;usr&#x2F;program"></a>mkdir -pv &#x2F;usr&#x2F;program</h1><h1 id="tar-zxvf-kafka-eagle-1-4-7-tar-gz-C-usr-program"><a href="#tar-zxvf-kafka-eagle-1-4-7-tar-gz-C-usr-program" class="headerlink" title="tar -zxvf kafka-eagle-1.4.7.tar.gz -C &#x2F;usr&#x2F;program&#x2F;"></a>tar -zxvf kafka-eagle-1.4.7.tar.gz -C &#x2F;usr&#x2F;program&#x2F;</h1><h1 id="cd-usr-program-kafka-eagle-bin-1-4-7"><a href="#cd-usr-program-kafka-eagle-bin-1-4-7" class="headerlink" title="cd &#x2F;usr&#x2F;program&#x2F;kafka-eagle-bin-1.4.7"></a>cd &#x2F;usr&#x2F;program&#x2F;kafka-eagle-bin-1.4.7</h1><h1 id="tar-zxvf-kafka-eagle-web-1-4-7-bin-tar-gz-C"><a href="#tar-zxvf-kafka-eagle-web-1-4-7-bin-tar-gz-C" class="headerlink" title="tar -zxvf kafka-eagle-web-1.4.7-bin.tar.gz -C ..&#x2F;"></a>tar -zxvf kafka-eagle-web-1.4.7-bin.tar.gz -C ..&#x2F;</h1><h1 id="rm-rf-kafka-eagle-bin-1-4-7"><a href="#rm-rf-kafka-eagle-bin-1-4-7" class="headerlink" title="rm -rf ..&#x2F;kafka-eagle-bin-1.4.7"></a>rm -rf ..&#x2F;kafka-eagle-bin-1.4.7</h1>  <pre><code class="hljs plaintext">4. 配置环境变量</code></pre>  [root@144 ~]# vim &#x2F;etc&#x2F;profile.d&#x2F;my.sh<h1 id="kafka-eagle"><a href="#kafka-eagle" class="headerlink" title="kafka-eagle"></a>kafka-eagle</h1>  KE_HOME&#x3D;&#x2F;usr&#x2F;program&#x2F;kafka-eagle-web-1.4.7<br>  PATH&#x3D;$KE_HOME&#x2F;bin:$PATH<br>  export KE_HOME<br>  export PATH<br>  [root@144 ~]# source &#x2F;etc&#x2F;profile.d&#x2F;my.sh <pre><code class="hljs plaintext">5. 给启动文件执行权限</code></pre><h1 id="chmod-x-KE-HOME-bin-ke-sh"><a href="#chmod-x-KE-HOME-bin-ke-sh" class="headerlink" title="chmod +x ${KE_HOME}&#x2F;bin&#x2F;ke.sh"></a>chmod +x ${KE_HOME}&#x2F;bin&#x2F;ke.sh</h1>  <pre><code class="hljs plaintext">6. 修改配置文件</code></pre>  [root@144 ~]# vim ${KE_HOME}&#x2F;conf&#x2F;system-config.properties<br>  ######################################<h1 id="multi-zookeeper-kafka-cluster-list"><a href="#multi-zookeeper-kafka-cluster-list" class="headerlink" title="multi zookeeper&amp;kafka cluster list"></a>multi zookeeper&amp;kafka cluster list</h1>  ######################################<br>  kafka.eagle.zk.cluster.alias&#x3D;cluster1<br>  cluster1.zk.list&#x3D;127.0.0.1:2181<br>  ######################################<h1 id="kafka-offset-storage"><a href="#kafka-offset-storage" class="headerlink" title="kafka offset storage"></a>kafka offset storage</h1>  ######################################<br>  cluster1.kafka.eagle.offset.storage&#x3D;kafka<br>  ######################################<h1 id="enable-kafka-metrics"><a href="#enable-kafka-metrics" class="headerlink" title="enable kafka metrics"></a>enable kafka metrics</h1>  ######################################<br>  kafka.eagle.metrics.charts&#x3D;true<br>  kafka.eagle.sql.fix.error&#x3D;false<br>  ######################################<h1 id="kafka-jdbc-driver-address"><a href="#kafka-jdbc-driver-address" class="headerlink" title="kafka jdbc driver address"></a>kafka jdbc driver address</h1>  ######################################<br>  kafka.eagle.driver&#x3D;com.mysql.jdbc.Driver<br>  kafka.eagle.url&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;kafka-ke?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;zeroDateTimeBehavior&#x3D;convertToNull<br>  kafka.eagle.username&#x3D;root<br>  kafka.eagle.password&#x3D;000000  <pre><code class="hljs plaintext">7. 启动(需要先启动ZK以及KAFKA)</code></pre>  [root@144 bin]# .&#x2F;ke.sh start<br>  Version 1.4.7 – Copyright 2016-2020<hr><ul><li>Kafka Eagle Service has started success.</li><li>Welcome, Now you can visit ‘<a href="http://ip:8048/ke">http://ip:8048/ke</a>‘</li><li>Account:admin ,Password:123456</li></ul><hr><ul><li><Usage> ke.sh [start|status|stop|restart|stats] </Usage></li><li><Usage> <a href="https://www.kafka-eagle.org/">https://www.kafka-eagle.org/</a> </Usage></li></ul><hr><pre><code></code></pre></li></ul><ol start="8"><li>登录页面查看监控数据<br> <img src="/2020/04/21/af-mq-kafka/af-mq-kafka-010.png" alt="抱歉,图片休息了"></li></ol><h2 id="flume对接kafka"><a href="#flume对接kafka" class="headerlink" title="flume对接kafka"></a>flume对接kafka</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BigData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>度盘命令行下载利器BaiduPCS-Go</title>
      <link href="/2020/04/16/st-baidupcs-go.html"/>
      <url>/2020/04/16/st-baidupcs-go.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%BC%80%E5%A7%8B">开始</a></li><li><a href="%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">常见问题</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>**<a href="https://github.com/iikira/BaiduPCS-Go">BaiduPCS-Go</a>**是一个开源跨平台的度盘命令行客户端，为操作度盘提供实用功能。</li><li>该工具很大程度上解决了在VPS上下载百度云文件速度过慢的问题。</li><li>如果对纯命令形式的操作不习惯，可以参考**<a href="https://github.com/liuzhuoling2011/baidupcs-web">baidupcs-web</a>**使用web界面操作。</li></ul><hr><blockquote><p>1.多平台支持, 支持 Windows, MacOS, Linux, 移动设备等。<br>2.百度帐号多用户支持。<br>3.<a href="https://baike.baidu.com/item/%E9%80%9A%E9%85%8D%E7%AC%A6">通配符</a>匹配网盘路径和Tab自动补齐命令和路径。<br>4.<strong>下载</strong>网盘内文件, 支持多个文件或目录下载, 支持断点续传和单文件并行下载。<br>5.<strong>上传</strong>本地文件, 支持上传大文件(&gt;2GB), 支持多个文件或目录上传。<br>6.<strong>离线下载</strong>, 支持http&#x2F;https&#x2F;ftp&#x2F;电驴&#x2F;磁力链协议。</p></blockquote><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><blockquote><p>Go语言程序, 可直接在<a href="https://github.com/iikira/BaiduPCS-Go/releases">发布页</a>下载使用.<br>可在这里下载最新commit对应的测试版: <a href="https://ci.appveyor.com/project/iikira/baidupcs-go/build/artifacts">https://ci.appveyor.com/project/iikira/baidupcs-go/build/artifacts</a><br>如果程序运行时输出乱码, 请检查下终端的编码方式是否为UTF-8.<br>如果未带任何参数运行程序, 程序将会进入仿Linux shell系统用户界面的cli交互模式, 可直接运行相关命令.<br>cli交互模式下, 光标所在行的前缀应为 BaiduPCS-Go &gt;, 如果登录了百度帐号则格式为 BaiduPCS-Go:&lt;工作目录&gt; &lt;百度ID&gt;$<br>程序会提供相关命令的使用说明.</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><code>安装</code></h3><ul><li>类Unix用户(Linux,MacOS等)<blockquote><p>程序应在终端(Terminal)运行.</p></blockquote></li><li>Windows用户<blockquote><p>程序应在命令提示符(Command Prompt)或PowerShell中运行,在mintty(例如: GitBash)可能会有显示问题.<br>  新手建议直接双击程序运行,进入仿Linux shell的cli交互模式.</p></blockquote></li><li>MacOS用户<blockquote><p>安卓, 建议使用<a href="https://termux.com/">Termux</a>或<a href="https://github.com/NeoTerm/NeoTerm">NeoTerm</a>或终端模拟器, 以提供终端环境.<br>   示例: <a href="https://github.com/iikira/BaiduPCS-Go/wiki/Android-%E8%BF%90%E8%A1%8C%E6%9C%AC%E9%A1%B9%E7%9B%AE%E7%A8%8B%E5%BA%8F%E5%8F%82%E8%80%83%E7%A4%BA%E4%BE%8B">Android运行本项目程序参考示例</a>, 有兴趣的可以参考一下.<br>   苹果iOS,需要越狱,在Cydia搜索下载并安装MobileTerminal,或者其他提供终端环境的软件.<br>   示例: <a href="https://github.com/iikira/BaiduPCS-Go/wiki/iOS-%E8%BF%90%E8%A1%8C%E6%9C%AC%E9%A1%B9%E7%9B%AE%E7%A8%8B%E5%BA%8F%E5%8F%82%E8%80%83%E7%A4%BA%E4%BE%8B">iOS 运行本项目程序参考示例</a>, 有兴趣的可以参考一下.</p></blockquote></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a><code>使用</code></h3><ul><li>登录度盘账号  <pre><code class="hljs plaintext">1.常规登录百度帐号    支持在线验证绑定的手机号或邮箱    BaiduPCS-Go login2.使用百度BDUSS来登录百度帐号    关于获取百度BDUSS可使用相关插件获取，Chrome推荐cookies.txt    BaiduPCS-Go login -bduss=&lt;BDUSS&gt;    例子BaiduPCS-Go login -bduss=1234567</code></pre></li><li>常用选项  <pre><code class="hljs plaintext">USAGE:    BaiduPCS-Go [global options] command [command options] [arguments...]</code></pre>  <pre><code class="hljs plaintext">GLOBAL OPTIONS:      --verbose             启用调试 [$BAIDUPCS_GO_VERBOSE]      --help, -h            show help      --version, -v         print the versionCOMMANDS:    tool                    工具箱    help, h, ?, ？           Shows a list of commands or help for one command  其他:    clear, cls              清空控制台    env                     显示程序环境变量    run                     执行系统命令    sumfile, sf             获取本地文件的秒传信息    update                  检测程序更新  百度帐号:    login [-bduss]          登录百度账号(支持常规登录以及百度BDUSS来登录)    loglist                 列出帐号列表    logout                  退出百度帐号    su [uid]                切换百度帐号    who                     获取当前帐号  百度网盘:    cd [-l]                 切换工作目录(支持切换目录后自动列出目录下的文件和目录及支持通配符)    cp                      拷贝文件/目录    createsuperfile, csf    手动分片上传—合并分片文件    download, d             下载文件/目录    export, ep              导出文件/目录    fixmd5                  修复文件MD5    locate, lt              获取下载直链    ls, l, ll               列出目录(支持-asc,-desc,-time,-name,-size排序)    match                   测试通配符    meta                    获取文件/目录的元信息    mkdir                   创建目录    mv                      移动/重命名文件/目录    offlinedl, clouddl, od  离线下载    pwd                     输出工作目录    quota                   获取网盘配额    rapidupload, ru         手动秒传文件    recycle [l]             回收站    rm                      删除文件/目录(被删除的文件或目录可在网盘文件回收站找回,对删除时要验证有奇效)    search, s               搜索文件(不支持查找目录,默认在当前工作目录搜索)    share                   分享文件/目录    tree, t                 列出目录的树形图    upload, u               上传文件/目录  配置:    config                  显示和修改程序配置项</code></pre></li><li>下载文件&#x2F;目录  <pre><code class="hljs plaintext">BaiduPCS-Go d &lt;网盘文件或目录的路径1&gt; &lt;文件或目录2&gt; &lt;文件或目录3&gt; ...可选参数    --test          测试下载, 此操作不会保存文件到本地    --ow            overwrite, 覆盖已存在的文件    --status        输出所有线程的工作状态    --save          将下载的文件直接保存到当前工作目录    --saveto value  将下载的文件直接保存到指定的目录    -x              为文件加上执行权限, (windows系统无效)    --mode value    下载模式, 可选值: pcs, stream, locate, locate_pan, share, 默认为 locate, 相关说明见上面的帮助 (default: &quot;locate&quot;)    -p value        指定下载线程数 (default: 0)    -l value        指定同时进行下载文件的数量 (default: 0)    --retry value   下载失败最大重试次数 (default: 3)    --nocheck       下载文件完成后不校验文件注意点    下载的文件默认保存到程序所在目录的download/目录,支持自定义指定默认保存目录,重名的文件会自动跳过!    eg：BaiduPCS-Go config set -savedir D:/Downloads下载模式说明    pcs: 通过百度网盘的 PCS API 下载    stream: 通过百度网盘的 PCS API, 以流式文件的方式下载, 效果同 pcs    locate: 默认的下载模式。从百度网盘 Android 客户端, 获取下载链接的方式来下载    locate_pan: 从百度网盘 WEB 首页获取下载链接来下载, 该下载方式需配合第三方服务器, 机密文件切勿使用此下载方式    share: 从网盘文件的分享列表获取文件的下载链接来下载</code></pre></li><li>上传文件&#x2F;目录  <pre><code class="hljs plaintext">BaiduPCS-Go u &lt;本地文件/目录的路径1&gt; &lt;文件/目录2&gt; &lt;文件/目录3&gt; ... &lt;目标目录&gt;注意点    上传默认采用分片上传的方式, 上传的文件将会保存到&lt;目标目录&gt;.    遇到同名文件将会自动覆盖!!    当上传的文件名和网盘的目录名称相同时, 不会覆盖目录, 防止丢失数据.</code></pre></li><li>离线下载  <pre><code class="hljs plaintext">添加离线下载任务    BaiduPCS-Go offlinedl add -path=&lt;离线下载文件保存的路径&gt; 资源地址1 地址2 ...    添加任务成功之后, 返回离线下载的任务ID.精确查询离线下载任务    BaiduPCS-Go offlinedl query 任务ID1 任务ID2 ...查询离线下载任务列表    BaiduPCS-Go offlinedl list取消离线下载任务    BaiduPCS-Go offlinedl cancel 任务ID1 任务ID2 ...删除离线下载任务    BaiduPCS-Go offlinedl delete 任务ID1 任务ID2 ...清空离线下载任务记录, 程序不会进行二次确认, 谨慎操作!!!    BaiduPCS-Go offlinedl delete -all</code></pre></li></ul><h3 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a><code>配置相关</code></h3><ul><li>显示程序环境变量  <pre><code class="hljs plaintext">BAIDUPCS_GO_VERBOSE=&quot;0&quot;                                 是否启用调试BAIDUPCS_GO_CONFIG_DIR=&quot;/root/.config/BaiduPCS-Go&quot;      配置文件路径</code></pre></li><li>显示和修改程序配置项  <pre><code class="hljs plaintext"># 显示配置BaiduPCS-Go config# 设置配置BaiduPCS-Go config set</code></pre>  <pre><code class="hljs plaintext">#设置下载文件的储存目录，默认存在/root/Downloads./BaiduPCS-Go config set -savedir /home#设置下载最大并发量为200，建议值50~500，数值越大速度越高，但太高可能会出问题./BaiduPCS-Go config set -max_parallel 200# 组合设置BaiduPCS-Go config set -max_parallel 150 -savedir D:/Downloads</code></pre></li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li><p>下载速度慢&#x2F;时快时慢</p><blockquote><p>尝试调高下载最大并发量和下载缓存, 以下数据为参考数据<br>BaiduPCS-Go config set -max_parallel 400 -cache_size 65536</p></blockquote></li><li><p>文件名有空格,中括号,或者是特殊字符不能识别</p><blockquote><p>使用双引号扩起文件名，或者在空格, 小括号, 中括号, 特殊字符前加一个反斜杠”&quot;<br>另外, 建议在命名文件时, 不要使用这些字符&#x3D;&#x3D;</p></blockquote></li><li><p>下载速度慢不靠谱方法</p><blockquote><p>加–locate或者–relocate<br>大文件加–nocheck是必须的</p></blockquote></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/iikira/BaiduPCS-Go">https://github.com/iikira/BaiduPCS-Go</a><br><a href="https://www.moerats.com/archives/738">https://www.moerats.com/archives/738</a><br><a href="https://github.com/liuzhuoling2011/baidupcs-web">https://github.com/liuzhuoling2011/baidupcs-web</a></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> 资源下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trojan科学上网：客户端</title>
      <link href="/2020/04/06/st-trojan-advanced.html"/>
      <url>/2020/04/06/st-trojan-advanced.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#Trojan%E5%85%A8%E5%B9%B3%E5%8F%B0%E5%AE%A2%E6%88%B7%E7%AB%AF">Trojan全平台客户端</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>记录trojan的一些进阶使用技巧。</p><h2 id="Trojan全平台客户端"><a href="#Trojan全平台客户端" class="headerlink" title="Trojan全平台客户端"></a>Trojan全平台客户端</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a><code>Windows</code></h3><ul><li>v2rayN<ol><li>Github下载<a href="https://github.com/2dust/v2rayN/releases">v2rayN</a>；网盘下载<img src="/2020/04/06/st-trojan-advanced/dowload.png" width="16" height="16" align="center"><a href="https://pan.baidu.com/s/1s5gDIPgvJN2TdHnp-YsC7A?pwd=8888">网盘下载</a> <code>提取码8888</code>。</li><li>点击左上角服务器图标添加节点。支持剪贴板、二维码、添加[Trojan]等方式。</li><li>选中节点按回车键或者右键选择设为活动服务器，然后主界面下方-》系统代理-》选择自动配置系统代理，软件图标变成红色即表示已经开启翻墙。<pre><code class="hljs plaintext">1. 不能翻墙怎么解决？  1. 修改v2rayN的内核。设置-》参数设置-》Core类型设置，可以尝试对节点切换不同的内核。  2. 同步系统时间。  3. 打开浏览器无痕模式窗口。  4. 多切换节点。  5. 下载旧版本的v2rayN软件。2. 能翻墙但是网速很慢怎么解决？  1. 设置-》路由设置-》绕过大陆，双击添加规则，在Domain中添加以下域名，一行一个域名，然后右击上移置顶。  2. `fonts.googleapis.com,translate.googleapis.com,gstatic.com`。</code></pre></li></ol></li><li>Trojan-Qt5<ol><li>Github下载<a href="https://github.com/Trojan-Qt5/Trojan-Qt5/releases">Trojan-Qt5</a>；网盘下载<img src="/2020/04/06/st-trojan-advanced/dowload.png" width="16" height="16" align="center"><a href="https://pan.baidu.com/s/1_CYwT6VDaZPBSHMrEvs3iQ?pwd=8888">网盘下载</a> <code>提取码8888</code>。</li><li>菜单栏连接-》添加。支持剪贴板、二维码、手动添加[Trojan]、<code>config.json</code>等方式。</li><li>选中节点点击连接，开启翻墙。</li><li>右键图标可更改系统代理模式，包括直连模式、PAC模式、全局模式。</li></ol></li><li>Qv2ray<ol><li>Github下载<a href="https://github.com/Qv2ray/Qv2ray/releases">Qv2ray</a>、<a href="https://github.com/v2ray/v2ray-core/releases">v2ray-core</a>；网盘下载<img src="/2020/04/06/st-trojan-advanced/dowload.png" width="16" height="16" align="center"><a href="https://pan.baidu.com/s/1N5ZRDOYkZaH7oWg9cxziBQ?pwd=8888">网盘下载</a> <code>提取码8888</code>。</li><li>同Mac版。</li></ol></li></ul><hr><ul><li>浏览器插件<br>同MAC版。</li></ul><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a><code>Mac</code></h3><ul><li>Qv2ray<ol><li>Github下载<a href="https://github.com/Qv2ray/Qv2ray/releases">Qv2ray</a>、<a href="https://github.com/v2ray/v2ray-core/releases">v2ray-core</a>、<a href="https://github.com/p4gefau1t/trojan-go/releases">trojan-go</a>；网盘下载<img src="/2020/04/06/st-trojan-advanced/dowload.png" width="16" height="16" align="center"><a href="https://pan.baidu.com/s/1N5ZRDOYkZaH7oWg9cxziBQ?pwd=8888">网盘下载</a> <code>提取码8888</code>。</li><li>文件内容主要包括 Qv2ray客户端、Qv2ray v2ray核心、Qv2ray插件、Qv2ray Trojan-go插件核心（可选）。</li><li>设置中文语言，点击首选项-》常规设置，语言选中 zh_CN，保存后重启即可切换为简体中文。</li><li>设置v2ray核心，将下载好的v2ray核心解压后放入<code>/Applications/qv2ray.app/Contents/</code>，点击首选项-》内核设置，将v2ray可执行文件路径设置为解压好的核心文件夹下的V2ray可执行文件即可，资源目录设置成解压好的核心文件夹即可，然后点击一次”检查v2ray核心设置”，确认核心无误后会弹窗v2ray版本信息。</li><li>安装协议插件，点击插件-》打开本地插件目录，将下载好的插件(后缀.so)拖入至弹出的文件夹内，重启Qv2ray再点击”插件”菜单即可看到已安装的插件。</li><li>添加节点后，可选中节点右键选择连接到此服务器开启翻墙。<pre><code class="hljs plaintext">1. (可选)设置Trojan-Go插件核心，在插件列表中找到Trojan-Go插件，并点击设定，点击选择并定位到解压好的核心文件路径下选择trojan-go可执行文件即可，点击&quot;Test Run&quot;弹窗版本信息即设置成功。2. TODO</code></pre></li></ol></li><li>Trojan-Qt5<ol><li>Github下载<a href="https://github.com/Trojan-Qt5/Trojan-Qt5/releases">Trojan-Qt5</a>；网盘下载<img src="/2020/04/06/st-trojan-advanced/dowload.png" width="16" height="16" align="center"><a href="https://pan.baidu.com/s/1_CYwT6VDaZPBSHMrEvs3iQ?pwd=8888">网盘下载</a> <code>提取码8888</code>。</li><li>同Windows版。</li></ol></li></ul><hr><ul><li>Shadowrocket<ol><li>打开 AppStore，登录美区 Apple ID 账号，美区 Apple ID 注册教程<a href="https://youtu.be/hyopGvMVN1A">https://youtu.be/hyopGvMVN1A</a>。</li><li>搜索小火箭 Shadowrocket，需要购买后才能下载使用。注意不支持Intel芯片的电脑，支持M1-M3芯片的电脑。</li><li>点击全局路由设置翻墙模式。默认是配置，指的是分流规则模式，就是国内网站走直连，国外网站走代理，这个模式会更节省流量；代理，指的是全局模式，就是所有的网站都走代理。</li></ol></li><li>Quantumult X<ol><li>打开 AppStore，登录美区 Apple ID 账号，美区 Apple ID 注册教程同上。</li><li>搜索圈X Quantumult X，需要购买后才能下载使用。</li><li>右击右上角的小风车图标设置翻墙模式。3个图标分别是规则分流模式、全部直连、全部代理。</li><li>Quantumult X 新手入门教程：<a href="https://github.com/kjfx/QuantumultX">https://github.com/kjfx/QuantumultX</a></li></ol></li></ul><hr><ul><li>浏览器插件<ol><li>去<a href="https://github.com/trojan-gfw/trojan/releases">https://github.com/trojan-gfw/trojan/releases</a>下载对应平台trojan官方客户端<br><img src="/2020/04/06/st-trojan-advanced/st-trojan-basic-003.png" alt="抱歉,图片休息了" title="trojan客户端"></li><li>安装SwitchyOmega插件，<img src="/2020/04/06/st-trojan-advanced/dowload.png" width="16" height="16" align="center"><a href="https://pan.baidu.com/s/1nN60uMMsit4XNYS90eASaw">网盘下载</a> <code>提取码8cp7</code>；并设置情景模式。<br><img src="/2020/04/06/st-trojan-advanced/st-trojan-basic-004.png" alt="抱歉,图片休息了" title="SwitchyOmega设置"></li></ol></li></ul><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a><code>Android</code></h3><ul><li>v2rayNG<ol><li>Github下载<a href="https://github.com/2dust/v2rayNG/releases">v2rayNG</a>；网盘下载<img src="/2020/04/06/st-trojan-advanced/dowload.png" width="16" height="16" align="center"><a href="https://pan.baidu.com/s/1R960U-r8URwrH9jMgrT_oQ?pwd=8888">网盘下载</a> <code>提取码8888</code>。</li><li>点击右上角+号添加节点。支持剪贴板、二维码、手动输入[Trojan]等方式。</li><li>点击右下角开关图标开启翻墙，然后点击下方灰色部分查看能不能使用及延迟大小；重新点击该图标即关闭翻墙。</li><li>点击左上角图标进入设置选项，找到路由设置&#x3D;》预定义规则，默认是全局代理，一般选择绕过局域网及大陆地址而后代理，这个会更节省流量。</li></ol></li><li>Igniter<ol><li>Github下载<a href="https://github.com/trojan-gfw/igniter/releases">igniter</a>；网盘下载<img src="/2020/04/06/st-trojan-advanced/dowload.png" width="16" height="16" align="center"><a href="https://pan.baidu.com/s/1LKOjYQWgtGexbo6IO00WgA?pwd=8888">网盘下载</a> <code>提取码8888</code>。</li><li>分别输入域名、端口、密码，可开启过滤大陆域名&#x2F;IP，点击连接开启翻墙。<br><img src="/2020/04/06/st-trojan-advanced/st-trojan-basic-005.png" alt="抱歉,图片休息了" title="Igniter客户端"></li></ol></li></ul><h3 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a><code>IOS</code></h3><ul><li>Shadowrocket<br>同MAC版。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://naiyous.com/3717.html">https://naiyous.com/3717.html</a><br><a href="https://v2rayssr.com/trojancdn.html">https://v2rayssr.com/trojancdn.html</a><br><a href="https://github.com/Loyalsoldier/v2ray-rules-dat">https://github.com/Loyalsoldier/v2ray-rules-dat</a><br><a href="https://johnshall.github.io/Shadowrocket-ADBlock-Rules-Forever">https://johnshall.github.io/Shadowrocket-ADBlock-Rules-Forever</a><br><a href="https://github.com/gfwlist/gfwlist">SwitchyOmega规则GFWList</a></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> 科学上网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPS离线BT下载利器</title>
      <link href="/2020/04/06/st-vps-bt.html"/>
      <url>/2020/04/06/st-vps-bt.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="%E9%83%A8%E7%BD%B2">部署</a></li><li><a href="%E5%8F%96%E5%9B%9E%E6%9C%AC%E5%9C%B0">取回本地</a></li><li><a href="%E5%B8%B8%E7%94%A8tracker">常用tracker</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>VPS的用途很多，本次介绍几种常用的服务器下载BT的利器，体验千兆网络的魅力。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ul><li>qBittorrent功能非常强大,支持添加tracker,DHT等,但是占用系统资源(内存)比较大，如果服务器还要做一些其它的工作，用这个可能就不太合适了。</li><li>Transmission占用系统资源少，对硬件的配置要求非常的低，甚至在路由器上面都可以运行，对于需要长期挂着是一个很好的选择。</li></ul><h3 id="qBittorrent"><a href="#qBittorrent" class="headerlink" title="qBittorrent"></a><code>qBittorrent</code></h3><ol><li>docker安装 <pre><code class="hljs plaintext">docker pull linuxserver/qbittorrent</code></pre></li><li>完成后输入 <pre><code class="hljs plaintext">docker create \  --name=qbittorrent \  -e PUID=1000 \  -e PGID=1000 \  -e TZ=Aisa/Shanghai \  -e UMASK_SET=022 \  -e WEBUI_PORT=8080 \  -p 8999:8999 \  -p 8999:8999/udp \  -p 8080:8080 \  -v /path/to/appdata/config:/config \  -v /path/to/downloads:/downloads \  --restart unless-stopped \  linuxserver/qbittorrent</code></pre></li><li>创建好后启动 <pre><code class="hljs plaintext">docker start qbittorrent</code></pre></li><li>进入主界面 <pre><code class="hljs plaintext">1.输入IP:端口号即可进入qbittorrent 的管理界面2.默认账号密码admin/admin3.进入&quot;Option-&gt;Web UI-&gt;Language&quot;,将语言设置成中文4.进入&quot;Option-&gt;高级&quot;,勾选&quot;总是向同级的所有Tracker汇报&quot;,适合下载一些冷门的资源5.进入&quot;Option-&gt;BitTorrent&quot;,可在做种限制中勾选&quot;当分享率达到&quot;,来设置上传大小,例如设置2代表当上传2倍大小时就停止上传给其他用户6.进入&quot;Option-&gt;BitTorrent&quot;,勾选&quot;自动添加以下tracker到新的torrent&quot;,来提高下载速度</code></pre><img src="/2020/04/06/st-vps-bt/st-vps-bt-001.png" alt="抱歉,图片休息了" title="qbittorrent"></li></ol><h3 id="Transmission"><a href="#Transmission" class="headerlink" title="Transmission"></a><code>Transmission</code></h3><ol><li>docker安装 <pre><code class="hljs plaintext">docker run -d \--restart=always \--name transmission \-v /path3/to/torrents:/to_download \-v /path3/to/download:/output \-p 9091:9091 \-p 51413:51413 \-e USERNAME=admin \-e PASSWORD=admin \jaymoulin/transmission</code></pre></li><li>进入主界面 <pre><code class="hljs plaintext">1.输入IP:9091即可进入transmission 的管理界面2.默认账号密码是空,按回车就可以进入</code></pre><img src="/2020/04/06/st-vps-bt/st-vps-bt-003.png" alt="抱歉,图片休息了" title="Transmission"></li></ol><h3 id="Aria2"><a href="#Aria2" class="headerlink" title="Aria2"></a><code>Aria2</code></h3><ol><li>docker安装 <pre><code class="hljs plaintext"># 最快速启动docker run -d --name aria2-ui -v /path2/down:/data -p 80:80 wahyd4/aria2-ui</code></pre> <pre><code class="hljs plaintext"># 加密下载界面docker run -d --name ariang \  -p 80:80 \  -e PUID=1000 \  -e PGID=1000 \  -e ENABLE_AUTH=true \  -e RPC_SECRET=Hello \  -e ARIA2_SSL=false \  -e ARIA2_USER=user \  -e ARIA2_PWD=pwd \  -v /home/down:/data \  wahyd4/aria2-ui</code></pre></li><li>进入主界面 <pre><code class="hljs plaintext">Aria2: http://ip:port/ui/FileManger: http://ip:portFileManger可作为网盘来使用,说caddy的功能差不多</code></pre></li><li>补充<ul><li>根据个人的需求来选择，如果觉得不需要加密Aria2的管理界面的，其实用第一种方式就行了。非常简单，一行命令即可。</li><li>同时也可以结合TransdroneAPP来使用，使用它来管理多个下载工具也是比较方便的。<img src="/2020/04/06/st-vps-bt/dowload.png" width="16" height="16" align="center"><a href="https://pan.baidu.com/s/19Nj1htcK49zyexF9qP7Stw">网盘下载</a> <code>提取码v7aa</code><br><img src="/2020/04/06/st-vps-bt/st-vps-bt-004.png" alt="抱歉,图片休息了" title="Aria2主界面"><br><img src="/2020/04/06/st-vps-bt/st-vps-bt-005.png" alt="抱歉,图片休息了" title="FileManger主界面"></li></ul></li></ol><h2 id="取回本地"><a href="#取回本地" class="headerlink" title="取回本地"></a>取回本地</h2><ul><li>下载好的文件存在服务器里，想把它取回到电脑或者手机，有以下几种方法。 </li><li>第三种适合于临时下载的，前两种适合长时间的。如果机器本身有装docker，那我建议使用第二种。当然第一种也有好处，就是可以绑定指定的域名。</li><li>各取所需吧，适合自己的需求的才是最好的。</li></ul><h3 id="安装caddy"><a href="#安装caddy" class="headerlink" title="安装caddy"></a><code>安装caddy</code></h3><ol><li>安装 <pre><code class="hljs plaintext">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/caddy_install.sh &amp;&amp; chmod +x caddy_install.sh &amp;&amp; bash caddy_install.sh</code></pre></li><li>写入配置 <pre><code class="hljs plaintext">echo &quot;:2015 &#123;   root /path/to/downloads timeouts none   gzip   browse  &#125;&quot; &gt; /usr/local/caddy/Caddyfile</code></pre></li><li>启动caddy <pre><code class="hljs plaintext">/etc/init.d/caddy start</code></pre></li><li>浏览器访问 <pre><code class="hljs plaintext">1.如不能访问,记得开放相关端口2.完成后就可以在浏览器里，输入IP地址:端口号来访问下载好的文件了。如果是MP4文件的话，还可以支持在线播放。3.默认密码是admin/adminadmin</code></pre><img src="/2020/04/06/st-vps-bt/st-vps-bt-002.png" alt="抱歉,图片休息了" title="caddy"></li></ol><h3 id="h5ai"><a href="#h5ai" class="headerlink" title="h5ai"></a><code>h5ai</code></h3><blockquote><p>这是一个 PHP 程序，原本它是要求机器本身有 PHP 才能用的，不过现在使用 docker 来安装的话，也可以非常迅速就安装好。</p></blockquote><pre><code class="hljs plaintext">docker run -d -p 8055:80 -v /home/tr/download:/h5ai --name h5ai ilemonrain/h5ai:full -d</code></pre><p>装好后在浏览器输入 ip:8085 就可以看到里面的内容</p><h3 id="python-web"><a href="#python-web" class="headerlink" title="python web"></a><code>python web</code></h3><p>这个是最简单的，基本所有的服务器都可以，而且不用额外安装其它的程序。只需要在 ssh 时进入到指定的文件夹，然后输入这条命令即可。</p><pre><code class="hljs plaintext">python -m SimpleHTTPServer</code></pre><p>会默认采用8000端口,此时输入 <strong>IP:8000</strong> 或者 <strong>域名:8000</strong> ，即可访问当前目录下的文件，如果有 index.html 则会默认加载。</p><p>然后想要停止时，按<code>CTRL + C</code> 取消。<br>不过这种方法有挺多缺点的，比如不支持断点续传，开启时需一直保持 ssh 连接着，显示的文件信息简陋等。</p><h2 id="常用tracker"><a href="#常用tracker" class="headerlink" title="常用tracker"></a>常用tracker</h2><p><a href="https://github.com/ngosang/trackerslist">https://github.com/ngosang/trackerslist</a><br><a href="https://trackerslist.com/all.txt">https://trackerslist.com/all.txt</a><br><img src="/2020/04/06/st-vps-bt/st-vps-bt-006.png" alt="抱歉,图片休息了" title="tracker"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://powersee.github.io/">https://powersee.github.io</a><br><a href="https://github.com/c0re100/qBittorrent-Enhanced-Edition">https://github.com/c0re100/qBittorrent-Enhanced-Edition</a><br><a href="https://github.com/ronggang/transmission-web-control">https://github.com/ronggang/transmission-web-control</a><br><a href="https://github.com/wahyd4/aria2-ariang-docker">https://github.com/wahyd4/aria2-ariang-docker</a></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> 科学上网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令行下载神器youtube-dl</title>
      <link href="/2020/03/29/st-youtube-dl.html"/>
      <url>/2020/03/29/st-youtube-dl.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%BC%80%E5%A7%8B">开始</a></li><li><a href="%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">常见问题</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><a href="https://github.com/ytdl-org/youtube-dl">youtube-dl</a> 是一个开源跨平台的命令行下载神器，可以从YouTube.com和其他一些网站中下载视频。</li><li>支持的网站列表：<a href="https://ytdl-org.github.io/youtube-dl/supportedsites.html">https://ytdl-org.github.io/youtube-dl/supportedsites.html</a></li><li>如果需要使用图形化工具界面操作，可以下载 <a href="https://github.com/MrS0m30n3/youtube-dl-gui">youtube-dl-gui</a>。</li><li>与之类似的还有 <a href="https://github.com/soimort/you-get">you-get</a>，这个工具对国内的网站支持的比较好一些。</li><li>如果需要下载的视频网站现在不能用youtube-dl下载的,可以试试You-Get，配合起来用。</li></ul><hr><p>下载油管视频的前提是能够科学上网，这里介绍几种下载视频&#x2F;音频的思路。</p><ol><li>浏览器在线下载(简单快捷，上手最快)<ul><li>可以通过一些网站提供的在线下载服务进行下载，比如下边这些网站，只需要将youtube视频网址粘贴一下，就可以下载。</li><li><a href="https://en.savefrom.net/1-youtube-video-downloader-1/">https://en.savefrom.net/1-youtube-video-downloader-1/</a></li><li><a href="https://www.youtuhi.com/">https://www.youtuhi.com/</a></li></ul></li><li>浏览器插件(上手稍慢，可以边看边下载)<ul><li>方法1,先安装油猴Tampermonkey插件,再去搜索相应的视频下载脚本。</li><li>方法2,直接安装相应的视频下载插件。</li></ul></li><li>命令行下载程序(上手难度大，功能最强大)<ul><li>这类的也有很多,例如上面提到的youtube-dl、you-get,有些还有相应的图形化工具。</li></ul></li></ol><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><code>安装</code></h3><ul><li><p>类Unix用户(Linux,MacOS等)</p>  <pre><code class="hljs plaintext">sudo curl -L https://yt-dl.org/downloads/latest/youtube-dl -o /usr/local/bin/youtube-dlsudo chmod a+rx /usr/local/bin/youtube-dl</code></pre>  <pre><code class="hljs plaintext">sudo wget https://yt-dl.org/downloads/latest/youtube-dl -O /usr/local/bin/youtube-dlsudo chmod a+rx /usr/local/bin/youtube-dl</code></pre></li><li><p>Windows用户</p><ol><li>从 <a href="https://ffmpeg.org/">ffmpeg官网</a> 下载 <a href="https://ffmpeg.zeranoe.com/builds/">ffmpeg</a>，注意选择Windows版本，解压后放到任意目录。</li><li>从 <a href="http://ytdl-org.github.io/youtube-dl">youtube-dl官网</a> 下载 <a href="https://ytdl-org.github.io/youtube-dl/download.html">youtube-dl.exe</a>，然后放在上一步得到ffmpeg的<code>bin</code>目录下。</li><li>将ffmpeg的bin文件夹（D:\ffmpeg\bin）路径加入系统PATH里面。</li><li>测试ffmpeg与youtube-dl，打开命令行，分别输入<code>ffmpeg -version;youtube-dl --version</code>，没报错就成功了。</li></ol><hr>  <pre><code class="hljs plaintext">Tips：1. 升级ffmpeg，去官网按照系统下载最新版、替换即可。2. 升级youtube-dl，只需要在命令行里面运行`youtube-dl --proxy  &quot;http://127.0.0.1:1080&quot;  -U`。3. 设置环境变量时不要放入%SYSTEMROOT%\System32（例如，不要放入C:\Windows\System32）。</code></pre></li><li><p>MacOS用户</p>  <pre><code class="hljs plaintext">可以使用Homebrew安装youtube-dl：brew install youtube-dl</code></pre></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a><code>使用</code></h3><pre><code class="hljs plaintext">youtube-dl [OPTIONS] URL [URL...]    程序自动选择一个最清晰的格式下载视频/播放列表    默认情况下，youtube-dl尝试下载最佳质量，即如果您希望获得最佳质量，则不需要通过任何特殊选项，youtube-dl将默认为您猜测。</code></pre><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a><code>选项</code></h3><ul><li>查看相关<pre><code class="hljs plaintext">-h, --help                  命令帮助--version                   查看程序版本-U, --update                更新程序到最新版本。确保您有足够的权限（如果需要，使用sudo运行）--list-extractors           列出所有支持的提取器/网站列表--extractor-descriptions    列出所有支持的提取器的输出描述--flat-playlist             不提取播放列表中的视频，只列出它们-F                          查看视频有哪些格式，方便进行针对型的下载</code></pre></li><li>下载相关<pre><code class="hljs plaintext">-i, --ignore-errors                     当下载错误时继续，例如跳过播放列表中不可用的视频--cookies /path/to/cookies/file.txt     将Cookie传递给youtube-dl(私人视频需要)-f, --format [format code/best/worst]   下载指定格式的视频，或者选择带有视频和音频的单个文件代表的最佳质量/质量最差格式。默认：-f bestvideo+bestaudio/best--download-archive /path/to/file.txt    仅从播放列表下载最新视频--proxy URL                             Use the specified HTTP/HTTPS/SOCKS proxy.For example socks5://127.0.0.1:1080/.--skip-download                         不下载视频，例如只下载字幕文件、图片等等</code></pre><pre><code class="hljs plaintext">--write-sub                             下载视频的所有可用字幕中的默认第一个(Available subtitles)--all-subs                              下载视频的所有可用字幕(Available subtitles)--write-auto-sub                        下载视频的自动生成的字幕文件中的默认第一个(YouTube only)--list-subs                             列出视频的所有可用字幕(油管的字幕分为系统自动生成的字幕和手动上传的字幕)--sub-format FORMAT                     字幕格式，接受格式首选项，例如：“srt”或“ass/srt/best”--sub-lang LANGS                        要下载的字幕的语言（可选）用逗号分隔，需搭配write-auto-sub一起使用--write-thumbnail                       将缩略图写入磁盘--write-all-thumbnails                  将所有缩略图格式写入磁盘--list-thumbnails                       模拟并列出所有可用的缩略图格式--write-description                     Write video description to a .description file--write-info-json                       Write video metadata to a .info.json file--write-annotations                     Write video annotations to a .annotations.xml file</code></pre><pre><code class="hljs plaintext">--date/datebefore/dateafter DATE        Download only videos uploaded in this date or before or after    绝对日期：日期格式YYYYMMDD。    相对日期：日期格式 (now|today)[+-][0-9](day|week|month|year)(s)?    $ youtube-dl --dateafter now-6months   //仅下载最近6个月内上传的视频     $ youtube-dl --date 19700101  //仅下载1970年1月1日上载的视频     $ youtube-dl --dateafter 20000101 --datebefore 20091231   仅下载200x十年期间上传的视频</code></pre></li><li>输出选项<pre><code class="hljs plaintext">-o, --output TEMPLATE                   Output filename template, see the &quot;OUTPUT TEMPLATE&quot; for all the infoeg: -o &quot;%(autonumber)05d-%(upload_date)s-%(title)s-%(id)s.%(ext)s&quot;--------------id （字符串）：视频标识符title （字符串）：视频标题url （字符串）：视频网址ext （字符串）：视频文件扩展名alt_title （字符串）：视频的辅助标题display_id （字符串）：视频的备用标识符uploader （字符串）：视频上传者的全名license （字符串）：视频使用许可的许可名称creator （字符串）：视频的创建者release_date （字符串）：视频发布的日期（YYYYMMDD）timestamp （数字）：视频可用的那一刻的UNIX时间戳。upload_date （字符串）：视频上传日期（YYYYMMDD）uploader_id （字符串）：视频上传者的昵称或IDchannel （字符串）：上传视频的频道的全名channel_id （字符串）：频道的IDlocation （字符串）：录制视频的实际位置duration （数字）：视频长度（以秒为单位）view_count （数字）：有多少用户在平台上观看了视频like_count （数字）：视频的正面评价数dislike_count （数字）：视频的负面评价数repost_count （数字）：视频的转发次数average_rating （数字）：用户给出的平均评分，所使用的比例取决于网页comment_count （数字）：视频评论数age_limit （数字）：视频的年龄限制（年）is_live （布尔值）：此视频是实时流还是固定长度的视频start_time （数字）：开始播放的时间（以秒为单位），如URL中所指定end_time （数字）：复制应结束的时间（以秒为单位），如URL中所指定format （字符串）：格式的易于理解的描述format_id （字符串）：指定的格式代码 --formatformat_note （字符串）：有关格式的其他信息width （数字）：视频的宽度height （数字）：视频的高度resolution （字符串）：宽度和高度的文字描述tbr （数字）：音频和视频的平均比特率，单位为KBit / sabr （数字）：平均音频比特率，单位为KBit / sacodec （字符串）：使用中的音频编解码器的名称asr （数字）：音频采样率，以赫兹为单位vbr （数字）：平均视频比特率，单位为KBit / sfps （数字）：帧频vcodec （字符串）：正在使用的视频编解码器的名称container （字符串）：容器格式的名称filesize （数字）：字节数（如果事先知道）filesize_approx （数字）：估计的字节数protocol （字符串）：将用于实际下载的协议extractor （字符串）：提取器的名称extractor_key （字符串）：提取器的键名epoch （数字）：创建文件时的Unix纪元autonumber （数字）：五位数字，每次下载都会增加，从零开始playlist （字符串）：包含视频的播放列表的名称或IDplaylist_index （数字）：播放列表中视频的索引，根据播放列表的总长度用前导零填充playlist_id （字符串）：播放列表标识符playlist_title （字符串）：播放列表标题playlist_uploader （字符串）：播放列表上传者的全名playlist_uploader_id （字符串）：播放列表上传者的昵称或ID</code></pre></li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li>经常更新youtube-dl保证功能最新而且稳定 <pre><code class="hljs plaintext">根据经验，youtube-dl每月至少发布一次，并且通常每周发布一次，甚至每天发布一次。youtube-dl -U</code></pre></li><li>安装ffmpeg获取高质量视频(安装步骤见参考链接) <pre><code class="hljs plaintext">youtube-dl在大多数网站上都能正常运行，但是如果需要下载更高质量的视频，则需要avconv或ffmpeg。当youtube-dl知道某个特定的下载程序对于给定的网站效果更好时，就会选择该下载程序。否则youtube-dl会选择最佳的下载器以实现一般兼容性，而目前恰好是ffmpeg。</code></pre> <pre><code class="hljs plaintext">youtube默认使用bestvideo+bestaudio/best格式选项,如果安装了ffmpeg或avconv，则将导致分别下载bestvideo和混合bestaudio并将它们混合到一个文件中，从而提供最佳的整体质量。否则，它会退回best并导致以单个文件的形式下载最佳质量的文件。如果您不希望获得分辨率高于1080p的视频，则可以添加-f bestvideo[height&lt;=?1080]+bestaudio/best到您的配置文件。</code></pre></li><li>将下载内容放入特定文件夹 <pre><code class="hljs plaintext">使用-o来指定输出模板，例如-o &quot;/home/user/videos/%(title)s-%(id)s.%(ext)s&quot;。如果您希望所有下载都使用此选项，请将选项放入配置文件中。</code></pre></li><li>将Cookie传递给youtube-dl <pre><code class="hljs plaintext">使用--cookies选项，例如--cookies /path/to/cookies/file.txt。为了从浏览器中提取Cookie，请使用任何符合要求的浏览器扩展程序来导出Cookie。当特定提取程序未明确实现Cookie时，将cookie传递给youtube-dl是解决登录问题的好方法。</code></pre></li><li>仅从播放列表下载新视频 <pre><code class="hljs plaintext">使用下载存档功能。使用--download-archive先下载完整的播放列表，该列表会将所有视频的标识符记录在一个特殊文件中。随后的每次相同运行均--download-archive将仅下载新视频，并跳过之前已下载的所有视频。请注意，只有成功的下载记录在文件中。</code></pre></li><li>检测youtube-dl是否支持给定的URL <pre><code class="hljs plaintext">首先查看支持的站点列表。请注意有时网站可能会更改其网址方案（例如，从https://example.com/video/1234567更改为https://example.com/v/1234567）而youtube-dl报告的网址为该列表中的服务不受支持。在这种情况下，只需报告一个issues。</code></pre></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/ytdl-org/youtube-dl">https://github.com/ytdl-org/youtube-dl</a><br><a href="https://github.com/MrS0m30n3/youtube-dl-gui">https://github.com/MrS0m30n3/youtube-dl-gui</a><br><a href="https://my.oschina.net/ososchina/blog/827182">https://my.oschina.net/ososchina/blog/827182</a></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul><pre><code class="hljs plaintext">youtube-dl -F -i --proxy &quot;socks5://127.0.0.1:1080&quot; --cookies /opt/setups/cookies.txt --download-archive archive.txt --write-info-json --all-subs --write-all-thumbnails -o &quot;%(upload_date)s_%(title)s_%(id)s.%(ext)s&quot;# 只下载音频而不下载视频# 同时指定音频格式(aac、flac、mp3、m4a、opus、vorbis、wav，默认为best)# 同时指定音频的质量（0到9，默认5，数值越小越好）youtube-dl -x --audio-format flac --audio-quality 0 https://www.youtube.com/watch?v=9MpO8lw_Rj4# 下载视频youtube-dl -i -o &quot;C:\Users\l1024v\Desktop\%(upload_date)s_%(title)s_%(id)s_%(width)s*%(height)s.%(ext)s&quot; &quot;https://zh.chaturbate.com/sellapink&quot;youtube-dl -i -o &quot;C:\Users\l1024v\Desktop\%(upload_date)s_%(title)s_%(id)s_%(width)s*%(height)s.%(ext)s&quot; &quot;https://www.youtube.com/watch?v=_rEG3jesVfM&quot;youtube-dl -i -o &quot;C:\Users\l1024v\Desktop\%(upload_date)s_%(title)s_%(id)s_%(width)s*%(height)s.%(ext)s&quot; &quot;https://space.bilibili.com/1371751867/favlist?fid=970837181&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> 资源下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trojan科学上网：搭建</title>
      <link href="/2020/03/08/st-trojan-basic.html"/>
      <url>/2020/03/08/st-trojan-basic.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E9%83%A8%E7%BD%B2">部署</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93">常见问题总结</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>介绍  <pre><code class="hljs plaintext">Trojan模仿了互联网上最常见的Https协议,以诱骗GFW封锁认为它就是Https,从而不被识别.Trojan处理来自外界的Https请求,如果是合法的,那么为该请求提供服务,否则将该流量转交给Web服务器Nginx,由Nginx为其提供服务.基于这个工作过程可以知道,Trojan的一切表现与Nginx一致,不会引入额外特征,从页达到无法识别的效果.</code></pre></li><li>Trojan与V2ray ws协议的区别  <pre><code class="hljs plaintext">V2ray是Nginx侦听443,数据-&gt;Nginx-&gt;V2ray;Trojan是自己侦听443,都是伪装成网站.</code></pre></li><li>Trojan-Go访问原理<pre><code class="hljs plaintext">当一个客户端试图连接Trojan-Go的监听端口时，会发生下面的事情：如果TLS握手成功，检测到TLS的内容非Trojan协议（有可能是HTTP请求，或者来自GFW的主动探测）。Trojan-Go将TLS连接代理到本地127.0.0.1:80上的HTTP服务。这时在远端看来，Trojan-Go服务就是一个HTTPS网站。如果TLS握手成功，并且被确认是Trojan协议头部，并且其中的密码正确，那么服务器将解析来自客户端的请求并进行代理，否则和上一步的处理方法相同。如果TLS握手失败，说明对方使用的不是TLS协议进行连接。此时Trojan-Go将这个TCP连接代理到本地127.0.0.1:1234上运行的HTTPS服务（或者HTTP服务），返回一个展示400 Bad Reqeust的HTTP页面。fallback_port是一个可选选项，如果没有填写，Trojan-Go会直接终止连接。虽然是可选的，但是还是强烈建议填写。</code></pre></li></ul><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><code>准备工作</code></h3><ul><li>►更新系统安装环境<pre><code class="hljs bash"><span class="hljs-comment"># 更新系统</span>yum update -y  <span class="hljs-comment">#CentOS</span>apt update -y  <span class="hljs-comment">#Debian</span><span class="hljs-comment"># 安装curl｜wget</span>yum install -y curl  <span class="hljs-comment">#CentOS</span>yum install -y wget  <span class="hljs-comment">#CentOS</span>apt-get install wget  <span class="hljs-comment">#Debian Ubuntu</span>apt-get install curl  <span class="hljs-comment">#Debian Ubuntu</span></code></pre></li><li>►安装开心版宝塔(免手机验证)<ul><li>直接安装V7.7.0的版本，之后的版本都会验证userInfo.json，虽然网上有大把的开心版，但不敢用。<pre><code class="hljs bash"><span class="hljs-comment"># Centos/Ubuntu/Debian安装命令 独立运行环境（py3.7）</span>curl -sSO https://raw.githubusercontent.com/8838/btpanel-v7.7.0/main/install/install_panel.sh &amp;&amp; bash install_panel.sh<span class="hljs-comment"># 备用安装链接，适用于不能访问GitHub的服务器。</span>curl -sSO http://d.moe.ms/AAAAA/btpanel-v7.7.0/install/install_panel.sh &amp;&amp; bash install_panel.sh</code></pre></li><li>屏蔽手机号<pre><code class="hljs bash">sed -i <span class="hljs-string">&quot;s|bind_user == &#x27;True&#x27;|bind_user == &#x27;XXXX&#x27;|&quot;</span> /www/server/panel/BTPanel/static/js/index.js</code></pre></li><li>删除强制绑定手机js文件<pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -f /www/server/panel/data/bind.pl</code></pre></li><li>手动解锁宝塔所有付费插件为永不过期<pre><code class="hljs plaintext">文件路径：/www/server/panel/data/plugin.json，搜索字符串：&quot;endtime&quot;: -1全部替换为&quot;endtime&quot;: 999999999999给plugin.json文件上锁防止自动修复为免费版：chattr +i /www/server/panel/data/plugin.json</code></pre></li></ul></li><li>►开启 BBR 加速<ul><li>开启Debian10自带的BBR加速<pre><code class="hljs bash"><span class="hljs-comment"># 本脚本只针对 Debian≥9 或是 CentOS≥8 以上的系统，可以开启系统自带BBR加速。</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;net.core.default_qdisc=fq&quot;</span> &gt;&gt; /etc/sysctl.conf<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;net.ipv4.tcp_congestion_control=bbr&quot;</span> &gt;&gt; /etc/sysctl.confsysctl -plsmod | grep bbr</code></pre></li><li>四合一 BBR Plus &#x2F; 原版BBR &#x2F; 魔改BBR<pre><code class="hljs bash"><span class="hljs-comment"># Centos 7, Debian 8/9, Ubuntu 16/18 测试通过, 不支持 OVZ</span>wget -N --no-check-certificate <span class="hljs-string">&quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot;</span> &amp;&amp; <span class="hljs-built_in">chmod</span> +x tcp.sh &amp;&amp; ./tcp.sh</code></pre></li></ul></li></ul><h3 id="安装Trojan-go面板"><a href="#安装Trojan-go面板" class="headerlink" title="安装Trojan-go面板"></a><code>安装Trojan-go面板</code></h3><blockquote><p>提前准备好trojan-web面板域名和trojan服务域名</p></blockquote><ol><li>Jrohy的一键Trojan面板脚本  <pre><code class="hljs bash"><span class="hljs-comment">#安装/更新</span><span class="hljs-built_in">source</span> &lt;(curl -sL https://git.io/trojan-install)<span class="hljs-comment">#卸载</span><span class="hljs-built_in">source</span> &lt;(curl -sL https://git.io/trojan-install) --remove</code></pre></li><li>修改trojan-web端口  <pre><code class="hljs bash">/etc/systemd/system/trojan-web.service在/usr/local/bin/trojan web 后面添加 -p portsystemctl daemon-reloadsystemctl restart trojan-web</code></pre></li><li>trojan设置  <pre><code class="hljs bash"><span class="hljs-comment"># 修改端口</span>  /usr/local/etc/trojan/config.json<span class="hljs-comment"># 申请证书报错</span>  netstat -ntlp  采用命令 sudo fuser -k 80/tcp 强制 杀掉进程  nginx<span class="hljs-comment"># 连接被墙的外网就No route to host：</span>  切换trojan-go版本解决</code></pre></li><li>更改Trojan-Go配置文件(可选)  <pre><code class="hljs plaintext"># 找到VPS目录文件 /usr/local/etc/trojan/config.json ，备份一份（若是把类型切换回来可以恢复使用Trojan）# 需要增加WS等其他Trojan-Go所支持的模块，增加完成后保存并在面板重启Trojan-GO服务&quot;websocket&quot;: &#123;    &quot;enabled&quot;: true,    &quot;path&quot;: &quot;/DFE4545DFDED/&quot;,    &quot;host&quot;: &quot;你的域名&quot;&#125;,&quot;mux&quot;: &#123;    &quot;enabled&quot;: true,    &quot;concurrency&quot;: 8,    &quot;idle_timeout&quot;: 60&#125;</code></pre></li></ol><h2 id="常见问题总结"><a href="#常见问题总结" class="headerlink" title="常见问题总结"></a>常见问题总结</h2><ul><li>Failed to set locale, defaulting to C.UTF-8解决方法<ul><li><a href="https://blog.csdn.net/ba476/article/details/124448981">https://blog.csdn.net/ba476/article/details/124448981</a></li></ul></li><li>Invalid version. The only valid version for X509Req is 0.<ul><li><a href="https://www.cnblogs.com/jscs/p/17484543.html">https://www.cnblogs.com/jscs/p/17484543.html</a></li></ul></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://ybfl.net/sites/158.html">https://ybfl.net/sites/158.html</a><br><a href="https://v2rayssr.com/bbr.html">https://v2rayssr.com/bbr.html</a><br><a href="https://v2rayssr.com/trojancdn.html">https://v2rayssr.com/trojancdn.html</a><br><a href="https://github.com/Jrohy/trojan">https://github.com/Jrohy/trojan</a><br><a href="https://www.youtube.com/watch?v=tC5bER5iHyE">https://www.youtube.com/watch?v=tC5bER5iHyE</a><br><a href="https://kejilion.blogspot.com/2023/10/vps.html">https://kejilion.blogspot.com/2023/10/vps.html</a></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> 科学上网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA热部署插件JRebel</title>
      <link href="/2020/01/13/st-jrebel-activate.html"/>
      <url>/2020/01/13/st-jrebel-activate.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JRebel是一款JVM插件，它使得代码片段&#x2F;配置文件修改后不用重启项目立即生效。IDEA上原生是不支持热部署的，一般更新了Java文件后要手动重启Tomcat服务器才能生效，浪费时间浪费生命。</p><p>目前对于IDEA热部署最好的解决方案就是安装JRebel插件。</p><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><h3 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h3><ol><li>搭建反向代理服务器<ul><li>下载OS相对应的工具包：<a href="https://github.com/ilanyu/ReverseProxy/releases">https://github.com/ilanyu/ReverseProxy/releases</a></li><li>执行Shell命令：<code>nohup ./ReverseProxy_linux_amd64 -l &quot;0.0.0.0:9999&quot; &amp;</code></li><li>Demo JRebel address：【<a href="http://127.0.0.1:9999/%7BGUID%7D%E3%80%91">http://127.0.0.1:9999/{GUID}】</a>, with any email.</li></ul></li><li>生成GUID <ul><li>在线生成GUID地址：<a href="https://www.guidgen.com/">https://www.guidgen.com</a></li><li>一键地址直接使用: 【<a href="https://jrebel.lvzhiqiang.top/f3b9f9e8-4084-415e-8bac-9c856985a0a4%E3%80%91">https://jrebel.lvzhiqiang.top/f3b9f9e8-4084-415e-8bac-9c856985a0a4】</a></li></ul></li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>打开jrebel激活面板,选择Connect to online licensing service.</li><li>如果失效刷新GUID替换就可以！</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://blog.lanyus.com/archives/317.html">撸了个反代工具, 可用于激活JRebel</a></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jetbrains </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataGrip札记：基础</title>
      <link href="/2019/12/10/st-datagrip-basic.html"/>
      <url>/2019/12/10/st-datagrip-basic.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>DataGrip是面向开发人员的数据库管理环境。它旨在查询，创建和管理数据库。</p><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><h3 id="数据库对象"><a href="#数据库对象" class="headerlink" title="数据库对象"></a><strong>数据库对象</strong></h3><ul><li><p><code>数据源分组</code></p><blockquote><p>可根据自定义类型对数据源分组，比如数据库供应商。按下F6或从上下文菜单中(右键-&gt;Move to Group…)选择移至分组…。<br>新建组可使用拖放操作完成，只需将一个数据源拖放到另一个数据源上。如果要将数据源放到现有组中，只需拖放进来。</p></blockquote></li><li><p><code>为选定的对象生成SQL文件</code></p><blockquote><p>可以使用SQL生成器 (Ctrl+Alt+G)(SQL Scripts→SQL Generator…)为数据库对象生成SQL文件，只需点击右窗格的Save按钮即可。<br>并提供两种输出布局：每个对象一个文件和每个对象一个文件，且按顺序。</p></blockquote></li><li><p><code>快速备份表</code></p><blockquote><p>可以通过拖放操作将表复制到同一个数据源中，如果您需要在进行任何关键数据操作之前创建表的快速备份，这可能非常方便。</p></blockquote></li><li><p><code>修改表结构/表数据</code></p><blockquote><p>在数据库或SQ脚本中的表名称中按下Ctrl+F6即可对它们进行修改，并提供即时预览功能。要编辑表中的数据，请按下F4查看数据编辑器。</p></blockquote></li><li><p><code>编辑源代码</code></p><blockquote><p>按下Ctrl+B，可以获得过程或函数的DDL语句，并进行Edit操作。<br>间距（文本编辑器左侧的垂直条)将高亮显示所做的更改，在点击工具栏上的Submit后，对话框将显示生成的SQL代码以更新源代码。<br>DataGrip将数据库的源代码保存在本地存储中，您可以查看您已更改的源代码部分，而且可以将任意改动还原到服务器版本。</p></blockquote></li><li><p><code>图表</code></p><blockquote><p>按下Ctrl+Alt+U或通过右键”Diagrams-&gt;Show Visualisation”，可以随时在图表中查看它们之间的关系。<br>带有主键和外键的列可以从图表中隐藏，只在相关行上显示，如有必要，这些图表可以导出至图像文件。</p></blockquote></li></ul><h3 id="智能文本编辑器"><a href="#智能文本编辑器" class="headerlink" title="智能文本编辑器"></a><strong>智能文本编辑器</strong></h3><ul><li><p><code>代码格式化</code></p><blockquote><p>按下Ctrl+Alt+L可以灵活根据用户定义的代码样式，自动完成SQL代码格式化。<br>在Settings → Editor → Code Style → SQL中调整代码样式，比如您可以定义关键词是否使用首字母大写。</p></blockquote></li><li><p><code>关键字自动大写</code></p><blockquote><p>可去”Editor-&gt;Code Style-&gt;SQL”中找到对应的数据库方言，在”Case-&gt;Word Case-&gt;Keywords”中将值设为To upper。<br>如果使用了小写，可以将光标停留在需要转换的字段或表名上，使用Ctrl+shift+U快捷键自动转换。</p></blockquote></li><li><p><code>多光标模式</code></p><blockquote><p>在许多情况下，多个光标是修改SQL代码最有效的方式。要添加多个光标，连续按两次Ctrl并按住不放，然后使用方向键放置新光标。<br>或者按住Shift+Alt不放并点击，也有同样效果。 或者先使用文本搜索功能，然后通过Select All Occurrences功能实现。</p></blockquote></li><li><p><code>代码注释</code></p><blockquote><p>选中要注释的代码，按下Ctrl+&#x2F;或Ctrl+shift+&#x2F;快捷键，能注释代码，或取消注释。</p></blockquote></li><li><p><code>实时模板</code></p><blockquote><p>按下Ctrl+J即可查看所有实时模板，并根据选择生成相应SQL代码的重复部分。<br>每个实时模板都有自己的缩写，只要输入缩写并按下Tab键即可粘贴完整的代码。比如输入selw就可以粘贴SELECT * FROM和WHERE。</p></blockquote></li><li><p><code>从剪贴板历史记录粘贴</code></p><blockquote><p>按下Ctrl+Shift+V可以访问剪贴板历史记录，并快速粘贴最近复制到剪贴板中的项。<br>当启动应用程序时，DataGrip会开始将复制的项记录到它的剪贴板历史记录中，并且在关闭应用程序时清除历史记录。 </p></blockquote></li><li><p><code>管理代码片段</code></p><blockquote><p>无需为移动代码块执行这么繁琐的复制粘贴操作，您可以直接使用这些热键来管理选定的行或者代码块。<br>— 按下Ctrl+D以复制行。<br>— 通过Ctrl+Y删除行。<br>— 通过Alt+Shift+上下箭头键移动行。</p></blockquote></li></ul><h3 id="运行查询"><a href="#运行查询" class="headerlink" title="运行查询"></a><strong>运行查询</strong></h3><ul><li><p><code>查询控制台</code></p><blockquote><p>每个数据源都有自己的默认控制台。进入上下文菜单，然后点击Open Console即可打开。或使用快捷键F4。<br>如果出于任何原因，您想为数据源创建另一个控制台，也可以通过：上下文菜单 → New → Console。</p></blockquote></li><li><p><code>执行查询</code></p><blockquote><p>按Ctrl+Enter执行光标停留的语句，可在setting-&gt;Database-General中设置smallest statement。<br>对于希望在新的tab窗口显示查询结果，可以点击”Pin Tab”按钮，那新查询将不会再当前tab中展示，而是新打开一个tab。</p></blockquote></li><li><p><code>评估表达式</code></p><blockquote><p>在其他基IntelliJ的IDE中，在对象上按Ctrl+Alt+F8或者Alt+Click可以让您获得快速评估。<br>在DataGrip中，在查询器中的表中调用它可以查看那个表中的数据，在列名称中按Ctrl+Alt+F8将显示预期结果集中那个列的值。</p></blockquote></li><li><p><code>运行查询的历史记录</code></p><blockquote><p>在每个控制台的工具栏上有一个按钮Browse Console History。按下它可以查看该数据源运行的所有查询的历史记录。</p></blockquote></li><li><p><code>完整SQL日志</code></p><blockquote><p>IDE的所有查询均记录在文本文件中。要打开该文件，请转到Help | Show SQL log in Explorer。</p></blockquote></li><li><p><code>执行计划</code></p><blockquote><p>选中要执行的语句右键”Explain plan(Raw)”将展示数据库要执行的操作，它可以帮助您优化查询。可以以表格或图表的形式表示。 </p></blockquote></li><li><p><code>用户参数</code></p><blockquote><p>当您从其他应用程序中获得SQL查询时，它可以添加参数。参数值用”:a”类似符号代替，再点击工具栏的View Parameters按钮。<br>您可以在”Database → User Parameters”中找到编辑参数模式的 UI。正则表达式会高亮显示，您可以选择模式有效的方言。</p></blockquote></li></ul><h3 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a><strong>处理文件</strong></h3><ul><li><p><code>附加目录</code></p><blockquote><p>可以在”Files”工具窗口中管理文件和目录，请使用工具栏上的”Attach Directory”按钮将所需目录附加到Files工具窗口中。</p></blockquote></li><li><p><code>文件语言</code></p><blockquote><p>右键选择”Change Dialect”可以更改任何文件(SQL)的语言(方言)，以获得正确的高亮显示和解析建议。</p></blockquote></li><li><p><code>版本控制</code></p><blockquote><p>DataGrip为Git、SVN和Mercurial等所有主要的版本控制系统提供了统一的支持，可以从不同的VCS处理不同项目并随意切换项目。<br>要获得VCS支持，可以通过”Settings → Plugins”安装相应的JetBrains插件。<br>另请参阅：<a href="https://blog.jetbrains.com/datagrip/2018/06/01/tutorial-how-to-use-git-with-datagrip/?_ga=2.177277036.872413008.1576052747-1727377903.1572920689">如何在DataGrip中处理Git</a>与<a href="https://blog.jetbrains.com/datagrip/2018/12/11/datagrip-and-github-step-by-step-integration/?_ga=2.149995903.872413008.1576052747-1727377903.1572920689">DataGrip和GitHub集成</a>。</p></blockquote></li></ul><h3 id="数据编辑器"><a href="#数据编辑器" class="headerlink" title="数据编辑器"></a><strong>数据编辑器</strong></h3><ul><li><p><code>全文搜索</code></p><blockquote><p>选择要搜索的数据源或数据源组甚至单独的表，并从上下文菜单调用”Full-text search”或者快捷键”Ctrl+Alt+Shift+F”即可。<br>点击结果以打开数据编辑器，如果由于列过多而无法定位数据，请在数据编辑器中使用文本搜索：Ctrl+F。</p></blockquote></li><li><p><code>筛选数据</code></p><blockquote><p>无需输入任何WHERE子句，只要在结果列表上方的”Filter criteria”输入栏中输入搜索条件即可查看您需要的数据。</p></blockquote></li><li><p><code>文本搜索</code></p><blockquote><p>在表编辑器中通过Ctrl+F调用，无需编写语句即可快速在表中查找数据。<br>如果您不知道要查找的数据位于哪一列，该功能就特别实用。同时您可以轻松隐藏无关行，以及使用正则表达式。</p></blockquote></li><li><p><code>行转列</code></p><blockquote><p>对于字段比较多的表，查看数据要左右推动，可以切换成列显示，在结果集视图区域使用Ctrl+Q快捷键开启并点击”Transposed View”。</p></blockquote></li></ul><h3 id="导入导出选项"><a href="#导入导出选项" class="headerlink" title="导入导出选项"></a><strong>导入导出选项</strong></h3><ul><li><p><code>从CSV文件导入数据</code></p><blockquote><p>点击要导入的schema，然后从上下文菜单中选择”Import Data from File…”，然后选择存储数据的CSV文件将看到导入对话框窗口。<br>CSV，意为逗号分隔值或者字符分隔值，其文件以纯文本形式存储表格数据，记录间以某种换行符分隔，字段间以逗号或制表符分隔。<br>左边的面板显示行分隔符，字段分隔符，空值以及第一行是页眉处理的相关设置。<br>右边的面板将看到要创建表的框架和结果数据预览，如果想从已有的表中导入数据，那么请使用该表的上下文菜单并选择从文件导入…。</p></blockquote></li><li><p><code>CSV编辑器</code></p><blockquote><p>DataGrip可以将CSV文件作为表进行编辑并可以即时预览表。在上下文菜单中点击”Edit as Table…”。</p></blockquote></li><li><p><code>表数据导出</code></p><blockquote><p>表可以导出至文件。表的上下文菜单 → 向文件转储数据 (Dump data to file)。<br>导出至其他已有表 (Another existing table)。表的上下文菜单 → 将表复制到 (Copy Table to)（或在表上按F5）→ 选择已有表。<br>导出至任意数据库供应商的任意数据源中的新表。表的上下文菜单 → 将表复制到（或在表上按F5） → 选择目标架构。</p></blockquote></li><li><p><code>SQL查询导出</code></p><blockquote><p>SQL查询可以作为结果导出到文件中。语句的上下文菜单 → 执行到文件 (Execute to file) → 选择格式。<br>如果查询比较慢，该功能很实用；如果你导出结果集，查询将再次运行，在这种情况下，您只需要运行一次。</p></blockquote></li><li><p><code>结果集导出</code></p><blockquote><p>结果集可以导出至文件。 转储按钮(Dump Data)  → To File。<br>导出至剪贴板。 转储按钮(Dump Data) → 至剪贴板。<br>导出至其他已有表。导出按钮(Export to Database…) → 选择已有表。<br>导出至任意数据库供应商中任意数据源中的新表。 导出按钮(Export to Database…) → 选择目标架构。</p></blockquote></li><li><p><code>导出格式</code></p><blockquote><p>每次导出到文件或剪贴板时，都需要选择格式。 通常是CSV文件，但在许多情况下，您需要JSON、XML甚至是DML语句。<br>SQL查询：任何表或结果集都可以用一组INSERT语句展示，请从下拉列表中选择”SQL Inserts”，它还可以选择”SQL Updates”帮您修改数据。<br>CSV、TSV：列表中有两个预设格式(逗号分隔值和Tab分隔值)。您可以根据DSV创建任意自定义格式。<br>HTML&#x2F;XML：有一个您无法更改的预设提取工具(HTML表)。此外还有脚本提取工具(HTML-Groovy.html.groovy和XML-Groovy.xml.groovy)等。<br>JSON：JSON-Groovy.json.groovy提取工具可以将您的表或结果集导出至JSON。<br>自定义格式：要处理更加复杂的形式，在提取工具菜单中选择转到脚本目录(Go to Scripts Directory)，导航至它们的存储文件夹。<br>这些脚本是用Groovy编写的，但也可以用JavaScript编写，而且通常位于Scratches和Consoles&#x2F;Extensions&#x2F;Database Tools and SQL&#x2F;data&#x2F;extractors中。修改已有提取工具或在这里添加您自己的提取工具。</p></blockquote></li><li><p><code>转储/恢复工具</code></p><blockquote><p>DataGrip集成了mysqldump和pg_dump。要转储对象，请使用上下文菜单中的Dump with…选项。</p></blockquote></li></ul><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a><strong>导航</strong></h3><ul><li><p><code>随处搜索</code></p><blockquote><p>如果不确定在哪里查找所需内容，可尝试按两次Shift键来调用Search Everywhere。<br>查找操作：Ctrl+Shift+A，切换到Actions。搜索某些你知道但不知道如何访问的功能。<br>查找表&#x2F;过程：Ctrl+N，切换到Tables。如果是表，会打开一个数据编辑器，要查看该表的DDL，请按DDL按钮。<br>查找文件：Shift+Ctrl+N，切换到Files。文件会打开。<br>查找符号：Shift+Ctrl+Alt+N，切换到Symbols。可以访问数据库视图中的任何数据库对象，包括列、约束、索引等。</p></blockquote></li><li><p><code>从SQL导航</code></p><blockquote><p>在SQL的编辑区域，针对SQL的关键字例如表名、字段名或者函数名上可做如下操作进行相关导航。<br>Edit source(F4)可将您转至数据或DDL。Go to declaration(Ctrl+B)可将您转至数据库树。Ctrl+Q悬浮查看表结构。<br>可去”Setting-&gt;Database-&gt;General-&gt;Navigation”定义导航位置的选项。 </p></blockquote></li><li><p><code>在数据库树视图中快速搜索</code></p><blockquote><p>任何树（列表、弹出窗口、下拉菜单）都支持快速搜索。请注意匹配的数据库对象只有在其节点已打开时才会高亮显示。<br>关于快速搜索的另一个实用之处在于其支持缩写。例如使用“sbs”就可以找到“sales_by_store”。</p></blockquote></li><li><p><code>最近的文件</code></p><blockquote><p>按下Ctrl+E打开Recent Files窗口。控制台、数据编辑器、文本文件一切都在这里，光标默认放在最后访问的项目。</p></blockquote></li><li><p><code>最近的位置</code></p><blockquote><p>按下Ctrl+Shift+E打开Recent Locations窗口。列出您最近访问&#x2F;改变的代码位置。它以代码段的形式显示代码位置前后几行。</p></blockquote></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jetbrains.com/zh-cn/datagrip/features">https://www.jetbrains.com/zh-cn/datagrip/features</a></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jetbrains </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS 系统进阶：开发环境Java + Node + Docker</title>
      <link href="/2019/11/24/os-mac-ide.html"/>
      <url>/2019/11/24/os-mac-ide.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>记录从Windows切换到Mac环境IDE的搭建。</p><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a><strong>Git</strong></h3><ul><li>官网下载：<a href="http://git-scm.com/download/mac">http://git-scm.com/download/mac</a></li><li>安装过程和 Windows 没啥区别，都是下一步下一步。</li><li>IDEA对Git的支持很好，也不需要额外配置什么，IDEA的Git操作都很便捷，强烈使用IDEA作为Git的GUI操作工具。</li><li><code>Homebrew方式(推荐)</code>：brew install git</li></ul><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a><strong>JDK</strong></h3><ul><li>官网下载 JDK7：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html</a></li><li>官网下载 JDK8：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></li><li>安装过程和 Windows 没啥区别，都是下一步下一步，只是比 Windows 简单，连安装路径都不需要改而已。  <pre><code class="hljs plaintext"># JDK 1.8export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Homeexport JRE_HOME=$JAVA_HOME/jreexport PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</code></pre></li><li>卸载  <pre><code class="hljs plaintext">sudo rm -rf /Library/Internet\ Plug-Ins/JavaAppletPlugin.pluginsudo rm -rf /Library/PreferencePanes/JavaControlPanel.prefPanesudo rm -rf /Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk</code></pre></li></ul><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a><strong>IDEA</strong></h3><ul><li>官网下载：<a href="http://www.jetbrains.com/idea">http://www.jetbrains.com/idea</a></li><li>安装过程和 Windows 没啥区别，都是下一步下一步。  <pre><code class="hljs plaintext">如果启动Tomcat的时候报：Permission denied，你则可以：打开终端，进入 Tomcat\bin 目录，然后执行：chmod 777 *.sh如果启动Tomcat之后，控制台乱码了，那你可以尝试下在 Tomcat VM 参数上加上：-Dfile.encoding=UTF-8Git 的路径配置：Preferences -- Version Control -- Git -- Path to Git executable 的值是：/usr/local/git/bin/git如果已经安装了zsh，终端路径可以改成zsh的，配置方法在 Preferences -- Tools -- Terminal -- Shell path 的值改为是：/bin/zsh</code></pre></li><li>IDEA在Mac下的配置文件保存路径  <pre><code class="hljs plaintext">下面内容中：XXXXXX，表示 IntelliJ IDEA 的版本号，IntelliJ IDEA 的配置目录是跟版本号有关系的。/Users/你的用户名/Library/Application Support/IntelliJIdeaXXXXXX，用于保存安装的插件/Users/你的用户名/Library/Caches/IntelliJIdeaXXXXXX，用于保存缓存、日志、以及本地的版本控制信息（local history 这个功能）/Users/你的用户名/Library/Preferences/IntelliJIdeaXXXXXX，用于保存你的个人配置、授权文件，等价于 Windows 下的 config 目录</code></pre></li></ul><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a><strong>Maven</strong></h3><ul><li>官网下载：<a href="http://maven.apache.org/download.cgi">http://maven.apache.org/download.cgi</a></li><li>Maven是绿色版的，任何系统都适用。</li><li>安装方式和Windows、Linux没啥本质区别，都是把zip文件夹解压，然后新增几个系统变量，修改Maven配置文件参数。  <pre><code class="hljs plaintext">把Maven解压后，直接把Windows的settings.xml复制过来，修改下该文件本地仓库的路径，其他没啥可以改的了。然后本地仓库的那些依赖包是直接从Windows下拷贝过来的，这个是任何系统下都兼容的，不需要额外处理。最后再用DEA对Maven 配置路径重新做下修改。</code></pre>  <pre><code class="hljs plaintext"># Mavenexport MAVEN_HOME=/Users/你的用户名/my_software/work_software/maven3.3.9export PATH=$MAVEN_HOME/bin:$PATH</code></pre></li></ul><h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a><strong>Gradle</strong></h3><ul><li>官网下载：<a href="https://gradle.org/releases">https://gradle.org/releases</a></li><li>Gradle和Maven思路是一模一样的。  <pre><code class="hljs plaintext"># GradleGRADLE_HOME=/Users/youmeek/my_software/work_software/gradle4.2PATH=$PATH:$GRADLE_HOME/binexport GRADLE_HOMEexport PATH</code></pre></li></ul><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a><strong>Docker</strong></h3><ul><li>官网下载：<a href="https://download.docker.com/mac/stable/Docker.dmg">https://download.docker.com/mac/stable/Docker.dmg</a></li><li>修改register的方式可以参看这篇文章：<a href="http://www.runoob.com/docker/macos-docker-install.html">http://www.runoob.com/docker/macos-docker-install.html</a></li></ul><h3 id="MySQL5-7"><a href="#MySQL5-7" class="headerlink" title="MySQL5.7"></a><strong>MySQL5.7</strong></h3><ul><li>官网下载：<a href="http://dev.mysql.com/downloads/mysql">http://dev.mysql.com/downloads/mysql</a></li><li>MySQL5.7版本：<a href="https://dev.mysql.com/downloads/mysql/5.7.html#downloads">https://dev.mysql.com/downloads/mysql/5.7.html#downloads</a></li><li>MySQL官网提供的Mac系统的安装包，是下一步下一步安装类型的，安装结束后，会提示你它生成的一个随机密码，你要复制下，等下要用。</li><li>如何修改root密码  <pre><code class="hljs plaintext">打开：系统偏好设置 -- 底部的 MySQL -- 点击：Stop MySQL Server，根据提示输入你的 Mac 用户密码。连接：sudo /usr/local/mysql/bin/mysql -h 127.0.0.1 -u root -P 3306 -p，输入刚刚复制的密码– 修改密码：set password = password(&#x27;123456&#x27;);</code></pre></li><li>MySQL配置文件设置(vim &#x2F;etc&#x2F;my.cnf)  <pre><code class="hljs plaintext">[mysql]default-character-set = utf8mb4[mysqld]symbolic-links=0log-error=/var/log/mysql/error.logdefault-storage-engine = InnoDBcollation-server = utf8mb4_unicode_520_ciinit_connect = &#x27;SET NAMES utf8mb4&#x27;character-set-server = utf8mb4lower_case_table_names = 1max_allowed_packet = 50M</code></pre></li></ul><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a><strong>Node</strong></h3><ul><li><code>Homebrew方式(推荐，因为避免权限问题)</code>：brew install node  <pre><code class="hljs plaintext"># 卸载brew uninstall nodesudo rm -rf /usr/local/share/systemtapsudo rm -rf /usr/local/lib/dtrace/node</code></pre></li><li>官网安装包下载：<a href="https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a>  <pre><code class="hljs plaintext"># 卸载sudo rm -rf /usr/local/&#123;bin/&#123;node,npm,node-debug,node-gyp&#125;,include/node*,lib/node_modules/npm,lib/node,share/man/*/node*&#125;sudo rm -rf ~/.npm*sudo rm -rf ~/.node*sudo rm -rf /usr/local/lib/node*sudo rm -rf /usr/local/share/doc/node*</code></pre></li><li>使用nrm切换源  <pre><code class="hljs plaintext">安装：npm install -g nrm列表源：nrm ls使用源：nrm use taobao</code></pre></li><li>npm安装很容易出现权限相关的问题，遇到了可以类似这样：sudo npm install –unsafe-perm&#x3D;true –allow-root –global gulp</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.youmeek.com/mac-java">http://www.youmeek.com/mac-java</a></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS 系统进阶：终端方案iTerm2 + Zsh + Vim</title>
      <link href="/2019/11/24/os-mac-terminal.html"/>
      <url>/2019/11/24/os-mac-terminal.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>方便前&#x2F;后端开发人员更好的通过终端解决问题。</p><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><h3 id="简介iTerm2"><a href="#简介iTerm2" class="headerlink" title="简介iTerm2"></a><strong>简介iTerm2</strong></h3><ul><li>iTerm2官网：<a href="https://iterm2.com/">https://iterm2.com</a></li><li>Mac的默认终端Terminal太难用了，需要一个新的终端来代替它，iTerm2 + Zsh就是其中一种方案。</li><li>iTerm2是Terminal的替代品，是iTerm的后继产品。iTerm2将终端带入了您从未想过一直想要的功能，使其进入了现代时代。</li></ul><h3 id="安装iTerm2"><a href="#安装iTerm2" class="headerlink" title="安装iTerm2"></a><strong>安装iTerm2</strong></h3><ul><li>方法1：官网下载下来是一个zip压缩包，解压出来有一个.app文件(特殊的文件夹)，双击运行即可安装，或是拖到应用程序里面。</li><li>方法2：直接使用Homebrew进行安装，命令参考<code>brew cask install iterm2</code>。</li></ul><hr><ul><li>更改配色方案：Preferences-&gt;Profiles-&gt;Colors-&gt;Color Presets-&gt;Import。  <pre><code class="hljs plaintext">例如设置配色方案为solarized，iTerm2默认是有带的，如果没有则访问：https://github.com/altercation/solarized，在项目中找到solarized/iterm2-colors-solarized 目录，下面有两个文件：Solarized Dark.itermcolors和Solarized Light.itermcolors，双击这两个文件就可以把配置文件导入到 iTerm 里了，同时还要再切换到Text标签，把Draw bold text in bold font的勾去掉。</code></pre></li><li>设置背景图片：Preferences-&gt;Profiles-&gt;Window-&gt;Background Image。</li><li>设置字体：Preferences-&gt;Profiles-&gt;Text-&gt;Font-&gt;Chanage Font。</li><li>将iTerm2设为默认终端并设置默认窗口大小。</li></ul><h3 id="使用iTerm2"><a href="#使用iTerm2" class="headerlink" title="使用iTerm2"></a><strong>使用iTerm2</strong></h3><ul><li><code>智能选中</code><ul><li>在iTerm2中，连续双击选中，连续三击选中整行，可以识别网址，引号引起的字符串，邮箱地址等。</li><li>在iTerm2中，选中即复制，即任何选中状态的字符串都被放到了系统剪切板中。</li></ul></li><li><code>快速调出窗口(Hotkey Window)</code><ul><li>有时候只是在终端执行几行命令，然后就不再使用它，可是我们还是必须要打开终端，使用完成后关闭它。</li><li>只要按快捷键就能开启iTerm2热启动功能，出来虚化的终端，输入命令，然后再把光标放在其他地方自动就消失了。</li><li>默认iTerm2没有开启此功能，可去设置快捷键：Preferences-&gt;Keys-&gt;Hotkey。</li></ul></li><li><code>常用快捷键</code></li></ul><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Command + Option + 数字</td><td align="left">切换窗口</td></tr><tr><td align="left">Command + 方向键</td><td align="left">切换标签页</td></tr><tr><td align="left">Command + 数字</td><td align="left">切换到指定数字标签页</td></tr><tr><td align="left">Command + d</td><td align="left">竖直分屏</td></tr><tr><td align="left">Command + shift + d</td><td align="left">水平分屏</td></tr><tr><td align="left">Command + n</td><td align="left">新建窗口</td></tr><tr><td align="left">Command + t</td><td align="left">新建标签页</td></tr><tr><td align="left">Command + w</td><td align="left">关闭当前标签或是窗口</td></tr><tr><td align="left">Command + shift + h</td><td align="left">查看剪贴板历史</td></tr><tr><td align="left">Command + ;</td><td align="left">根据(输入的前缀)历史记录自动补全</td></tr><tr><td align="left">Command + enter</td><td align="left">进入全屏模式，再按一次返回</td></tr><tr><td align="left">Command + 鼠标单击</td><td align="left">可以打开文件&#x2F;文件夹&#x2F;链接</td></tr><tr><td align="left">Command + r</td><td align="left">清屏</td></tr></tbody></table><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Control + k</td><td align="left">删除光标位置(包括)到行尾之间的内容</td></tr><tr><td align="left">Control + w</td><td align="left">删除光标位置(不包括)到行首之前的内容</td></tr><tr><td align="left">Control + d</td><td align="left">删除光标所在位置的字符</td></tr><tr><td align="left">Control + h</td><td align="left">删除光标所在位置前一个字符</td></tr><tr><td align="left">Control + y</td><td align="left">召回最近用命令删除的文字</td></tr><tr><td align="left">Control + r</td><td align="left">搜索历史命令</td></tr><tr><td align="left">Control + c</td><td align="left">结束当前状态，另起一行</td></tr><tr><td align="left">Control + u</td><td align="left">清空当前行，无论光标在什么位置</td></tr><tr><td align="left">Control + a</td><td align="left">移动到行首</td></tr><tr><td align="left">Control + e</td><td align="left">移动到行尾</td></tr></tbody></table><h3 id="简介Zsh"><a href="#简介Zsh" class="headerlink" title="简介Zsh"></a><strong>简介Zsh</strong></h3><ul><li>Zsh官网：<a href="https://www.zsh.org/">https://www.zsh.org</a>  <pre><code class="hljs plaintext">Mac和一般的Linux发行版默认采用的shell是bash，并不是很好用。Zsh是Shell中的一种，由于Zsh配置门槛有点高(需要专门花时间去了解Zsh)，因为这样，用户也就相对少了。</code></pre></li><li>oh-my-Zsh官网：<a href="http://ohmyz.sh/">http://ohmyz.sh</a>  <pre><code class="hljs plaintext">直到有一天oh-my-Zsh的作者诞生，他想要整理出一个配置框架出来，让大家直接使用他的这个公认最好的Zsh配置，省去繁琐的配置过程。所以，oh-my-Zsh就诞生了，它只是为了让你减少Zsh的配置，然后又可以好好的享受Zsh这个Shell。oh-my-Zsh是基于zsh一个扩展工具集，提供了丰富的扩展功能，包括主题配置，插件机制，已经内置的便捷操作。</code></pre></li><li>修改终端配置就变成了：vim ~&#x2F;.zshrc，而不是：vim ~&#x2F;.bash_profile。</li></ul><h3 id="安装Zsh"><a href="#安装Zsh" class="headerlink" title="安装Zsh"></a><strong>安装Zsh</strong></h3><ol><li>安装Zsh <pre><code class="hljs plaintext">$ brew install zsh</code></pre></li><li>安装wget <pre><code class="hljs plaintext">$ brew install wget</code></pre></li><li>安装oh-my-Zsh <pre><code class="hljs plaintext">$ sh -c &quot;$(wget -qO- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></pre> 或者 <pre><code class="hljs plaintext">$ sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></pre> 下载完后，会提示你输入当前登录系统的用户密码，输入完成之后就会从bash切换到zsh，如果你没有输入密码直接跳过了，<br> 可以运行该命令进行手动切换：chsh -s &#x2F;bin&#x2F;zsh gitnav(系统用户名),切换完成之后，关掉终端，重新打开终端即可。</li><li>设置oh-my-Zsh主题(可选)<ul><li>主题列表：<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">https://github.com/ohmyzsh/ohmyzsh/wiki/Themes</a></li><li>oh-my-Zsh自带了一些默认主题，存放在 ~&#x2F;.oh-my-zsh&#x2F;themes 目录中。</li><li>固定主题：例如在.zshrc文件中修改(或添加)<code>ZSH_THEME=&quot;agnoster&quot;</code>。</li><li>随机主题：<code>ZSH_THEME=&quot;random&quot;</code>。</li></ul></li><li>安装Zsh插件(可选)<ul><li>oh-my-Zsh自带了一些默认插件，存放在 ~&#x2F;.oh-my-zsh&#x2F;plugins 目录中。</li></ul></li></ol><h3 id="使用Zsh"><a href="#使用Zsh" class="headerlink" title="使用Zsh"></a><strong>使用Zsh</strong></h3><ul><li>不区分大小写智能提示，按Tab键进行提示。</li><li>按下tab键显示出所有待选项后，再按一次tab键，即进入选择模式，按tab&#x2F;shift + tab 切向下&#x2F;上一个选项，ctrl+f&#x2F;b&#x2F;n&#x2F;p 可以向前后左右切换。</li><li>kill + 空格键 + Tab键，列出运行的进程，要杀哪个进程不需要再知道PID了。<ul><li>zsh提供了让你知道PID的方法：例如输入kill vim，再按下tab，会变成：kill 5643</li></ul></li><li>ls **&#x2F;*，分层级地列出当前目录下所有文件及目录，并递归目录<ul><li>ls *.png 查找当前目录下所有 png 文件</li><li>ls **&#x2F;*.png 递归查找</li></ul></li><li>zsh的目录跳转很智能，你无需输入cd就可直接输入路径即可。比如：..表示后退一级目录，..&#x2F;..&#x2F;表示后退两级，依次类推。</li><li>在命令窗口中输入：d，将列出当前session访问过的所有目录，再按提示的数字即可进入相应目录。</li><li>给man命令增加结果高亮显示，可编辑配置文件：vim ~&#x2F;.zshrc，增加下面内容  <pre><code class="hljs plaintext"># man context highlightexport LESS_TERMCAP_mb=$&#x27;\E[01;31m&#x27;       # begin blinkingexport LESS_TERMCAP_md=$&#x27;\E[01;38;5;74m&#x27;  # begin boldexport LESS_TERMCAP_me=$&#x27;\E[0m&#x27;           # end modeexport LESS_TERMCAP_se=$&#x27;\E[0m&#x27;           # end standout-modeexport LESS_TERMCAP_so=$&#x27;\E[38;5;246m&#x27;    # begin standout-mode - info boxexport LESS_TERMCAP_ue=$&#x27;\E[0m&#x27;           # end underlineexport LESS_TERMCAP_us=$&#x27;\E[04;38;5;146m&#x27; # begin underline</code></pre></li><li>常用插件  <pre><code class="hljs plaintext">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestionsgit clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlightingvim ~/.zshrc，在 plugins 里面换行，分别添加：zsh-autosuggestions，zsh-syntax-highlighting</code></pre></li></ul><h3 id="简介Vim"><a href="#简介Vim" class="headerlink" title="简介Vim"></a><strong>简介Vim</strong></h3><p>略</p><h3 id="安装Vim"><a href="#安装Vim" class="headerlink" title="安装Vim"></a><strong>安装Vim</strong></h3><p>brew install vim</p><h3 id="使用Vim"><a href="#使用Vim" class="headerlink" title="使用Vim"></a><strong>使用Vim</strong></h3><p>下载配置：curl <a href="https://raw.githubusercontent.com/wklken/vim-for-server/master/vimrc">https://raw.githubusercontent.com/wklken/vim-for-server/master/vimrc</a> &gt; ~&#x2F;.vimrc</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.youmeek.com/mac-iterm2">http://www.youmeek.com/mac-iterm2</a></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS 系统进阶：包管理工具</title>
      <link href="/2019/11/22/os-mac-package.html"/>
      <url>/2019/11/22/os-mac-package.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Mac与Linux都是基于Unix的系统，因此继承了很多Unix的特性，包括软件的编译，安装等。</li><li>有些操作，命令行或者说脚本的方式效率是远高于GUI界面操作的，这个概念用过Unix&#x2F;Linux做过开发的人会懂，特别是搞运维的。</li></ul><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><h3 id="简介Homebrew"><a href="#简介Homebrew" class="headerlink" title="简介Homebrew"></a><strong>简介Homebrew</strong></h3><ul><li><p>Homebrew官网：<a href="https://brew.sh/index_zh-cn.html">https://brew.sh/index_zh-cn.html</a></p><blockquote><p><strong>1.使用Homebrew安装MacOS（或Linux）系统中没有预装但你需要的东西。</strong><br><strong>2.Homebrew会将软件包安装到独立目录(&#x2F;usr&#x2F;local&#x2F;Cellar和&#x2F;usr&#x2F;local&#x2F;opt&#x2F;)，并将其文件软链接至&#x2F;usr&#x2F;local&#x2F;bin。</strong><br><strong>3.Homebrew不会将文件安装到它本身目录之外，默认位于&#x2F;usr&#x2F;local&#x2F;Homebrew，所以您可将Homebrew安装到任意位置。</strong><br><strong>4.不会再出现“要安装，请拖动此图标……”，使用brew cask安装macOS应用程序、字体和插件以及其他非开源软件。</strong><br>5.轻松创建你自己的Homebrew包。<br>6.完全基于Git和Ruby，所以自由修改的同时你仍可以轻松撤销你的变更或与上游更新合并。<br>7.Homebrew的配方都是简单的Ruby脚本。<br>8.Homebrew 使 macOS（或您的 Linux 系统）更完整。使用 gem 来安装 RubyGems、用 brew 来安装那些依赖包。<br>9.制作一个 cask 就像创建一个配方一样简单。</p></blockquote></li><li><p>Homebrew是Mac下的一个包管理工具，类似于Ubuntu的apt-get，CentOS的yum。</p><blockquote><p>它会帮我们依次下载源码-&gt;解压-&gt;编译-&gt;安装，同时还包括相关依赖包，并自动设置好各种环境变量和参数。<br>  这个对程序员来说简直是福音，简单的指令，就能快速安装和升级本地的各种开发环境。</p></blockquote></li><li><p>同类技术比较：<a href="http://www.zhihu.com/question/19862108">Homebrew 和 Fink、MacPort 相比有什么优势？</a></p></li><li><p><code>应用列表</code>：<a href="https://formulae.brew.sh/formula">https://formulae.brew.sh/formula</a></p></li></ul><h3 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a><strong>安装Homebrew</strong></h3><ol><li>将以下命令粘贴至终端安装Xcode command line tools，如果提示已经安装过了那就不用管了。<pre><code class="hljs plaintext">$ xcode-select --install</code></pre></li><li>将以下命令粘贴至终端<pre><code class="hljs plaintext">$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre></li><li>测试安装是否成功 <pre><code class="hljs plaintext">$ brew</code></pre></li><li>卸载<pre><code class="hljs plaintext">$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</code></pre></li></ol><h3 id="使用Homebrew"><a href="#使用Homebrew" class="headerlink" title="使用Homebrew"></a><strong>使用Homebrew</strong></h3><table><thead><tr><th align="left">命令</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">brew install wget</td><td align="left">安装指定软件包</td></tr><tr><td align="left">brew uninstall wget</td><td align="left">卸载指定软件包，一键静默卸载</td></tr><tr><td align="left">brew upgrade wget</td><td align="left">更新指定软件包,如果不加软件名，就更新所有可以更新的软件</td></tr><tr><td align="left">brew info svn</td><td align="left">查看指定软件包的各种信息，包括版本源码地址等等</td></tr><tr><td align="left">brew search git</td><td align="left">模糊搜索brew支持的软件，如果不加软件名，就会列出所有它支持的软件</td></tr><tr><td align="left">brew list</td><td align="left">列出本机通过brew安装的所有软件</td></tr><tr><td align="left">brew update</td><td align="left">更新brew软件自身</td></tr><tr><td align="left">brew cleanup</td><td align="left">清除下载的各种缓存</td></tr></tbody></table><p>组合命令：brew update &amp;&amp; brew upgrade &amp;&amp; brew cleanup </p><h3 id="更换brew源为国内源-可选"><a href="#更换brew源为国内源-可选" class="headerlink" title="更换brew源为国内源(可选)"></a><strong>更换brew源为国内源(可选)</strong></h3><ol><li>替换homebrew默认源（源代码仓库） <pre><code class="hljs plaintext">$ cd /usr/local/Homebrew  $ git remote set-url origin https://mirrors.ustc.edu.cn/brew.git</code></pre></li><li>替换homebrew-core源（核心软件仓库） <pre><code class="hljs plaintext">$ cd /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core$ git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git$ cd /usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask$ git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</code></pre></li><li>替换homebrew-bottles源（预编译二进制软件包） <pre><code class="hljs plaintext">$ echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#x27; &gt;&gt; ~/.bash_profile$ echo &#x27;export HOMEBREW_NO_AUTO_UPDATE=true&#x27; &gt;&gt; ~/.bash_profile$ source ~/.bash_profile</code></pre> 上面是针对bash用户，对于zsh用户是~&#x2F;.zshrc文件。<br> 上面第二行是禁用掉每次安装前的更新，防止Homebrew在安装软件的过程中可能会长时间卡在Updating Homebrew这个步骤。</li><li>重置为官方源 <pre><code class="hljs plaintext">    $ cd /usr/local/Homebrew      $ git remote set-url origin https://github.com/Homebrew/brew.git      $ cd /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core    $ git remote set-url origin https://github.com/Homebrew/homebrew-core.git    $ cd /usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask    $ git remote set-url origin https://github.com/Homebrew/homebrew-cask.git    $ brew update    ```      如果Homebrew Bottles源也被替换了的话，只要在~/.bash_profile配置文件里删除掉对应的命令所在行，并source一下即可。--- 附上国内其他镜像源： &lt;https://mirror.tuna.tsinghua.edu.cn/help/homebrew/&gt;  &lt;https://mirror.tuna.tsinghua.edu.cn/help/homebrew-bottles/&gt;### **Proxychains4为终端做代理(可选)**</code></pre>1.保证你本地有一个 socks5 到代理工具，不然下面的方法你无法使用。我这里的工具是：Shadowsocks<br>2.安装 Proxychains4，输入命令：brew install proxychains-ng<br>3.修改配置文件：vim &#x2F;usr&#x2F;local&#x2F;etc&#x2F;proxychains.conf<br> 在配置文件中找到：[ProxyList]（也就是第 111 行的地方），在其下面一行新增一条：socks5 127.0.0.1 1080 # my vps<br>4.测试：proxychains4 wget <a href="http://www.google.com,如果你能正常下载到/">www.google.com，如果你能正常下载到</a> Google 页面，则表示成功了。以后只要在命令前面加个：proxychains4，即可。<br>5.修改终端配置，让命令更加简洁：<br> 如果你是 zsh 终端，配置修改：vim ~&#x2F;.zshrc，添加一行：alias proxy&#x3D;’proxychains4’<br> 如果你是 bash 终端，配置修改：vim ~&#x2F;.bash_profile，添加一行：alias proxy&#x3D;’proxychains4’<br> 修改之后，以后要用 proxychains4 执行穿墙命令的话，那就可以这样写：proxy wget google.com<pre><code class="hljs plaintext">### **简介brew cask**- brew cask 官网：&lt;https://buyinstagramlikes.io/caskroom&gt;    &gt; Homebrew Cask扩展了Homebrew，并为MacOS上的图形界面程序（.dmg/.pkg）的安装和管理带来了优雅，简单，快速等。  它先将程序下载解压到统一的目录中（/usr/local/Caskroom），省掉了自己去下载、解压、拖拽（安装）等蛋疼步骤。  然后再移动到~/Applications/目录下，并在原目录中留下软链接，这样非常方便的在应用程序里找到它。Homebrew Cask包含很多在AppStore里没有的常用软件。- brew cask Github：&lt;https://github.com/caskroom/homebrew-cask&gt;- `应用列表`：&lt;https://formulae.brew.sh/cask&gt;### **安装brew cask**1. 将以下命令粘贴至终端(最好先将brew换为国内源)</code></pre> $ brew cask <pre><code class="hljs plaintext">2. 测试安装是否成功</code></pre> $ brew cask<pre><code></code></pre></li></ol><h3 id="使用brew-cask"><a href="#使用brew-cask" class="headerlink" title="使用brew cask"></a><strong>使用brew cask</strong></h3><table><thead><tr><th align="left">命令</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">brew cask install qq</td><td align="left">下载安装软件</td></tr><tr><td align="left">brew cask uninstall qq</td><td align="left">卸载软件</td></tr><tr><td align="left">brew cask info qq</td><td align="left">显示这个软件的详细信息，如果已经用cask安装了，也会显示其安装目录信息等</td></tr><tr><td align="left">brew cask search qq</td><td align="left">模糊搜索软件，如果不加软件名，就列出所有它支持的软件</td></tr><tr><td align="left">brew cask list</td><td align="left">列出本机按照过的软件列表</td></tr><tr><td align="left">brew update &amp;&amp; brew upgrade brew-cask</td><td align="left">更新cask自身</td></tr><tr><td align="left">brew cask cleanup</td><td align="left">清除下载的缓存以及各种链接信息</td></tr></tbody></table><p>组合命令：brew update &amp;&amp; brew upgrade brew-cask &amp;&amp; brew cleanup </p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.youmeek.com/mac-homebrew">http://www.youmeek.com/mac-homebrew</a></li><li><a href="https://www.zybuluo.com/phper/note/87055">https://www.zybuluo.com/phper/note/87055</a></li><li><a href="https://maomihz.com/2016/06/tutorial-6">https://maomihz.com/2016/06/tutorial-6</a></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人发展战略：基础</title>
      <link href="/2019/10/31/te-personal-development.html"/>
      <url>/2019/10/31/te-personal-development.html</url>
      
        <content type="html"><![CDATA[<h1 id="个人发展战略：基础"><a href="#个人发展战略：基础" class="headerlink" title="个人发展战略：基础"></a>个人发展战略：基础</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>一、诊断现状<br>   1）一个模型，帮你找到真正热爱的工作：分析个人和工作匹配的要素有哪些，知道自己为什么会不喜欢一份工作，以及怎么找到跟自己匹配的工作。<br>   2）四大要素，决定了你的市场价值：分析应该把时间花在什么要素上面，才能有市场价值的提升，并不是所有努力都有效<br>二、发现潜能<br>   3）四类迹象，发现你的隐藏能力：找到自己的天赋，也就是隐藏的能力，才能事半功倍<br>三、学习提升<br>   4）三种方法，将知识内化成能力：知识是死的，能力才能盘活它<br>   5）三大系统，让学习不靠意志力：靠意志力学习是不可能的，需要依靠三大系统<br>四、规划未来<br>   6）三个建议，让你不做“定制化人才：如何找到不变的因素，应对未来的加速变化，避免成为企业定制化人才</p></blockquote><p>普及一些基本的职业发展和提升方法，不再让一些毫无专业基础的成功学老师误导我们，每个人都应该有自己的发展策略，当好自己的CEO。</p><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><h3 id="一个模型，帮你找到真正热爱的工作"><a href="#一个模型，帮你找到真正热爱的工作" class="headerlink" title="一个模型，帮你找到真正热爱的工作"></a><strong>一个模型，帮你找到真正热爱的工作</strong></h3><p>掌握冰山模型的用法，能够用它来分析自己跟工作的匹配度，从而做出正确的职业选择，并能精准找到自己喜欢并有成就感的工作。</p><p>查理芒格在《穷查理宝典》里面提到，掌握一定数量的思维模型，能解决这世上90%的问题。</p><p>冰山模型是美国著名心理学家麦克利兰提出来的，它全面地描述了一个人的个体素质要素，也就是说，<code>你跟一个岗位是不是匹配、匹配程度如何、市场薪资值多少，都是这个模型可以解释的，几乎所有大公司都会用它来进行人才招聘和培养。</code></p><p><img src="/2019/10/31/te-personal-development/te-personal-development-001.jpg" alt="抱歉,图片休息了" title="冰山模型"></p><ul><li><code>第一部分，知识和技能</code>  <pre><code class="hljs plaintext">冰山模型从上到下有很多要素，最上面的要素是知识和技能。知识，就是我们在学习和实践中获得的认知和经验，比如财务知识、人力资源知识等等，包括我们现在学习的冰山模型，也属于知识。这跟你大学所学的专业、常看的书、从事的工作、甚至业余爱好都有关系。技能是指你所具备的某项专门技术，比如骑自行车、编程、使用Excel等等。一个人的知识和技能是可以后天习得的，也是非常显性，容易看出来的。所以，我们称为冰山上的部分。知识技能跟工作之间的关系是什么呢？简单来说，如果你的工作中有很多陌生的内容，觉得每天都信息量很大、来不及接收，感到慌乱和焦虑，很可能就是你的知识技能跟岗位不匹配。但这不是什么大问题，因为知识和技能比较容易补齐，上上课、看看书、跟资深同事学，一段时间之后就能提升。</code></pre></li><li><code>第二部分，能力</code>  <pre><code class="hljs plaintext">冰山模型中间的要素是能力，或叫通用能力，比如学习和思考能力、人际交往能力等。相对知识和技能来说，能力高低不是一眼就能看出来的。比如，一个人的创新能力到底如何，很难用一个证书、几道题目来考察，而需要看他在处理很多问题时候的行为。能力跟知识技能最大的区别在于：知识和技能属于特定领域，而能力则更多是通用领域的。比如，知识会分财务、人力资源、金融等等，但是“创新”这样的能力，是适用于任何领域的，一旦掌握，是能够迁移的。那么，如果能力不匹配，在工作中会如何呢？工作效率、沟通效率较低，面对复杂的问题无从下手，缺乏成就感，力不从心。能力的培养周期相对长一些，一般要几个月时间，我们后面几节会讲方法。</code></pre></li><li><code>第三部分，价值观、性格、动机</code>  <pre><code class="hljs plaintext">冰山模型最底下包括价值观、性格特质、动机。这些要素在成年之后很难被改变，它们会受基因、家庭教育、童年经历等等的影响。简单介绍一下各个要素：价值观是你判断事物的标准，比如说，当你在择业的时候，自由和稳定产生了冲突，你选择哪个、放弃哪个；在事业和家庭产生冲突的时候，你怎么处理，等等。如果你在工作中经常陷入矛盾和纠结，对所做的事情很难发自内心地认同，很可能就是价值观上不匹配，比如你做自媒体，公司为了赚钱让你写一些低俗内容，但你觉得那对用户没有价值。性格特质则是个人的行为偏好，比如，你是偏内向还是外向，更关注宏观还是细节，等等。如果你在工作中发现，自己好像工作量没有很大，但却觉得心累，很有可能是性格不匹配 。比如，你是内向性格的人，是从独处中获得能量，但你做了一份每天都要不断跟陌生人沟通的工作。 至于动机，其实动机的分类方法有很多，最常见的是麦克利兰的理论，分为成就动机、权力动机和亲和动机。成就动机的人，喜欢挑战；权力动机的人，希望影响他人；而亲和动机的人，希望维持更好的团队关系。如果你感觉自己没有动力，做事提不起劲儿来，那很可能就是现在的工作跟你的动机不匹配，比如你明明是成就感动机，喜欢一定挑战，但你的工作却高度重复。</code></pre><img src="/2019/10/31/te-personal-development/te-personal-development-002.jpg" alt="抱歉,图片休息了" title="工作与冰山模型"><br><img src="/2019/10/31/te-personal-development/te-personal-development-003.jpg" alt="抱歉,图片休息了" title="冰山模型分析是否喜欢现有岗位"></li></ul><h3 id="四大要素，决定了你的市场价值"><a href="#四大要素，决定了你的市场价值" class="headerlink" title="四大要素，决定了你的市场价值"></a><strong>四大要素，决定了你的市场价值</strong></h3><h3 id="四类迹象，发现你的隐藏能力"><a href="#四类迹象，发现你的隐藏能力" class="headerlink" title="四类迹象，发现你的隐藏能力"></a><strong>四类迹象，发现你的隐藏能力</strong></h3><h3 id="三种方法，将知识内化成能力"><a href="#三种方法，将知识内化成能力" class="headerlink" title="三种方法，将知识内化成能力"></a><strong>三种方法，将知识内化成能力</strong></h3><h3 id="三大系统，让学习不靠意志力"><a href="#三大系统，让学习不靠意志力" class="headerlink" title="三大系统，让学习不靠意志力"></a><strong>三大系统，让学习不靠意志力</strong></h3><h3 id="三个建议，让你不做“定制化人才”"><a href="#三个建议，让你不做“定制化人才”" class="headerlink" title="三个建议，让你不做“定制化人才”"></a><strong>三个建议，让你不做“定制化人才”</strong></h3><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
          <category> 鸡汤笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸡汤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS 系统入门：常用软件</title>
      <link href="/2019/10/27/os-mac-software.html"/>
      <url>/2019/10/27/os-mac-software.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>整理一些常用的Mac软件下载站以及MAC精品软件。</p><blockquote><p>为了你的隐私安全，PC&#x2F;移动端的浏览器选用，不建议使用国内套壳浏览器（360&#x2F;QQ&#x2F;搜狗等）推荐使用chrome、<a href="https://www.mozilla.org/en-US/firefox/new/">Firefox国际版</a>；<br>输入法方面电脑端推荐使用自带输入法，如需使用第三方输入法，建议选择知名软件博主制作的去广告、绿色版的输入法程序，此类软件的绿色版只是去掉了多余的权限但依然无法避免隐私泄露的问题。移动端与电脑端同理，不建议使用国内输入法，容易被输入法记录打字习惯，打字数据等。</p></blockquote><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><h3 id="Mac软件搜索技巧"><a href="#Mac软件搜索技巧" class="headerlink" title="Mac软件搜索技巧"></a><strong>Mac软件搜索技巧</strong></h3><ul><li>我日常找Mac软件会先访问国外的站点如：Cmacapps 因为国内除个别个技术雄厚的站以外大都是国外站点的搬运工，靠收会员费卖广告盈利，我虽能理解，但还是对靠这种信息不对称的收割行为非常厌恶。</li><li>国外站点找不到软件会继续看看国人做的博客如： 脑袋瓜子、马可波罗，思杰马克丁相关的软件会去热心人士成立的站点 FuckMakeding 扒拉一下，如果还搜索不到就去谷歌用关键词大法地毯式搜索：<code>软件名称+mac+破解</code>。</li><li>要是还找不到就会去某宝试试关键词：<code>软件名称 + 兑换码</code>、<code>软件名称 + 序列号</code>等，来看下商家代理的对软件销售情况，如果发现了商家卖你想要软件的兑换码，提取商品标题里的关键词，然后继续使用某宝搜索，让搜索结果更加精准，最后就能找到一些低价的软件兑换码，但要注意价格小心翻车。如果不想卖软件序列号的话，可以把用在你在淘宝上搜索的关键词放到谷歌上搜索，尝试获取另一批内容。</li></ul><hr><p>PS：不同搜索引擎搜索结果也是不同的，搜索盗版软件可优先尝试 <a href="https://duckduckgo.com/">duckduckgo</a>，搜索国外软件纯英文搜索词&gt;中文搜索词。</p><h3 id="Mac软件国内外下载站"><a href="#Mac软件国内外下载站" class="headerlink" title="Mac软件国内外下载站"></a><strong>Mac软件国内外下载站</strong></h3><table><thead><tr><th align="left">网站名称</th><th align="left">地址</th><th align="center">语言</th><th align="center">良心程度</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">风云社区</td><td align="left"><a href="https://www.scoee.com/">https://www.scoee.com</a></td><td align="center"><font color="#6724de">中文</font></td><td align="center"><font color="#f55d00">优</font></td><td align="left"></td></tr><tr><td align="left">Cmacapps</td><td align="left"><a href="https://cmacapps.com/">https://cmacapps.com</a></td><td align="center"><font color="#00876b">英文</font></td><td align="center"><font color="#f55d00">优</font></td><td align="left">非常强悍</td></tr><tr><td align="left">马可菠萝</td><td align="left"><a href="https://www.macbl.com/">https://www.macbl.com</a></td><td align="center"><font color="#6724de">中文</font></td><td align="center"><font color="#f55d00">优</font></td><td align="left"></td></tr><tr><td align="left">FuckMakeding</td><td align="left"><a href="https://www.fxxkmakeding.xyz/">https://www.fxxkmakeding.xyz</a></td><td align="center"><font color="#6724de">中文</font></td><td align="center"><font color="#f55d00">优</font></td><td align="left">反思杰马克丁热心人士</td></tr><tr><td align="left">柠檬精选</td><td align="left"><a href="https://lemon.qq.com/lab">https://lemon.qq.com/lab</a></td><td align="center"><font color="#6724de">中文</font></td><td align="center"><font color="#f55d00">优</font></td><td align="left">国内免费应用自荐</td></tr><tr><td align="left">脑袋瓜子</td><td align="left"><a href="https://www.naodai.org/">https://www.naodai.org</a></td><td align="center"><font color="#6724de">中文</font></td><td align="center"><font color="#f55d00">优</font></td><td align="left">CleanMyMac更新勤快</td></tr><tr><td align="left">mac torrent download</td><td align="left"><a href="http://mac-torrent-download.net/">http://mac-torrent-download.net</a></td><td align="center"><font color="#00876b">英文</font></td><td align="center"><font color="#0078df">良</font></td><td align="left">软件用种子的形式发布</td></tr><tr><td align="left">NMac Ked</td><td align="left"><a href="https://nmac.to/">https://nmac.to</a></td><td align="center"><font color="#00876b">英文</font></td><td align="center"><font color="#0078df">良</font></td><td align="left">更新速度很快，英文博客</td></tr><tr><td align="left">懒得勤快</td><td align="left"><a href="https://masuit.com/">https://masuit.com</a></td><td align="center"><font color="#6724de">中文</font></td><td align="center"><font color="#0078df">良</font></td><td align="left">不算纯Mac站，但有黑科技</td></tr><tr><td align="left">xclient</td><td align="left"><a href="https://xclient.info/">https://xclient.info</a></td><td align="center"><font color="#6724de">中文</font></td><td align="center"><font color="#0078df">良</font></td><td align="left"></td></tr><tr><td align="left">Mac毒</td><td align="left"><a href="https://www.macdu.org/">https://www.macdu.org</a></td><td align="center"><font color="#6724de">中文</font></td><td align="center"><font color="#0078df">良</font></td><td align="left"></td></tr><tr><td align="left">麦氪派</td><td align="left"><a href="https://www.waitsun.com/">https://www.waitsun.com</a></td><td align="center"><font color="#6724de">中文</font></td><td align="center"><font color="#0078df">良</font></td><td align="left"></td></tr><tr><td align="left">APPKED</td><td align="left"><a href="https://www.macappdownload.com/">https://www.macappdownload.com</a></td><td align="center"><font color="#00876b">英文</font></td><td align="center"><font color="#0078df">良</font></td><td align="left"></td></tr><tr><td align="left">易破解</td><td align="left"><a href="http://www.ypojie.com/pc/mac">http://www.ypojie.com/pc/mac</a></td><td align="center"><font color="#6724de">中文</font></td><td align="center"><font color="#0078df">良</font></td><td align="left">不算纯Mac站</td></tr><tr><td align="left">史蒂芬周博客</td><td align="left"><a href="http://www.sdifen.com/">http://www.sdifen.com</a></td><td align="center"><font color="#6724de">中文</font></td><td align="center"><font color="#8c2e00">差</font></td><td align="left">.</td></tr></tbody></table><h3 id="Mac精品软件"><a href="#Mac精品软件" class="headerlink" title="Mac精品软件"></a><strong>Mac精品软件</strong></h3><table><thead><tr><th align="left">软件名称</th><th align="left">官网</th><th align="left">类型</th><th align="center">是否中文</th><th align="center">是否付费</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left"><a href="https://dozermac.com/">Dozer</a></td><td align="left"></td><td align="left"><font color="#00876b">系统工具</font></td><td align="center"><font color="#dd0081">✖ </font></td><td align="center"><font color="#e9a800">✖</font></td><td align="left">菜单栏图标隐藏</td></tr><tr><td align="left"><a href="https://www.mowglii.com/itsycal">Itsycal</a></td><td align="left"></td><td align="left"><font color="#00876b">系统工具</font></td><td align="center"><font color="#dd0081">✖ </font></td><td align="center"><font color="#e9a800">✖</font></td><td align="left">菜单栏日历功能增强</td></tr><tr><td align="left"><a href="https://apps.apple.com/cn/app/%E4%B8%87%E5%B9%B4%E5%8E%86-%E6%97%A5%E5%8E%86%E4%BB%A5%E5%8F%8A%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E5%B7%A5%E5%85%B7/id1185943818">万年历 - 日历以及天气预报工具</a></td><td align="left">App Store</td><td align="left"><font color="#00876b">系统工具</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#e9a800">✖</font></td><td align="left">菜单栏日历功能增强</td></tr><tr><td align="left"><a href="https://www.iterm2.com/">iterm2</a></td><td align="left"></td><td align="left"><font color="#00876b">系统工具</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#e9a800">✖</font></td><td align="left">优雅的命令行工具</td></tr><tr><td align="left"><a href="https://fireball.studio/oneswitch">One Switch</a></td><td align="left"></td><td align="left"><font color="#00876b">系统工具</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#cecdca">✔</font></td><td align="left">菜单栏管理工具</td></tr><tr><td align="left"><a href="https://pock.dev/">pock</a></td><td align="left"></td><td align="left"><font color="#00876b">系统工具</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#e9a800">✖</font></td><td align="left">Touch Bar增强工具</td></tr><tr><td align="left"><a href="https://apps.apple.com/cn/app/backtrack-record-past-audio/id1477089520">Backtrack</a></td><td align="left">App Store</td><td align="left"><font color="#00876b">系统工具</font></td><td align="center"><font color="#dd0081">✖ </font></td><td align="center"><font color="#e9a800">✖</font></td><td align="left">菜单栏录音工具</td></tr><tr><td align="left"><a href="https://lemon.qq.com/">Lemon Cleaner</a></td><td align="left"></td><td align="left"><font color="#00876b">系统工具</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#e9a800">✖</font></td><td align="left">腾讯出品垃圾清理工具</td></tr><tr><td align="left"><a href="http://www.mycleanmymac.com/">CleanMyMac</a></td><td align="left"></td><td align="left"><font color="#00876b">系统工具</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#cecdca">✔</font></td><td align="left">强大的mac系统清理工具</td></tr><tr><td align="left"><a href="https://cocoatech.com/">Path Finder</a></td><td align="left"></td><td align="left"><font color="#00876b">系统工具</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#cecdca">✔</font></td><td align="left">系统文件管理器</td></tr><tr><td align="left"><a href="https://amphetamine.en.softonic.com/mac">Amphetamine</a></td><td align="left"></td><td align="left"><font color="#00876b">系统工具</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#e9a800">✖</font></td><td align="left">防休眠工具</td></tr><tr><td align="left"><a href="https://iina.io/">IINA</a></td><td align="left"></td><td align="left"><font color="#f55d00">影音视听</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#e9a800">✖</font></td><td align="left">mac最好的视频软件</td></tr><tr><td align="left"><a href="https://github.com/zenghongtu/Mob">Mob</a></td><td align="left"></td><td align="left"><font color="#f55d00">影音视听</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#e9a800">✖</font></td><td align="left">喜马拉雅Mac版（非官）</td></tr><tr><td align="left"><a href="https://github.com/ddddxxx/LyricsX">LyricsX</a></td><td align="left"></td><td align="left"><font color="#f55d00">影音视听</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#e9a800">✖</font></td><td align="left">Spotify、Apple Music歌词工具</td></tr><tr><td align="left"><a href="https://github.com/listen1/listen1_desktop">listen1</a></td><td align="left"></td><td align="left"><font color="#f55d00">影音视听</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#e9a800">✖</font></td><td align="left">网易、QQ、虾米聚合播放器</td></tr><tr><td align="left"><a href="https://motrix.app/zh-CN">motrix</a></td><td align="left"></td><td align="left"><font color="#0078df">网络工具</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#e9a800">✖</font></td><td align="left">下载工具支持BT、迅雷等</td></tr><tr><td align="left"><a href="https://www.freedownloadmanager.org/zh">free download</a></td><td align="left"></td><td align="left"><font color="#0078df">网络工具</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#e9a800">✖</font></td><td align="left">国外下载工具</td></tr><tr><td align="left"><a href="https://partner.lizhi.io/xclient/downie">Downie</a></td><td align="left"></td><td align="left"><font color="#0078df">网络工具</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#cecdca">✔</font></td><td align="left">优秀视频下载软件</td></tr><tr><td align="left"><a href="https://ezip.awehunt.com/">ezip</a></td><td align="left"></td><td align="left"><font color="#e9a800">应用软件</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#e9a800">✖</font></td><td align="left">免费解压缩工具</td></tr><tr><td align="left"><a href="https://www.keka.io/zh-cn">Keka</a></td><td align="left"></td><td align="left"><font color="#e9a800">应用软件</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#e9a800">✖</font></td><td align="left">免费解压缩工具</td></tr><tr><td align="left"><a href="https://ranchero.com/netnewswire">NetNewsWire</a></td><td align="left"></td><td align="left"><font color="#e9a800">应用软件</font></td><td align="center"><font color="#dd0081">✖ </font></td><td align="center"><font color="#e9a800">✖</font></td><td align="left">开源RSS阅读工具</td></tr><tr><td align="left"><a href="https://apps.apple.com/cn/app/maipo-for-weibo/id789066512">Maipo for 微博</a></td><td align="left">App Store</td><td align="left"><font color="#e9a800">应用软件</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#e9a800">✖</font></td><td align="left">新浪微博mac版（非官）</td></tr><tr><td align="left"><a href="https://apps.apple.com/cn/app/spark-email-app-by-readdle/id1176895641">Spark</a></td><td align="left">App Store</td><td align="left"><font color="#e9a800">应用软件</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#e9a800">✖</font></td><td align="left">邮箱收发信工具</td></tr><tr><td align="left"><a href="http://www.ntfsformac.cc/">Tuxera</a></td><td align="left"></td><td align="left"><font color="#e9a800">应用软件</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#cecdca">✔</font></td><td align="left">快速读写NTFS格式磁盘工具</td></tr><tr><td align="left"><a href="https://www.office.com/">Office</a></td><td align="left"></td><td align="left"><font color="#e9a800">应用软件</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#cecdca">✔</font></td><td align="left">办公软件</td></tr><tr><td align="left"><a href="http://dict.eudic.net/">欧路词典</a></td><td align="left"></td><td align="left"><font color="#e9a800">应用软件</font></td><td align="center"><font color="#cecdca">✔ </font></td><td align="center"><font color="#e9a800">✖</font></td><td align="left">词典软件</td></tr><tr><td align="left"><a href="https://www.jetbrains.com/idea/">IDEA</a></td><td align="left"></td><td align="left"><font color="#dd0081">软件开发</font></td><td align="center"><font color="#dd0081">✖ </font></td><td align="center"><font color="#cecdca">✔</font></td><td align="left">java集成IDE</td></tr></tbody></table><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>欢迎大家跟帖补充及修正～</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS 系统入门：系统使用</title>
      <link href="/2019/10/27/os-mac-basic.html"/>
      <url>/2019/10/27/os-mac-basic.html</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>整理MacOS系统的一些基本知识。</p><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><h3 id="关于桌面"><a href="#关于桌面" class="headerlink" title="关于桌面"></a><strong>关于桌面</strong></h3><ul><li><p><code>程序坞</code></p><ul><li>原名叫Dock栏，位于桌面底部，这样设计的好处是程序坞不会被程序的界面所遮挡。</li><li>程序坞的右侧有一条黑色的竖线，竖线的左边是程序的图标，竖线的右边可以放置文件或者文件夹，这样可以通过桌面快速的打开文件。</li></ul></li><li><p><code>菜单栏</code></p><ul><li>菜单栏的最左侧有一个苹果LOGO，类似Win中的“开始”按键，但又有不同，MAC不会将所有应用都至于其中，里面都是一些基础操作。</li><li>菜单栏的右上角(状态菜单)则是输入法、WIFI、电量、时间以及部分程序的状态显示，可通过Command+拖动来更换图标位置。</li><li>菜单栏的左上角(应用菜单)则是显示当前APP的一些设置和功能，切换不同的软件时该菜单也会跟着变动，这样设计不会遮挡程序的显示内容、习惯统一、界面美观。</li></ul></li><li><p><code>调度中心</code></p><ul><li>调度中心的作用是快速显示当前正在用的窗口，方便切换。在Mac OS中可以存在多个桌面，每个桌面都可以单独打开一个应用无缝切换。</li><li>通过快捷键F3或者触摸板四指向上滑动可呼出此功能，可以添加、删除桌面以及将窗口归类到指定桌面等操作。</li></ul></li><li><p><code>关闭退出应用</code></p><ul><li>在应用和窗口的左上角有红黄绿三个小点，可以理解为Windows上的关闭、最小化、最大化，但其中又有一点点区别。</li><li>点击最小化按钮会将应用窗口变为一个缩略图排布在Dock栏右侧。</li><li>点击关闭按钮有时并不是完全退出应用，而是将应用的窗口关闭。某些应用即使点了关闭按钮依旧会有一个小黑点标识，说明程序依旧在运行。</li><li><strong>彻底关闭应用：右击Dock栏正在运行的应用——退出；或者直接采用快捷键Command+Q。</strong></li></ul></li><li><p><code>强制退出应用</code></p><ul><li>MAC有时候会因为内存占用过大或者处理器性能不够而导致应用卡死，这个时候可以通过Command+Option+ESC来呼出”强制退出应用程序”功能。</li></ul></li><li><p><code>Dock栏添加/移除应用</code></p><ul><li>如果想将应用保留在Dock栏，可以直接在启动台中将应用图标拖移至Dock栏，或者打开软件后在Dock上右键这个图标——选项——在Dock栏中保留。</li><li>同理在选中Dock栏的程序后往屏幕外拖移即可移除应用（并非是是卸载）。</li></ul></li><li><p><code>系统偏好设置</code></p><ul><li>可以理解为Windows中的控制面板，Mac系统中的所有功能都可以在其中设置。</li><li>当你不知道某一设置具体在哪的情况下可以通过右上角的搜索框来输入关键词查找。</li></ul></li></ul><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a><strong>文件管理</strong></h3><ul><li><p><code>访达(finder)</code></p><ul><li>在Dock栏最左边的第一个应用即是访达(访问文件,一触即达)，finder类似Win上的(文件)资源管理器且一直处于运行状态无法退出。</li><li>在Mac中并不会区分C、D、E等盘，而是在左侧提供了几个默认分类，根据需求存放文件即可。</li><li>finder中的文件可以使用图标、列表、分栏以及画廊四种形式来展示，有的时候文件夹比较深，找文件不方便，可以采用分栏的形式。</li><li>画廊的方式适合浏览图片，为了更好的视觉效果，显示区可以放大一些，双指在触控栏左右滑动就能够快速展示图片内容，提高文件查阅效率。</li><li>有时候因为文件排的比较满没有空白的区域新建文件夹，这时可以通过菜单栏功能新建文件夹或者选中文件后右键选择”用所选项目新建文件夹”。</li></ul></li><li><p><code>快速预览文件</code></p><ul><li>有时候因为文件的缩略图太小，文件名又很类似，找到某个文件需要频繁打开关闭，其实选中文件后单击空格键可以快速预览文件，再按空格即可关闭。</li><li>预览是跨越文件类型的，凡是Mac系统支持的文件通通可以查看，包括文本、Word、Excel、PDF、图片、音频、视频甚至是raw格式的文件。</li></ul></li><li><p><code>快速重命名</code></p><ul><li>MAC上的回车键除了正常发送、确认，还有另外一个比较常用的功能就是文件重命名。选中文件——点击回车键——重命名。</li><li>此方法对文件是没有效果的，可以使用鼠标连续点击某个文件夹&#x2F;文件的名称两次进行重命名，这个里面的连续点击有一个间隔时间，大概是1s左右。</li></ul></li><li><p><code>聚焦搜索(Spotlight)</code></p><ul><li>聚焦搜索是MAC非常实用的功能之一，可以查询Mac上的应用、文稿、照片和其他文件以及进行单位换算等操作，通过Command+空格可以直接呼出。</li><li>直接点击文件名是打开它，按住Command不松再双击这个文件名，就能在访达中找到它了。</li><li>当搜索内容时，再次按Command+B，还可以打开浏览器百度搜索这个关键字。</li><li>当程序坞中的启动台图标不小心移除了，可以通过聚焦搜索后将其拖到程序坞即可。<blockquote><p>活动监视器：查看正在运行的软件情况(CPU,内存,能耗,磁盘,网络)<br>  文本编辑：新建记事本，格式是rtf<br>  终端：可以输入linux等命令,例如ifconfig查看本机的IP地址<br>  字体册：可以安装字体<br>  磁盘工具：可以硬盘维护&#x2F;格式化硬盘<br>  抓图：可定时抓取屏幕,在菜单栏的”捕捉-屏幕定时”开始启动</p></blockquote></li></ul></li><li><p><code>标记</code></p><ul><li>在标记的文件夹里删除文件是真的删除，原路径里的文件也会消失，同样的道理把标记里的文件拖移到别的文件夹，也会改变原先文件的存储路径。</li><li>标记索引的结果，也可以像普通文件夹一样添加到程序坞，方便快速调用；添加标记操作还可以设置快捷键，方便快速添加标记。</li></ul></li></ul><h3 id="程序安装"><a href="#程序安装" class="headerlink" title="程序安装"></a><strong>程序安装</strong></h3><ul><li><code>安装软件</code></li></ul><pre><code class="hljs plaintext">方法一：通过App Store安装软件    与IOS相同，MAC OS中同样有App Store，用户可以通过自己的iCloud ID登录商店下载购买软件。    App Store中的软件都是通过官方审核，可以帮助用户自动完成下载以及安装，不会出现下载下来不能安装或者无法打开的问题。方法二：直接下载安装软件    部分软件App Store无法下载到，可以在各种网站上搜索下载。    一种是DMG格式的压缩文件，类似windows的iso格式，打开后直接将.app文件夹拖入Applactions文件夹即可完成安装，在应用程序文件夹里和启动台都能找到。    一种是PKG格式的安装文件，类似windows的exe和msi格式，pkg安装一般要求sudo授权，卸载pkg安装的应用也比较麻烦。</code></pre><p>PS：有时通过DMG文件中的pkg文件安装程序后,不会出现在应用程序的文件夹里,而是作为系统的一个支持文件在需要的时候自动运行。</p><ul><li><code>卸载软件</code></li></ul><pre><code class="hljs plaintext">以下方法适合DMG格式的卸载，对于PKG格式的卸载，除了其自身可能提供的卸载程序，还可以借助CleanMyMac等第三方软件来彻底卸载删除。方法一：访达-&gt;应用程序，选中想要卸载的应用程序，移到废纸篓(类似windows中的回收站)或者command+delete删除。    此方法也适用于删除文件。使用Command+Option+delete可以绕过废纸篓彻底删除文件。方法二：启动台(Launchpad)，按下option键或者按住图标不松，软件会出现抖动，点击图标左上角的XX即可卸载。    跟Windows 8/10的开始菜单类似，都是放软件的快捷图标，只是Mac的更加iOS而已。    这种卸载的方式只适用于从App Store安装的软件。</code></pre><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a><strong>快捷键</strong></h3><pre><code class="hljs plaintext">Fn键    Windows可以使用Fn搭配F1—F12来调节笔记本的音量、屏幕亮度等属性；而MAC快捷键不需要搭配任何按键就可以来调节音量亮度。    如果希望无需按住Fn键而将顶行按键始终用作标准功能键，请完成以下操作：系统偏好设置——键盘——键盘标签——将 F1、F2 等键用作标准功能键。    对于带有TouchBar的用户来说这些就都不是问题了。Command    可以简单的将其理解为WIN系统的Ctrl键，通过Command与其他一些按键的组合能够实现复制黏贴等比较常用的快捷操作。</code></pre><ul><li><code>常用基础快捷键</code></li></ul><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Command + N</td><td align="left">新建窗口,有些程序支持多窗口操作</td></tr><tr><td align="left">Command + T</td><td align="left">新建标签页,有些时候标签页比窗口更加简洁</td></tr><tr><td align="left">Command + Q</td><td align="left">退出当前使用的程序</td></tr><tr><td align="left">Command + W</td><td align="left">关闭当前的窗口&#x2F;标签页,有些程序支持多窗口操作</td></tr><tr><td align="left">Command + Tab</td><td align="left">切换程序,到最近使用过的程序窗口,Command按住不松继续按Q可依次关闭程序</td></tr><tr><td align="left">Command + ～&#x2F;&#96;</td><td align="left">切换窗口,在当前桌面同一程序的不同窗口间进行切换</td></tr><tr><td align="left">Command + 点击</td><td align="left">使用新的标签页打开页面,例如在浏览器打开超链接</td></tr><tr><td align="left">Command + H</td><td align="left">将最前面的窗口隐藏</td></tr><tr><td align="left">Command + M</td><td align="left">将最前面的窗口最小化至 Dock</td></tr><tr><td align="left">Command + X</td><td align="left">剪切文本内容</td></tr><tr><td align="left">Command + C</td><td align="left">复制文本内容&#x2F;文件</td></tr><tr><td align="left">Command + V</td><td align="left">粘贴</td></tr><tr><td align="left">Command + Option + V</td><td align="left">移动文件(需配合Command + C) ,<strong>移动文件功能还可以使用拖拽实现</strong></td></tr><tr><td align="left">fn + delete</td><td align="left">删除光标右边的内容</td></tr><tr><td align="left">Control + 空格</td><td align="left">切换输入法</td></tr></tbody></table><ul><li><code>常用截屏快捷键</code></li></ul><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Command + Shift + 3</td><td align="left">截取整个屏幕并保存</td></tr><tr><td align="left">Command + Shift + Control + 3</td><td align="left">截取整个屏幕到剪贴板</td></tr><tr><td align="left">Command + Shift + 4</td><td align="left">截取部分屏幕并保存,出现十字准线,按下鼠标或者在触控板上三指拖移来选择区域并松手</td></tr><tr><td align="left">Command + Shift + Control + 4</td><td align="left">截取部分屏幕到剪贴板,可以先按Command+Shift+4出现十字准线,松手再按Control选取区域</td></tr><tr><td align="left">Command + Shift + 4 + 空格</td><td align="left">截取某个窗口(包括桌面),可以先按Command+Shift+4出现十字准线,松手点下空格,光标会变成相机图标,移动光标点按鼠标或触控板确定</td></tr><tr><td align="left">Command + Shift + 5</td><td align="left">调出图形界面</td></tr><tr><td align="left">Command + Shift + 6</td><td align="left">截取TouchBar</td></tr><tr><td align="left">截图快捷键 + Option</td><td align="left">截图去阴影</td></tr><tr><td align="left">Esc</td><td align="left">取消截图</td></tr></tbody></table><ul><li><code>常用Option快捷键</code></li></ul><table><thead><tr><th align="left">功能</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><strong>拖拽粘贴</strong></td><td align="left">Mac内拖拽文件默认是剪切,拖拽时按住Option,能在移动文件的同时达到复制粘贴的效果。</td></tr><tr><td align="left"><strong>查看隐藏的菜单栏功能</strong></td><td align="left">点击菜单栏的相关图标时按住Option,会有意想不到的功能,例如点击wifi图标会出现各种隐藏的网络属性。</td></tr><tr><td align="left"><strong>关闭多个窗口</strong></td><td align="left">在同一程序打开多个窗口时,按住Option的同时点击关闭,能关闭所有的窗口页面,例如关闭多个访达窗口。</td></tr><tr><td align="left"><strong>显示检查器</strong></td><td align="left">使用Command+I能查看文件的简介,使用Option+Command+I能打开检查器,动态显示不同文件对应的简介内容。</td></tr><tr><td align="left"><strong>更改默认查看方式&#x2F;拷贝路径</strong></td><td align="left">按住Option的同时,右键文件可以更改默认打开方式,同时也可以拷贝文件的路径。</td></tr><tr><td align="left"><strong>快速翻页</strong></td><td align="left">在页面很长又需要频繁的上下翻页的场景中,按下Option的同时,点击滚动条的空白位置就能瞬间定位到指定区域。</td></tr><tr><td align="left"><strong>展开所有文件夹</strong></td><td align="left">在访达中,按下Option的同时,点击文件夹左边的三角箭头,系统就能自动展开所有文件夹。</td></tr></tbody></table><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">option + 2 （英文模式下）</td><td align="left">商标™</td><td align="left">option + R</td><td align="left">注册商标®</td></tr><tr><td align="left">option + ＝</td><td align="left">不等号≠</td><td align="left">option + X</td><td align="left">约等于≈</td></tr><tr><td align="left">option + .</td><td align="left">大于或等于≥</td><td align="left">option + ,</td><td align="left">小于或等于≤</td></tr><tr><td align="left">option + P</td><td align="left">圆周率π（大写为∏）</td><td align="left">option + K</td><td align="left">度°</td></tr><tr><td align="left">option + G</td><td align="left">版权©</td><td align="left">option + &#x2F;</td><td align="left">除号÷</td></tr><tr><td align="left">option + 3</td><td align="left">英镑￡</td><td align="left">option + 4 （英文模式下）</td><td align="left">美分¢</td></tr><tr><td align="left">shift + option + 2</td><td align="left">欧元€</td><td align="left"></td><td align="left"></td></tr></tbody></table><h3 id="触控板"><a href="#触控板" class="headerlink" title="触控板"></a><strong>触控板</strong></h3><ul><li><code>无缝衔接鼠标的五大基本功能</code></li></ul><table><thead><tr><th align="left">功能</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><strong>拖拽粘贴</strong></td><td align="left">Mac内拖拽文件默认是剪切,拖拽时按住Option,能在移动文件的同时达到复制粘贴的效果。</td></tr><tr><td align="left"><strong>移动光标</strong></td><td align="left">有时找不到光标时,这时单指快速的摇一摇,光标会马上变身放大</td></tr><tr><td align="left"><strong>左键点击</strong></td><td align="left">单指点按出单击,点按力度可以调;用力点按还可以用来查询单词(不需要选中)</td></tr><tr><td align="left"><strong>右键点击</strong></td><td align="left">即辅助点按,双指(轻)点按出右键,不用挪到右下角</td></tr><tr><td align="left"><strong>滑动滚轮</strong></td><td align="left">双指滚动,要看下面的内容往上翻,要看上面的内容往下拽</td></tr><tr><td align="left"><strong>拖拽选取</strong></td><td align="left">开启三指拖移(辅助功能-&gt;指针控制-&gt;触控板选项——启用拖移&gt;三指拖移),先放下2个手指头，然后只留下食指移动</td></tr></tbody></table><ul><li><code>其他手势操作</code></li></ul><table><thead><tr><th align="left">功能</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><strong>放大或缩小</strong></td><td align="left">网页,图片,PDF文稿等可以通过双指的捏合进行放大或缩小</td></tr><tr><td align="left"><strong>智能缩放</strong></td><td align="left">双指轻拍两下就能智能缩放</td></tr><tr><td align="left"><strong>旋转</strong></td><td align="left">双指旋转能在预览中改变照片的显示方向</td></tr><tr><td align="left"><strong>通知中心</strong></td><td align="left">双指从触控板的右边缘进入,向左轻扫就能显示通知中心(不起效果)</td></tr><tr><td align="left"><strong>在页面间轻扫</strong></td><td align="left">在浏览器中,通过双指左右轻扫,可在不同页面间切换</td></tr><tr><td align="left"><strong>切换桌面</strong></td><td align="left">三(四)指左右轻扫,就能在全屏应用程序和不同桌面之间进行切换</td></tr><tr><td align="left"><strong>调度中心</strong></td><td align="left">三(四)指向上轻扫,能看见互相遮挡叠加的应用程序以及不同的桌面,点击需要的程序就能排在最前面</td></tr><tr><td align="left"><strong>App Expose</strong></td><td align="left">三(四)指向下轻扫,和调度中心一样,只不过它中会针对当前选中的一个程序进行平铺,例如excel中</td></tr><tr><td align="left"><strong>启动台</strong></td><td align="left">将拇指和另外三根手指合拢到一起,就可以显示启动台</td></tr><tr><td align="left"><strong>显示桌面</strong></td><td align="left">将拇指和另外三根手指同时展开,就可以显示桌面</td></tr></tbody></table><h3 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a><strong>输入法</strong></h3><ul><li><code>原生输入法的隐藏技巧</code>  <pre><code class="hljs plaintext">1、翻页选词：反括号键(])2、中英文数字混合输入：按住shift大写字母；按住option输入数字3、复杂字拆字输入：eg：淼：输入3个水，按住shift和空格4、标注拼音的声调：在键盘--输入法中添加&quot;英语-&gt;ABC扩展&quot;，在这种输入法下,先按住option+AEV～(四个键分别表示四个声调)输入声调,再输入元音字母5、拼音间隔：在元音之间加引号,例如西安、余额宝等6、emoji：command+control+空格7、在中文输入法下,要临时输入大写,按住shift即可;要切换到英文呢,点按大写锁定键即可,要持续输入英文呢,长按大写锁定键不松即可.</code></pre></li><li><code>三种不需要键盘就能输入的方法</code>  <pre><code class="hljs plaintext">1、手写输入    先去&quot;键盘-输入法&quot;中,点击+号添加手写输入,在菜单栏中点击输入法切换或者快捷键Control+shift+空格来唤醒手写输入.2、语音输入    在任何能打字的地方,连按两下FN就能开启语音输入,可去&quot;键盘-听写&quot;中打开此功能.3、虚拟键盘    在&quot;键盘-键盘&quot;中勾选&quot;在菜单栏中显示虚拟按键及表情检视器&quot;,在菜单栏中点击输入法切换调出虚拟键盘.</code></pre></li></ul><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a><strong>常见问题</strong></h3><ul><li><code>MAC需要关机吗</code>  <pre><code class="hljs plaintext">关于mac要不要关机其实并没有个准确说法，大部分mac用户都没有关机的习惯，原因有如下几点    1.mac开关机所需的时间较长，为了追求高效连续性的工作，MacBook可以使用开盖合盖来代替开关机。    2.MacBook合盖后进入睡眠模式，此时所有应用程序都会被冻结，电池只为内存供电，消耗极少。    3.mac系统更加稳定以及固态硬盘更长的寿命，可以保证长时间睡眠模式后唤醒的时候也不至于出现睡死情况。</code></pre></li><li><code>MAC需要安装杀毒软件吗</code>  <pre><code class="hljs plaintext">对于大部分用户来说MAC不需要安装杀毒软件，如果你非常重视自己的电脑安全，非要采取一些手段保护的话，可以参考以下建议    1.不要去安装类似360安全卫士之类的国产杀毒软件。    2.Mac OS会频繁针对系统漏洞进行更新，请务必将自己的Mac OS保持最新版本。    3.尽量在App Store下载官方应用，如果非要安装第三方应用请选择值得信任的网站进行下载。    4.使用时间机器备份系统，如果系统出现问题也可以恢复到之前的任意时间。</code></pre></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://post.smzdm.com/p/679153">Mac新手必看教程—轻松玩转Mac OS</a></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>欢迎大家跟帖补充及修正～</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>投资理财：基础</title>
      <link href="/2019/08/28/te-investment-financing.html"/>
      <url>/2019/08/28/te-investment-financing.html</url>
      
        <content type="html"><![CDATA[<h1 id="投资理财：基础"><a href="#投资理财：基础" class="headerlink" title="投资理财：基础"></a>投资理财：基础</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>理财就是理生活.</p><p>童话读物-小狗钱钱.</p><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><h3 id="正课"><a href="#正课" class="headerlink" title="正课"></a>正课</h3><ul><li><p>三个锦囊,帮我们避免理财雷区</p>  <pre><code class="hljs plaintext">a.通货膨胀    1.俗称&quot;钱不值钱了&quot;,指的是物价持续的上升,钱的购买力下降了.    2.通货膨胀对三类人很不友好：把钱放家里的人(无利息)、把钱存银行的人(利息1%-2%)、靠固定收入过日子的人(死工资).        近20年的平均通货膨胀率在年化5%左右.        不要把钱在家里,不要把钱存进银行,不要依靠固定收入.具体的操作可以通过理财实现.b.理财的三大好处    1.跑赢通货膨胀        只要理财的收益率高于5%就行,像余额宝等产品收益率一般在3%-4%左右,注定是跑不赢的.    2.带来被动收入        收入分为主动收入和被动收入;前者是通过主动付诸劳动获得的收入,后者就是我们在死工资之外,通过钱生钱的方式获得的那部分收入.        如果一个人只靠被动收入就可能满足他的所有支出,不需要花费主动收入的钱,那么他就实现了财务自由.    3.避免被人挖坑        银行门口推销的理财保险的收益一般在3%以下,跟余额宝差不多,而且保障部分的保额低,起不到真正的保障作用,不建议买.c.理财的三大误区    1.现在没钱,想等有钱了再开始理财.         -&gt;不是因为有钱了才理财,而是因为理财了才有钱.    2.把所有钱都拿去投资.         -&gt;理财用的是自己的闲钱.    3.还没学会就开始上手操作.         -&gt;先学习再投资,不懂的东西不要碰.</code></pre></li><li><p>清点资产,也许你是一个隐形富豪</p>  <pre><code class="hljs plaintext">a.资产和负债的定义    1.资产,就是能把钱放进你口袋里的东西.例如股票、基金、可以收租金的房子等等.    2.负债,就是把钱从你的口袋里取走的东西.例如自用的车子、需要定期维护保养的包包(不能转卖)等等.b.分清楚&quot;必要&quot;&quot;需要&quot;和&quot;想要&quot;    1.&quot;必要&quot;是维持基本生活所需的东西,是你不花会死的.例如喝水、付房租等衣食住行相关的.    2.&quot;需要&quot;是可以在必要基础上进一步改善生活质量的.例如喝牛奶、吃水果等补充营养维生素相关的.    3.&quot;想要&quot;是我们欲望的写照.例如有了棉袄,也有保暖内衣,还想要纯羊绒的妮子大衣,穿上去更修身漂亮,呢子大衣就是想要.c.买东西之前扪心自问    1.这个不买会死吗    2.以后不买会死吗    3.买个便宜的会死吗</code></pre></li><li><p>钱难赚,保险别乱买</p>  <pre><code class="hljs plaintext">a.社会保险:有限的保障    1.简称&quot;社保&quot;.五险一金中的&quot;五险&quot;就是我们常说的社保,其中包括:养老、医疗、工伤、生育和失业保险.    2.其中养老和医疗保险是我们接触频率非常高的,因为不管是什么人,最需要受到保障的也就是:老有所养,病有所医.    3.社保只是最最基本的保障,虽然必不可少,但是作用十分有限.除了社保,我们还需要给自己配置一部分商业保险.        -&gt;到目前为止,很多治疗得大疾病的特效药,副作用小的进口药,医保依然是不能保险的.真正能报销的药品,在已知药品名录里仅占1.4%.        -&gt;如果经过N年的通货膨胀,要靠养老保险保证我们的生活水平有一定的难度.        -&gt;社保的原理就是要覆盖尽可能多的人,要覆盖这么多人,那么保障程度必然不高,否则谁也承担不了这个巨额的成本.b.商业保险:补充社保不足    1.主要包括两大类:人身保险(保的是人的生命或身体)和财产保险(保的是财产及相关利益).    2.人身保险主要分为四大类:意外险、重疾险、医疗险和寿险.其中重疾险和医疗险同属于健康险.        -&gt;意外险,理赔意外伤害而导致的死亡或者残疾.意外伤害必须是外来的、突发的、非本意的以及非疾病的,这四个条件缺一不赔.        -&gt;重疾险,补偿重大疾病带来的经济损失.一般来说,当确诊疾病并符合保险条款时,保险公司就会之际赔付保额.        -&gt;医疗险,理赔在医院看病产生的医疗费用.只要是符合赔付标准的,都可以按照保险条款进行报销.        -&gt;寿险,理赔人的死亡.不管是什么原因导致死亡,只要人死了就理赔.    3.保险不能降低风险,但可以转移风险,避免意外发生后给家人造成巨大的经济损失.c.配置保险的3个误区    1.只重视给老人和孩子买保险,忽视了经济支柱        -&gt;一个家庭中,谁是最应该配置保险的人呢,我们就要看谁如果不在了,会使整个家庭的经济损失最大.        -&gt;因此,最应该配置保险的是一个家庭的经济支柱,而不是老人和小孩.先把大人的保险配置充足了,再考虑孩子和老人的保险.    2.关注产品多余需求        -&gt;应该首先根据家庭的负债情况、未来对家庭孩子的教育支出、家庭必须的生活费的支出,来量化家庭支柱各自承担的责任,以选择最适合家庭的保险产品.        -&gt;因此,买保险要有限考虑需求,看自己需要哪些保障,再来挑选合适的产品.    3.不做财务分析        -&gt;因此,买保险财务分析不能少,按实际说出自己的财务状况,专业人士才能给你精准的保险配置建议.</code></pre></li><li><p>股票,多数人的找死,少数人的等死</p>  <pre><code class="hljs plaintext">a.对股票的两种误解    1.乱投资者的误解:认为买股票就是碰运气,所以盲目进场乱投资.没学会就上手操作,违背了&quot;不懂的东西不碰&quot;的原则.        -&gt;因此,乱投资是找死.    2.不投资者的误解:一想到投资股票有风险,立马就对股票死心了.在通货膨胀面前,不投资不仅不安全,而且是最大的不安全因素.        -&gt;因此,不投资是等死.b.什么是股票    1.股票的本质就是,公司拿出部分的所有权换取资金,用于后续的经营发展.    2.股票可不是一串虚拟的数字,也不是屏幕上那些红红绿绿的线条,它的背后,是一家实实在在的公司.c.股票的赚钱方式    1.公司盈利,获得分红.    2.低买高卖,赚取差价.</code></pre></li><li><p>活了这么多年才知道,银行并不一定安全</p>  <pre><code class="hljs plaintext">第1类投资品:中间商倒买倒卖    代表:银行,P2P,信托    赚钱原理:汇集了很多人的钱,然后再把钱借给需要钱的人,以赚取中间差额    需要关注:中间人的信用.看他们把钱都借给了谁,那些借钱的人能不能还得了欠的钱和利息.        -&gt;银行一般都借给有固定资产抵押的大型企业,还不出来的人相对较少,风险相对较低.        -&gt;民间高利贷和小额信贷,是借给那些着急用钱并承诺给高额汇报的个人或公司,由于借钱人组织良莠不齐,借贷手续简单,无法充分保证收回资金,风险相对较高.第2类投资品:无中间商赚差价    代表:债券(包括国债,地方债,企业债)    赚钱原理:把钱借给国家,地方政府或者企业,赚取利息.    需要关注:借款人的信用资质,看看他们还你钱的几率有多大.        -&gt;政府的信用是良好的,所以国债几乎被认为无风险,除非国家被攻占了,还不出钱的几率很小.        -&gt;地方政府的信用参差不齐,部分地方债的风险就比较高,风险比企业债还高.企业债就要看企业家的信用了.第3类投资品:拥有部分资产    代表:股票    赚钱原理:人们用自己的钱买公司的部分资产,与公司共同承担风险,亏盈共享.你需要找到赚钱的公司,并出钱投资它.    需要关注:你出钱投资的这家公司赚不赚钱.第4类投资品:成为资产所有人    代表:黄金,期货,艺术品收藏等    赚钱原理:靠着外部信息,通过预测未来的涨跌赚钱,与自身的价值无关.    需要专注:哪些因素会影响价格,然后综合判断.第5类投资品:混合型投资品    代表:银行理财,基金等    赚钱原理:它投资的不是单一的东西,里面既有股票也有债券.    需要关注:根据高低风险投资品的成分占比,来判断它是否符合你的投资需求.        -&gt;不是带着&quot;银行&quot;俩字就是安全的,招商银行的客户经理,曾经给客户推荐理财产品,该客户最后亏了几十万.        -&gt;银行的理财产品一般都会有各种包装,它的本质可能是保险产品,可能是基金,你买的时候一定要看清楚再决定要不要投资.</code></pre></li><li><p>买基金与买口红一样简单</p>  <pre><code class="hljs plaintext">a.基金相关概念    1.基金,就是基金公司收集投资者的钱,按照证监会规定的规则,进行各种各样的投资的一种投资品.    2.根据投资理念的不同,基金可以分为主动型基金和被动型基金.    3.定投,就是在固定的日期,投入固定的钱.比如每月1号发工资,你可以从工资里转出1000元,投入到你选好的指数基金里面,美誉重复这个动作.    4.指数基金,就是基金经理不主动寻求超越市场的表现,复制别人的整个投资,不需要你自己花太多精力来做选择.    5.在投资中,我们是无法精确找出一只指数基金,价格最低,以后涨幅最高,但是却能通过策略,找到相对低价的好基金.    6.虽然从理论上廛,长期投资指数基金都能赚到,但是有策略的收益会高出2倍,甚至更高.b.主动型基金的缺点    1.过于依赖基金经理        -&gt;基金经理和他的团队拿我们投资者的钱,买什么股票或债券,什么时候买,买多少,都是由基金经理和他的团队说了算.        -&gt;如果眼光好,在上千只股票基金中选择了一个牛逼基金经理,那他能帮你跑赢市场,获得超额收益,但从历史数据看,能够长期跑赢市场的基金经理是很少的.    2.交易成本偏高        -&gt;各家公司主动型基金的申购费,赎回费,管理费都不便宜.这这偏贵的手续费最终会拉低你实际的收益.c.定投指数基金的好处    1.投资门槛很低        -&gt;每月拿出100块,比一次性拿出2万简单得多.    2.操作非常简单        -&gt;每月固定时间投资一笔钱到选中的基金,不需要花很长的时间分析公司.    3.摊薄投资成本        -&gt;指数基金的价格是波动的,你不能确定这次买是不是最便宜的,分开每月买一次就平均了.    4.强制储蓄资金        -&gt;每月把钱转到基金账户,还不会脑子一发热就把钱花掉了.</code></pre></li><li><p>每年白捡几百块,你要不要?</p>  <pre><code class="hljs plaintext">a.国债逆回购相关概念    1.国债逆回购就是金额机构(杨白劳)把国债(喜儿)抵押给你(黄世仁),找你借钱.        -&gt;投资版&lt;&lt;白毛女&gt;&gt;:杨白劳把喜儿抵押给黄世仁,找黄世仁借方便面.    2.国债是中央政府的借据,因为有国家背书,安全性很高.企业,银行以及各类大机构,都会购买一定比例的国债,作为比较保守的投资.b.国债逆回购会赔吗    1.企业以及机构在经营过程中,有时会缺少流动资金,就会把国债抵押用来周转资金.    2.企业以国债为抵押特借钱,我们借钱给他们,就算到期还不上钱,手里也有国债.所以,把国债逆回购说成是稳赚不赔,一点也不过分.c.国债逆回购怎么操作    1.第一步,开通账户        -&gt;首先得有个股票账户,股票账户不仅可以买卖股票,还可以买债券,基金,国债逆回购等投资品.        -&gt;开户很简单,身份证,银行卡和手机,按照网上的开户流程,10分钟就搞定了.        -&gt;好的证券公司,总结为9个字:服务好,网点多,佣金低.        -&gt;下载开户券商APP一定去官方网站,小心木马中毒,毕竟投资是涉及真金白银的.    2.第二步,跨过门槛        -&gt;上海证券交易所(上交所)的门槛高一些,如果要进行国债逆回购,至少要10w的流动资金.        -&gt;深圳证券交易所(深交所)低个档次,1000元就可以参与了.刚开始我们可以选择门槛低的深交所交易.        -&gt;国债逆回购有1天,7天,14天,甚至是182天的,具体的天数可以查看相关代码.    3.第三步,卖出份额        -&gt;首先,登录软件,查找131810,也就是1天期的国债逆回购,进入对应页面,点击&quot;卖出&quot;按钮.相当于把自己的钱以一个合理的价格&quot;卖&quot;出去.        -&gt;然后,确定下单.如果要确保成交,卖出的价格要跟&quot;买一&quot;的价格一样,这个&quot;买一&quot;的价格就是你下单的利率.        -&gt;数字越高,你得到的利息越高.不过这个利息是没办法无限高的.一般周四,月末,季度末,年末,市场资金面紧张时,利息通常会变得很高.        -&gt;最后,申请了之后,可以再点击一下委托,看是不是真的申购成功了,标注为&quot;已成&quot;,就代表申购成功.反之撤销重新再操作一次.        -&gt;另外,国债逆回购到期后,资金就会自动流到我们的账户里,不用再像股票基金一样,买入后还要手动卖出,真的是超级省心.</code></pre></li><li><p>理财,是一辈子的修行</p>  <pre><code class="hljs plaintext">a.理财不是一夜暴富    1.理财第一步:树立正确的投资理念        -&gt;说大一点,学习理财投资是一辈子的事.    2.理财第二步:选择正确的方法        -&gt;影响我们最终财富的因素有3个:本金,收益率,投资时间.        -&gt;提高本金,可以通过提高主动收入(工资).        -&gt;得高收益率,可以学习基金,股票,保险等具体投资品的投资方法和策略,这样才有可能在管理风险的前提下获得稳定的收益.b.构建初级体系    系统的学习初级知识,然后在这个基础上,选择自己感兴趣的,适合自己的投资方向,构建属于自己的能力圈.</code></pre></li></ul><h3 id="晨读美文"><a href="#晨读美文" class="headerlink" title="晨读美文"></a>晨读美文</h3><h3 id="晚间分享"><a href="#晚间分享" class="headerlink" title="晚间分享"></a>晚间分享</h3><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
          <category> 投资理财 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 投资理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常见面试题</title>
      <link href="/2019/08/18/dl-java-interview.html"/>
      <url>/2019/08/18/dl-java-interview.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java常见面试题"><a href="#Java常见面试题" class="headerlink" title="Java常见面试题"></a>Java常见面试题</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>记录自己面试时遇到的一些面试题。</p><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><h3 id="家娃基础专题"><a href="#家娃基础专题" class="headerlink" title="家娃基础专题"></a>家娃基础专题</h3><ul><li><p>对Java平台的理解</p>  <pre><code class="hljs plaintext">Java是一种面向对象的编程语言，最显著的特性有两个方面    一个是“书写一次，到处运行”（Write once, run anywhere），能够非常容易地获得跨平台能力；    另一个是垃圾收集（GC, Garbage Collection），Java 通过垃圾收集器（Garbage Collector）回收内存，大部分情况下，程序员不需要自己操心内存的分配和回收。对于“Java是解释执行”这句话，这个说法不太准确    我们开发的Java 的源代码，首先通过Javac编译成为字节码，然后在运行时，JVM 会通过类加载器（Class-Loader）加载字节码，并通过内嵌的解释器将其转换成为最终的机器码。    但是常见的JVM，比如我们大多数情况使用的 Oracle JDK 提供的 Hotspot JVM，都提供了JIT（Just-In-Time）编译器，也就是通常所说的动态编译器，    它能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于编译执行，而不是解释执行了。 在JDK 8 实际是解释和编译混合的一种模式，即所谓的混合模式（-Xmixed）    Oracle Hotspot JVM 内置了两个不同的 JIT compiler，C1对应前面说的client模式，适用于对于启动速度敏感的应用，比如普通 Java 桌面应用；    C2对应server模式，它的优化是为长时间运行的服务器端应用设计的。默认是采用所谓的分层编译（TieredCompilation）。</code></pre></li><li><p>Exception、Error的区别</p>  <pre><code class="hljs plaintext">Exception和Error都继承自Throwable类    只有Throwable类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。    Exception和Error体现了Java平台设计者对不同异常情况的分类。Error是指在正常情况下，不大可能出现的情况，绝大部分的Error都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。    既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError、StackOverflowError等都是Error的子类。Exception是程序正常运行中，可以预料的意外情况，对于这类异常，应该尽可能处理异常，使程序恢复，分为检查型（checked）异常和非检查型（unchecked）异常。    检查型异常：在源代码里必须显式地进行捕获处理，否则编译不通过;非RuntimeException都是此类异常.        IOException、SQLException、ClassNotFoundException等    非检查型异常：在源代码里可以不处理(可以修改代码更严谨),也可以处理;RuntimeException及其子类都是此类异常,Error类也可归为此类.        NullPointerException、IndexOutOfBoundsException、ClassCastException、IllegalArgumentException等</code></pre></li><li><p>ClassNotFoundException与NoClassDefFoundError区别</p>  <pre><code class="hljs plaintext">前者的根本原因是.class文件找不到,例如少引了某个jar。    解决方法是通常需要检查一下classpath下能不能找到包含缺失.class文件的jar。后者是类加载器试图加载类的定义，但是找不到这个类的定义，而实际上这个.class文件是存在的。    解决方法是需要检查这个类定义中的初始化部分（如类属性定义、static 块等）的代码是否有抛异常的可能，如果是 static 块，可以考虑在其中    将异常捕获并打印堆栈等，或者直接在对类进行初始化调用（如 new Foobar()）时作 try  catch。</code></pre></li><li><p>异常处理原则</p>  <pre><code class="hljs plaintext">尽量不要捕获通用异常,而应该捕获特定异常    这样能让自己的代码能够直观地体现出尽量多的信息,方便快速定位问题。不要生吞异常,即捕获后不要什么都不做    这样程序可能在后续代码以不可控的方式结束,没人能够轻易判断究竟是哪里抛出了异常，以及是什么原因产生了异常。只捕获有必要的代码段,尽量不要一个大的try包住整段的代码    try-catch代码段会产生额外的性能开销，它往往会影响JVM对代码进行优化。不要使用异常处理块控制代码流程    Java每实例化一个Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。</code></pre></li><li><p>throw、throws的区别</p>  <pre><code class="hljs plaintext">throw：    在方法体中,后面跟的是异常对象,并且只能是一个    throw抛出的是一个异常对象,说明这里肯定有一个异常产生了throws：    在方法声明上,后面跟的是异常的类名,可以是多个    throws是声明方法有异常,是一种可能性,这个异常并不一定会产生</code></pre></li><li><p>final、finally、finalize的区别</p>  <pre><code class="hljs plaintext">final：最终的意思,可以修饰类,变量,方法    修饰类,该类不能被继承;修饰变量,该变量常量,不能被重新赋值;修饰方法,该方法不能被重写finally：是异常处理的一种机制,用来保护重点代码一定要被执行,例如关闭资源,释放锁等     一般来说,代码肯定会执行,特殊情况,例如在执行finally之前jvm退出了finalize：是Object类的一个方法,会在垃圾回收对象前调用,来释放资源,每个对象的finalize方法只会被GC调用一次    GC根据GCroot算法进行来分析对象的可达性来判断对象是否存活,如果不可达被判定为垃圾对象后,会先判断该对象是否覆盖finalize方法,    如果没有覆盖说明对象不需要经过特殊处理,可以直接回收,否则会将该对象放入一个F-Queue队列中,会被一个低优先级的线程调用,再次进行    可达性分析,来判断是否复活还是回收.不建议使用,容易引起挂起和死锁.</code></pre></li><li><p>string、sringbuffer、stringbuilder的区别</p>  <pre><code class="hljs plaintext">String：长度和内容不可变的,内部被final修饰,缓存于字符串常量池中,底层结构是char[]    String对象是否真的不可变?可通过反射进行改变        String s = &quot;Hello World&quot;; //创建字符串&quot;Hello World&quot;,并赋给引用变量s        System.out.println(&quot;s=&quot; + s);        Field valueFieldOfString = String.class.getDeclaredField(&quot;value&quot;); //获取String类的value字段        valueFieldOfString.setAccessible(true); //改变value属性的访问权限        char[] value = (char[]) valueFieldOfString.get(s); //获取s对象上的value属性值        value[5] = &#x27;_&#x27;; //改变value所应用的数组中的第5个字符        System.out.println(&quot;s=&quot; + s);StringBuffer、StringBuilder：长度和内容可变的,内部被final修饰,继承自AbstractStringBuilder,默认大小是16,可指定,底层结构是char[]    append操作：会先判断char[]的总长度是否能容纳新添加的字符串,不够的话会进行扩容,默认扩容至是&quot;value.length * 2 + 2&quot;,如果该大小    小于最终需要的长度,则将后者设为需要扩容的长度,调用System.arraycopy方法来实现数组拷贝应用场景：    String：适用于内容不经常发生改变的场景,例如常量声明,少量的字符串拼接操作等    StringBuffer：适用于频繁进行字符串的运算(拼接,替换,删除等),并且运行多线程环境下,例如XML解析,HTTP参数解析与封装等        线程安全,效率低,采用synchronized    StringBuilder：适用于频繁进行字符串的运算(拼接,替换,删除等),并且运行单线程环境下,例如SQL语句拼装,JSON封装等        线程不安全,效率高</code></pre></li><li><p>HashMap的原理实现</p>  <pre><code class="hljs plaintext">底层数据结构为哈希表/散列表,是一个元素为链表的数组,链表中的Node包括hash,key,value,nexthashmap是非线程安全的,因为put的时候有个扩容操作,会有一个复制数组的操作,有可能会操作旧的数组jdk8对hashmap加入了红黑树,在链表的长度&gt;8的时候会进行一个红黑树的转换hashtable是线程安全的,get与put操作都是用synchronized实现的,会锁住整个表.ConcurrentHashMap是线程安全的    jdk1.7采用ReentrantLock锁住每个segment;    jdk1.8采用CAS+Synchronized只针对put上锁,如果key对应的元素不存在,则通过CAS进行操作,否则使用synchronized进行操作;get不上锁,因为Node的成员val是用volatile修饰.    这也是它比其他并发集合比如hashtable、用Collections.synchronizedMap()包装的hashmap安全效率高的原因之一。</code></pre></li><li><p>synchronized和ReentrantLock区别</p>  <pre><code class="hljs plaintext">可重入性：    都是可重入锁/递归锁,指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响。锁的实现：    Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，前者的实现是比较难见到的，后者有直接的源码可供阅读。性能区别：    在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，    两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的    CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。功能区别：    很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放    锁造成死锁，所以最好在finally中声明释放锁。ReenTrantLock独有的能力：    1.ReenTrantLock可以通过带布尔值的构造函数指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。        公平锁是指多个线程在等待同一个锁时，必须按照申请的时间顺序来依次获得锁；而非公平锁则不能保证这一点。非公平锁在锁被释放时，任何一个等待锁的线程都有机会获得锁。    2.ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。    3.ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。什么情况下使用ReenTrantLock：如果你需要实现ReenTrantLock的三个独有功能时。</code></pre>  <pre><code class="hljs plaintext">自旋锁：    如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），    等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。    但是线程自旋是需要消耗cpu的，说白了就是让cpu在做无用功，线程不能一直占用cpu自旋做无用功，所以需要设定一个自旋等待的最大时间。</code></pre></li><li><p>equals和&#x3D;&#x3D;的区别</p>  <pre><code class="hljs plaintext">==：是一个比较运算符,基本类型比较的是值,引用类型比较的是地址值(是否为同一个对象的引用).equals：是Object类的一个方法,只能比较引用类型,重写前比较的是地址值,重写后一般是比较对象的属性.</code></pre></li></ul><h3 id="并发编程专题"><a href="#并发编程专题" class="headerlink" title="并发编程专题"></a>并发编程专题</h3><ul><li>线程池相关  <pre><code class="hljs plaintext">线程池作用：    Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处。    第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。    第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。    第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。Executor框架的基本组成：    Executor框架的最顶层实现是ThreadPoolExecutor类,Executors工厂类中提供的newFixedThreadPool等方法其实也只是ThreadPoolExecutor的构造函数参数不同而已。        ThreadPoolExecutor             extends AbstractExecutorService                 implements ExecutorService                    extends Executor    ThreadPoolExecutor参数：        corePoolSize：核心池的大小        maximumPoolSize：最大线程数        keepAliveTime：当线程数大于核心时,多余的空闲线程等待新任务的最长时间        unit：keepAliveTime的时间单位        workQueue：用来储存等待执行任务的队列        threadFactory：线程工厂        RejectedExecutionHandler：饱和/拒绝策略线程池四种创建方式：    Java通过Executors（jdk1.5并发包）提供四种线程池，分别为：    newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。        线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。    newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。        定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()    newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。    newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。线程池大小选择策略：    具体根据实际情况具体分析,可通过压测实验    CPU密集型：cpu核心数 + 1    IO密集型：cpu核心数 * (1 + 平均等待时间/平均工作时间)</code></pre></li><li>常见并发类  <pre><code class="hljs plaintext">CountDownLatch：计数器    CountDownLatch可以实现类似计数器的功能，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。    比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。    常用方法：        countDown：计数器-1        await：減去为0,恢复任务继续执行Semaphore：计数信号量    Semaphore是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，完成任务后归还，超过阈值后，线程申请许可信号将会被阻塞。    Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。    常用方法：        availablePermits：获取当前可用的资源数量        acquire：申请许可        release：释放许可</code></pre>  <pre><code class="hljs plaintext">并发队列Queue：    ConcurrentLinkedQueuｅ：基于链表的高性能非阻塞队列        通过无锁的方式，实现了高并发状态下的高性能，通常ConcurrentLinkedQueue性能好于BlockingQueue.它是一个基于链接节点的无界线程安全队列。该队列的元素遵循先进先出的原则。        常用方法：            add 和offer() 都是加入元素的方法(在ConcurrentLinkedQueue中这俩个方法没有任何区别)            poll() 和peek() 都是取头元素节点，区别在于前者会删除元素，后者不会。    BlockingQueue：阻塞队列        ArrayBlockingQueue：基于数组的并发阻塞队列            ArrayBlockingQueue是一个有边界的阻塞队列，它的内部实现是一个数组。有边界的意思是它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。            ArrayBlockingQueue是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。        LinkedBlockingQueue：基于链表的FIFO阻塞队列            LinkedBlockingQueue阻塞队列大小的配置是可选的，如果我们初始化时指定一个大小，它就是有边界的，如果不指定，它就是无边界的。说是无边界，其实是采用了默认大小为Integer.MAX_VALUE的容量。            它的内部实现是一个链表。和ArrayBlockingQueue一样，LinkedBlockingQueue 也是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。        PriorityBlockingQueue：带优先级的无界阻塞队列            PriorityBlockingQueue是一个没有边界的队列，它的排序规则和 java.util.PriorityQueue一样。        SynchronousQueue：并发同步阻塞队列            SynchronousQueue队列内部仅允许容纳一个元素。当一个线程插入一个元素后会被阻塞，除非这个元素被另一个线程消费。</code></pre></li><li>线程间通信  <pre><code class="hljs plaintext">多个线程处理同一资源(共享数据),但是任务(处理方式)却不同.等待唤醒机制    Object类提供了3个方法：        wait(): 让线程处于等待状态，被wait的线程会被存储到线程池中。        notify(): 唤醒线程池中一个线程(任意)。如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。        notifyAll(): 唤醒线程池中的所有线程。如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行。    以上方法为什么定义在Object类中?        这些方法的调用必需通过锁对象调用,而锁对象有可能是任意对象,所以这些方法必须定义在Object类中.</code></pre></li></ul><h3 id="性能调优专题"><a href="#性能调优专题" class="headerlink" title="性能调优专题"></a>性能调优专题</h3><ul><li>零拷贝  <pre><code class="hljs plaintext">概念：    零拷贝技术是指计算机执行操作时,CPU不需要先将数据从某处内存复制到另一个特定区域.这种技术通常用于通过网络传输文件节省CPU周期和网络带宽.场景：    kafaka,netty,rocketmq,nginx,apache中都用到了零拷贝。好处：    Linux IO流程：先通过DMA拷贝将磁盘数据读入内核空间缓冲区,然后通过CPU拷贝从内核向用户进程空间缓冲区复制数据.    减少传输数据在存储器之间不必要的中间拷贝次数,从而有效提高数据传输效率    减少了用户进程空间和内核空间之间因为上下文切换而带来的开销实现：    1.java NIO - MappedByteBuffer,适合比较大的文件        FileChannel fileChannel = new RandomAcessFile(new File(&quot;data.zip&quot;),&quot;rw&quot;).getChannel();        MappedByteBuffer buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY,0,fileChannel.size());    2.java NIO - FileChannel.transferTo,直接将当前通道内容传输到另一个通道,没有涉及到Buffer的任务操作,底层通过系统调用sendfile()        FileChannel fileChannel = new RandomAcessFile(new File(&quot;data.zip&quot;),&quot;rw&quot;).getChannel();        SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(&quot;&quot;,1234));        fileChannel.transferTo(0,fileChannel.size(),socketChannel);</code></pre></li></ul><h3 id="数据结构与算法专题"><a href="#数据结构与算法专题" class="headerlink" title="数据结构与算法专题"></a>数据结构与算法专题</h3><ul><li>B树(B-树)与B+树的区别  <pre><code class="hljs plaintext">B树与B+树的出现是为了减少磁盘IO的次数,基本思想就是    降低树的深度,每个节点存储多个元素    摒弃二叉树结构,采用多叉树B树：也叫平衡多路查找树    每个节点都存储key和data,所有节点组成这颗树,并且叶子节点指针为null.B+树：    只有叶子节点存储data,叶子节点包含了这棵树的所有键值,叶子节点不存储指针.        这意味着相同大小的磁盘页每个节点可以存储更多元素,使得查询的IO次数更少.    每个叶子节点增加了顺序访问指针(一个指向相邻叶子节点的指针).        使得所有节点形成有序链表,便于范围查询,这样一棵树成了数据库系统实现索引的首选数据结构。</code></pre></li></ul><h3 id="设计模式专题"><a href="#设计模式专题" class="headerlink" title="设计模式专题"></a>设计模式专题</h3><ul><li>如何高效实现单例设计模式  <pre><code class="hljs plaintext">核心思想：    保证系统中一个类仅有一个实例,并且提供一个访问该实例的全局访问方法常见应用场景：    windows任务管理器,数据库连接池,java中的runtime,spring中bean的默认生命周期优点：    避免对象的频繁创建和销毁,提高性能实现：    饿汉式：        优点是访问性能高,线程安全;缺点是加载时就初始化,可能会造成资源浪费.    懒汉式：        优点是访问性能高,延迟初始化,提高了资源利用率;缺点是非线程安全    懒汉式 + synchronized：        优点是线程安全,延迟初始化,提高了资源利用率;缺点是getInstance()访问需要同步,并发访问性能低.    懒汉式 + double check + volatile：        优点是线程安全,延迟初始化,提高了资源利用率,getInstance()访问性能高.        public static Singleton getInstance()&#123;            if(instance == null)&#123;                synchronized(Singleton.class)&#123;                    if(instance == null)&#123;                        instance = new Singleton();                    &#125;                &#125;            &#125;            return instance;        &#125;    内部内Holder：        优点是线程安全,延迟初始化,提高了资源利用率,getInstance()访问性能高.        public final class Singleton&#123;            private Singleton()&#123;&#125;            private static class Holder&#123;                private static Singleton INSTANCE = new Singleton();            &#125;            public static Singleton getInstance()&#123;                return Holder.INSTANCE;            &#125;        &#125;    枚举(Enum)：        优点是线程安全,getInstance()访问性能高;缺点是不能延迟初始化        防止通过反射调用私有构造器来创建多个实例;提供了自动序列化机制,防止反序列化的时候创建新的对象.        public enum Singleon&#123;            INSTANCE;            void otherMethod()&#123;...&#125;        &#125;</code></pre></li></ul><h3 id="互联网工具专题"><a href="#互联网工具专题" class="headerlink" title="互联网工具专题"></a>互联网工具专题</h3><h3 id="源码框架专题"><a href="#源码框架专题" class="headerlink" title="源码框架专题"></a>源码框架专题</h3><h3 id="分布式框架专题"><a href="#分布式框架专题" class="headerlink" title="分布式框架专题"></a>分布式框架专题</h3><ul><li>分布式事务解决方案  <pre><code class="hljs plaintext">本地事务：分布式事务：    单JVM跨库事务：        XA/JTA两阶段提交方案：            开源框架实现有atomikos,外加补偿机制.在CAP理论当中强调的是一致性,由于可用性较低,实际应用的并不多.    多JVM微服务：        CAP理论：            开发大规模分布式系统会遇到一致性,可用性,分区容错性3个特性,而一个分布式系统最多只能满足其中的2项.而分区容错性是分布式系统            必然要面对和解决的问题,因此我们要根据业务特点在一致性和可用性之间寻求平衡.            分区容错性：在任意分区网络故障的情况下系统仍能继续运行        BASE理论：            基本可用：指分布式系统在出现不可预知故障的时候,允许损失部分可用性.            软状态：允许系统中的数据存在中间状态,即允许数据同步的过程中存在延时.            最终一致：本质是需要系统保证最终数据能够达到一致,而不需要实时保证系统数据的强一致性.        柔性事务：            最大努力通知方案：             TCC两阶段补偿性方案：                try：完成所有业务检查(一致性),预留业务资源(准隔离性)                confrim：确认执行业务操作,不做任务业务检查,只使用try阶段预留的业务资源                cancel：取消try阶段预留的业务资源                开源框架实现：atomikos商业版,tcc-transaction,spring-cloud-rest-tcc,支付宝tcc(XTS)                    分布式事务框架主要是帮我们解决了第二阶段的自动化;充当了一个协调器,根据预留操作的返回结果来自动化调用提交/取消操作.            可靠消息最终一致性方案：                基于RocketMQ：存在中间状态                基于普通消息队列：不存在中间状态,自己单独写个服务来实现中间状态    TCC与XA对比：        XA是资源(数据库)层面的分布式事务,强一致性,在两阶段提交的整个过程中,一直会持有资源的锁.        TCC是业务层面的分布式事务,最终一致性,不会一直持有资源的锁.针对整个系统提升了性能.</code></pre></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系列之 Redis&amp;Ehcache</title>
      <link href="/2019/04/13/af-redis.html"/>
      <url>/2019/04/13/af-redis.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式系列之-Redis-Ehcache"><a href="#分布式系列之-Redis-Ehcache" class="headerlink" title="分布式系列之 Redis&amp;Ehcache"></a>分布式系列之 Redis&amp;Ehcache</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#Ehcache">Ehcache</a></li><li><a href="#Redis">Redis</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>缓存的分类  <pre><code class="hljs plaintext">客户端缓存    浏览器页面缓存    App客户端缓存网络缓存    CDN内容分发缓存    Nginx代理缓存服务器缓存    数据库缓存    平台缓存</code></pre></li><li>为什么使用缓存  <pre><code class="hljs plaintext">减轻服务器端压力，减少网络传输请求</code></pre></li><li>缓存框架的分类  <pre><code class="hljs plaintext">单体式缓存框架/内置缓存框架/JVM缓存框架(只能针对于单个JVM中,缓存容器存放在JVM中,每个JVM互不影响)    Ehcache、Oscahche、Guava Caache    可自己基于Map集合来实现JVM缓存框架分布式缓存框架(共享缓存数据)    Redis、MemCache</code></pre></li></ul><h2 id="Ehcache"><a href="#Ehcache" class="headerlink" title="Ehcache"></a>Ehcache</h2><h3 id="什么是Ehcache"><a href="#什么是Ehcache" class="headerlink" title="什么是Ehcache"></a><code>什么是Ehcache</code></h3><pre><code class="hljs plaintext">Ehcache是纯java的开源缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。它主要面向通用缓存、Java EE和轻量级容器，具有内存和磁盘存储、缓存加载器、缓存扩展、缓存异常处理程序。 Ehcache最初由Greg Luck于2003年开始开发。2009年,该项目被Terracotta购买。软件仍然开源,但一些新的主要功能(例如，快速可重启性之间的一致性的)只能在商业产品中使用。Ehcache 被广泛用于在Hibernate、Spring、Cocoon等其他开源系统。</code></pre><h3 id="Ehcache的主要特性"><a href="#Ehcache的主要特性" class="headerlink" title="Ehcache的主要特性"></a><code>Ehcache的主要特性</code></h3><pre><code class="hljs plaintext">1.快速；2.简单；3.多种缓存策略；4.缓存数据有两级：内存和磁盘，因此无需担心容量问题；5.缓存数据会在虚拟机重启的过程中写入磁盘；6.可以通过 RMI、可插入 API 等方式进行分布式集群缓存；7.具有缓存和缓存管理器的侦听接口；8.支持多缓存管理器实例，以及一个实例的多个缓存区域；9.提供 Hibernate 的缓存实现；</code></pre><h3 id="Ehcache使用介绍"><a href="#Ehcache使用介绍" class="headerlink" title="Ehcache使用介绍"></a><code>Ehcache使用介绍</code></h3><pre><code class="hljs plaintext">Ehcache是用来管理缓存的一个工具，其缓存的数据可以是存放在内存里面的，也可以是存放在硬盘上的。其核心是CacheManager，一切Ehcache的应用都是从CacheManager开始的。它是用来管理Cache（缓存）的，一个应用可以有多个CacheManager，而一个CacheManager下又可以有多个Cache。Cache内部保存的是一个个的Element，而一个Element中保存的是一个key和value的配对，相当于Map里面的一个Entry。</code></pre><h3 id="Ehcache缓存过期策略"><a href="#Ehcache缓存过期策略" class="headerlink" title="Ehcache缓存过期策略"></a><code>Ehcache缓存过期策略</code></h3><pre><code class="hljs plaintext">当缓存需要被清理时（比如空间占用已经接近临界值了），需要使用某种淘汰算法来决定清理掉哪些数据。常用的淘汰算法有下面几种：    FIFO：First In First Out，先进先出。判断被存储的时间，离目前最远的数据优先被淘汰。    LRU：Least Recently Used，最近最少使用。判断最近被使用的时间，目前最远的数据优先被淘汰。    LFU：Least Frequently Used，最不经常使用。在一段时间内，数据被使用次数最少的，优先被淘汰。</code></pre><h3 id="springboot整合ehcache"><a href="#springboot整合ehcache" class="headerlink" title="springboot整合ehcache"></a><code>springboot整合ehcache</code></h3><ol><li>添加maven依赖 <pre><code class="hljs plaintext">&lt;!--开启 cache 缓存 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- ehcache缓存 --&gt;&lt;dependency&gt;    &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;    &lt;version&gt;2.9.1&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li>添加Ehcache配置文件app1_ehcache.xml <pre><code class="hljs plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;&gt;&lt;diskStore path=&quot;java.io.tmpdir/ehcache-rmi-4000&quot; /&gt;&lt;!-- 默认缓存 --&gt;&lt;defaultCache maxElementsInMemory=&quot;1000&quot; eternal=&quot;true&quot;timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; overflowToDisk=&quot;true&quot;diskSpoolBufferSizeMB=&quot;30&quot; maxElementsOnDisk=&quot;10000000&quot;diskPersistent=&quot;true&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot;memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;&lt;/defaultCache&gt;&lt;!-- 自定义缓存 --&gt;&lt;cache name=&quot;userCache&quot; maxElementsInMemory=&quot;1000&quot; eternal=&quot;false&quot;timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; overflowToDisk=&quot;true&quot;diskSpoolBufferSizeMB=&quot;30&quot; maxElementsOnDisk=&quot;10000000&quot;diskPersistent=&quot;false&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot;memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;&lt;cacheEventListenerFactory class=&quot;net.sf.ehcache.distribution.RMICacheReplicatorFactory&quot; /&gt;&lt;!-- 用于在初始化缓存，以及自动设置 --&gt;&lt;bootstrapCacheLoaderFactory class=&quot;net.sf.ehcache.distribution.RMIBootstrapCacheLoaderFactory&quot; /&gt;&lt;/cache&gt;&lt;/ehcache&gt;</code></pre> <pre><code class="hljs plaintext">参数相关配置    1、diskStore ：        指定数据(.data and .index)存储位置，可指定磁盘中的文件夹位置    2、defaultCache ： 默认的管理策略        一、以下属性是必须的：        　　1、name： Cache的名称，必须是唯一的(ehcache会把这个cache放到HashMap里)。        　　2、maxElementsInMemory：在内存中缓存的element的最大数目。         　　3、maxElementsOnDisk：在磁盘上缓存的element的最大数目，默认值为0，表示不限制。         　　4、eternal：设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断。         　　5、overflowToDisk： 如果内存中数据超过内存限制，是否要缓存到磁盘上。         二、以下属性是可选的：        　　1、timeToIdleSeconds： 对象空闲时间，指对象在多长时间没有被访问就会失效。只对eternal为false的有效。默认值0，表示一直可以访问。        　　2、timeToLiveSeconds： 对象存活时间，指对象从创建到失效所需要的时间。只对eternal为false的有效。默认值0，表示一直可以访问。        　　3、diskPersistent： 是否在磁盘上持久化。指重启jvm后，数据是否有效。默认为false。         　　4、diskExpiryThreadIntervalSeconds： 对象检测线程运行时间间隔。标识对象状态的线程多长时间运行一次。        　　5、diskSpoolBufferSizeMB： DiskStore使用的磁盘大小，默认值30MB。每个cache使用各自的DiskStore。        　　6、memoryStoreEvictionPolicy： 如果内存中数据超过内存限制，向磁盘缓存时的策略。默认值LRU，可选FIFO、LFU。</code></pre></li><li>配置yml <pre><code class="hljs plaintext">### 读取缓存配置cache:    type: ehcache    ehcache:        config: classpath:app1_ehcache.xml</code></pre></li><li>项目使用 <pre><code class="hljs plaintext">@CacheConfig(cacheNames = &quot;userCache&quot;)public interface UserMapper &#123;@Select(&quot;SELECT ID ,NAME,AGE FROM users where id=#&#123;id&#125;&quot;)@CacheableList&lt;Users&gt; getUser(@Param(&quot;id&quot;) Long id);&#125;</code></pre> <pre><code class="hljs plaintext">@Cacheable  加了该注解的方法表示可以缓存@CacheConfig 表示创建缓存配置，Key为userCache</code></pre></li><li>启动 <pre><code class="hljs plaintext">//开启ehcache缓存模式@EnableCaching@MapperScan(basePackages = &#123; &quot;top.lvzhiqiang.mapper&quot; &#125;)@SpringBootApplicationpublic class App &#123;public static void main(String[] args) &#123;SpringApplication.run(App.class, args);&#125;&#125;</code></pre></li><li>清除缓存 <pre><code class="hljs plaintext">@Autowiredprivate CacheManager cacheManager;@RequestMapping(&quot;/remoKey&quot;)public void remoKey() &#123;    cacheManager.getCache(&quot;userCache&quot;).clear();&#125;</code></pre></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><code>总结</code></h3><p><img src="/2019/04/13/af-redis/af-redis-001.png" alt="抱歉,图片休息了"><br><img src="/2019/04/13/af-redis/af-redis-002.png" alt="抱歉,图片休息了"> </p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a><code>什么是Redis</code></h3><pre><code class="hljs plaintext">Redis是由意大利人Salvatore Sanfilippo（网名：antirez）开发的一款开源、高性能的的非关系型内存数据库,并以key-value方式进行存储。Redis全称为：Remote Dictionary Server（远程数据服务），该软件使用C语言编写，官方提供的数据是可以达到100000+的qps。它支持数据的持久化来保证数据高可用、支持丰富的数据类型进行存储。并采用单线程模式来保证线程安全问题。-----------------------集群方式：    Redis主从复制+哨兵机制    Redis3.0分片集群</code></pre><h3 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a><code>Redis的应用场景</code></h3><ul><li>会话session的一致性管理</li><li>短信验证码,保证有效期</li><li>缓存热点数据(经常被查询又不经常被修改)</li><li>基于redis实现分布式锁</li><li>网站计数器(由于单线程,高并发场景下,保证全局count唯一</li><li>实现消息中间件的发布订阅功能(不推荐)</li></ul><h3 id="Redis支持的数据类型"><a href="#Redis支持的数据类型" class="headerlink" title="Redis支持的数据类型"></a><code>Redis支持的数据类型</code></h3><pre><code class="hljs plaintext">相关命令    ping：测试连接是否可以成功    quit：退出连接    dbsize：返回key的数量    info：输出redis信息    type key：返回数据类型    rename oldkey newkey：重命名    randomkey：随机返回一个key    select 0-15：选择数据库    move key 0-15：把key 移动到其他库    del key：删除某个key    key *：匹配显示所有key,支持正则    exists key：查看key是否存在</code></pre><ul><li>String（字符串）  <pre><code class="hljs plaintext">set key valueget key</code></pre></li><li>Hash（字典）  <pre><code class="hljs plaintext">hmset key  key1 value1 key2 value2hgetall keyhget key key1</code></pre></li><li>List（列表）  <pre><code class="hljs plaintext">lpush/rpush key valuelrange key</code></pre></li><li>Set（集合）  <pre><code class="hljs plaintext">sadd key valuesmembers key</code></pre></li><li>Sorted Set（有序集合）  <pre><code class="hljs plaintext">zadd key valuezrange key</code></pre></li></ul><h3 id="springboot整合redis"><a href="#springboot整合redis" class="headerlink" title="springboot整合redis"></a><code>springboot整合redis</code></h3><ol><li>添加maven依赖 <pre><code class="hljs plaintext">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li>修改yml文件 <pre><code class="hljs plaintext">spring:    redis:        database: 0        host: 192.168.1.103        port: 6379        password: 123456        jedis:            pool:                max-active: 8                max-wait: -1                max-idle: 8                min-idle: 0        timeout: 10000</code></pre></li><li>代码 <pre><code class="hljs plaintext">@Servicepublic class RedisService &#123;@Autowiredprivate StringRedisTemplate stringRedisTemplate;public void set(String key, Object object, Long time) &#123;if (object instanceof String) &#123;// 存放String 类型setString(key, object);&#125;if (object instanceof Set) &#123;// 存放 set类型setSet(key, object);&#125;stringRedisTemplate.expire(key, time, TimeUnit.SECONDS);// 设置有效期 以秒为单位&#125;public void setString(String key, Object object) &#123;String value = (String) object;// 如果是String 类型stringRedisTemplate.opsForValue().set(key, value);&#125;public void setSet(String key, Object object) &#123;Set&lt;String&gt; value = (Set&lt;String&gt;) object;for (String oj : value) &#123;stringRedisTemplate.opsForSet().add(key, oj);&#125;&#125;public String getString(String key) &#123;return stringRedisTemplate.opsForValue().get(key);&#125;&#125;@RestControllerpublic class IndexControler &#123;@Autowiredprivate RedisService redisService;@RequestMapping(&quot;/setString&quot;)public String setString(String key, String value) &#123;redisService.set(key, value, 60l);return &quot;success&quot;;&#125;@RequestMapping(&quot;/getString&quot;)public String getString(String key) &#123;return redisService.getString(key);&#125;...&#125;</code></pre></li></ol><h3 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a><code>Redis发布订阅</code></h3><pre><code class="hljs plaintext">Redis发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。这点和设计模式中的观察者模式比较相似,pub/sub不仅仅解决发布者和订阅者直接代码级别耦合也解决两者在物理部署上的耦合。Redis客户端可以订阅任意数量的频道。----------------redis 127.0.0.1:6379&gt; SUBSCRIBE redisChatredis 127.0.0.1:6379&gt; UNSUBSCRIBE redisChatredis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;Redis is a great caching technique&quot;</code></pre><h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a><code>Redis事务</code></h3><pre><code class="hljs plaintext">redis对事务的支持目前还比较简单。redis只能保证一个client发起的事务中的命令可以连续的执行，而中间不会插入其他client的命令。由于redis是单线程来处理所有client的请求的所以做到这点是很容易的。一般情况下redis在接受到一个client发来的命令后会立即处理并返回处理结果，但是当一个client在一个连接中发出multi命令时，这个连接会进入一个事务上下文，该连接后续的命令并不是立即执行，而是先放到一个队列中。当从此连接受到exec命令后，redis会顺序的执行队列中的所有命令。并将所有命令的运行结果打包到一起返回给client.然后此连接就结束事务上下文。----------------redis集群对象JedisCluster不支持事务，但是，集群里边的每个节点支持事务----------------开启事物：multi回滚事物：discard提交事物：exec</code></pre><pre><code class="hljs plaintext">//SpringBoot操作Redis事务public void setString(String key, Object object) &#123;    stringRedisTemplate.setEnableTransactionSupport(true);    stringRedisTemplate.multi();// 开启事务    try &#123;        // 如果是String 类型        String value = (String) object;        stringRedisTemplate.opsForValue().set(key, value);    &#125; catch (Exception e) &#123;        stringRedisTemplate.discard();// 回滚事务    &#125; finally &#123;        stringRedisTemplate.exec();// 提交事务    &#125;&#125;</code></pre><h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a><code>Redis主从复制</code></h3><ul><li>概述  <pre><code class="hljs plaintext">1、将redis数据库分为主数据库（master）和从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。2、通过redis的主从复制功能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。3、redis非集群模式只允许有一个主服务器,允许有多个从服务器。</code></pre></li><li>图<br>  <img src="/2019/04/13/af-redis/af-redis-003.png" alt="抱歉,图片休息了"> </li><li>搭建  <pre><code class="hljs plaintext">0.关闭防火墙1.下载Redis程序包2.解压到指定目录并编译安装    # cd /usr/program/redis-3.2.9    # make    # cd src    # make install PREFIX=/usr/program/redis-3.2.93.配置环境变量,使用vim编辑/etc/profile.d/my.sh文件    REDIS_HOME=/usr/program/redis-3.2.9    PATH=$REDIS_HOME/bin:$PATH    export REDIS_HOME    export PATH4.配置redis为后台启动    # vim $&#123;REDIS_HOME&#125;/redis.conf //将daemonize no 改成daemonize yes    # vim $&#123;REDIS_HOME&#125;/redis.conf // requirepass 123456,指定密码    # vim $&#123;REDIS_HOME&#125;/redis.conf //将bind 127.0.0.1注释掉,开启外网访问5.开启redis    # redis-server $&#123;REDIS_HOME&#125;/redis.conf6.连接Redis客户端    # ./redis-cli -h 127.0.0.1 -p 6379 -a &quot;123456&quot;    PING 结果表示成功7.从服务器上修改redis.conf配置文件    # vim $&#123;REDIS_HOME&#125;/redis.conf //打开slaveof 192.168.33.130 6379,    # vim $&#123;REDIS_HOME&#125;/redis.conf //打开masterauth 123456,主redis服务器如果配置了密码,则需要配置</code></pre></li></ul><h3 id="Redis哨兵机制"><a href="#Redis哨兵机制" class="headerlink" title="Redis哨兵机制"></a><code>Redis哨兵机制</code></h3><ul><li>概述  <pre><code class="hljs plaintext">1.redis的哨兵(sentinel) 系统用于管理多个Redis服务器,该系统执行以下三个任务:    监控(Monitoring): 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。    提醒(Notification):当被监控的某个Redis出现问题时, 哨兵(sentinel) 可以通过API向管理员或者其他应用程序发送通知。    自动故障迁移(Automatic failover):当一个Master不能正常工作时，哨兵(sentinel)会开始一次自动故障迁移操作,它会将失效Master的        其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master;         当客户端试图连接失效的Master时,集群也会向客户端返回新Master的地址,使得集群可以使用Master代替失效Master。2.哨兵(sentinel) 的一些设计思路和zookeeper非常类似3.哨兵是独立的一个应用程序(进程)</code></pre></li><li>配置  <pre><code class="hljs plaintext">0.集群的所有服务器都要开启密码,即主服务器也要打开设置masterauth属性1.拷贝到etc目录    cp sentinel.conf  /usr/local/redis/etc2.修改sentinel.conf配置文件    sentinel monitor mymaster  192.168.110.133 6379 1  #主节点 名称 IP 端口号 选举次数    sentinel auth-pass mymaster 123456      sentinel down-after-milliseconds mymaster 30  #修改心跳检测,默认为30秒,此改为30毫秒    sentinel parallel-syncs mymaster 2  #做多多少合格节点,可不配置3.启动哨兵模式    ./redis-server /usr/local/redis/etc/sentinel.conf --sentinel &amp;4.停止哨兵模式    kill</code></pre></li></ul><h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a><code>Redis持久化</code></h3><ul><li>概念  <pre><code class="hljs plaintext">持久化就是把内存中的数据写到磁盘中去，防止服务宕机了内存数据丢失。Redis提供了两种持久化方式:RDB（默认开启）和AOF。</code></pre></li><li>RDB持久化<ul><li>RDB全称Redis DataBase,是以二进制文件形式在某个时间点将数据写入一个临时文件(会替换上次持久化的文件)，来达到数据恢复。</li><li>RDB功能核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数</li><li>更多请参考<a href="http://redisbook.readthedocs.io/en/latest/internal/rdb.html#id4">http://redisbook.readthedocs.io/en/latest/internal/rdb.html#id4</a>  <pre><code class="hljs plaintext">##持久化数据存储在本地的文件dbfilename dump.rdb##持久化数据存储在本地的路径，如果是在/redis/redis-3.0.6/src下启动的redis-cli，则数据会存储在当前src目录下dir ./##保存策略,即snapshot触发的时机###如下为900秒后，至少有一个变更操作，才会snapshot###可以通过“save “””来关闭snapshot功能  #以下分别表示更改了1个key时间隔900s进行持久化存储；300s内更改了10个key则发起快照保存；更改10000个key60s进行存储save 900 1save 300 10save 60 10000##当snapshot时出现错误无法继续时，是否阻塞客户端“变更操作”，“错误”可能因为磁盘已满/磁盘故障/OS级别异常等stop-writes-on-bgsave-error yes  ##是否启用rdb文件压缩，默认为“yes”，压缩往往意味着“额外的cpu消耗”，同时也意味这较小的文件尺寸以及较短的网络传输时间rdbcompression yes</code></pre></li></ul></li><li>AOF持久化<ul><li>AOF全称Append-only file,将“操作+数据”以格式化指令的方式追加到操作日志文件的尾部，“日志文件”保存了历史所有的操作过程</li><li>采用redis通讯协议(RESP)格式的命令文本进行存储  <pre><code class="hljs plaintext">##此选项为aof功能的开关，默认为“no”，可以通过“yes”来开启aof功能  appendonly yes##指定aof文件名称  appendfilename appendonly.aof##指定aof方式文件同步(保存)策略，有三个合法值：always everysec no,默认为everysec###always代表每执行一个命令保存一次,停机时最多只丢失一个命令的数据。###everysec代表每一秒钟保存一次 ,停机时一般情况下会丢失不超过2秒钟的数据,推荐。###no代表不保存,停机时会丢失操作系统最后一次对AOF文件触发SAVE操作之后的数据。appendfsync everysec  ##在aof-rewrite期间，appendfsync是否暂缓文件同步，&quot;no&quot;表示“不暂缓”，“yes”表示“暂缓”，默认为“no”no-appendfsync-on-rewrite no  ##aof文件rewrite触发的最小文件尺寸(mb,gb),只有大于此aof文件大于此尺寸是才会触发rewrite，默认“64mb”，建议“512mb”  auto-aof-rewrite-min-size 64mb  ##相对于“上一次”rewrite，本次rewrite触发时aof文件应该增长的百分比。  ###每一次rewrite之后，redis都会记录下此时“新aof”文件的大小(例如A)，那么当aof文件增长到A*(1 + p)之后  ###触发下一次rewrite，每一次aof记录的添加，都会检测当前aof文件的尺寸。  auto-aof-rewrite-percentage 100</code></pre></li></ul></li><li>RDB和AOF区别  <pre><code class="hljs plaintext">RDB    优点：使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能     缺点：RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候AOF    优点：可以保持更高的数据完整性    缺点：AOF文件比RDB文件大，加载(恢复速度)慢。</code></pre></li></ul><h3 id="Redis的集群部署-推荐3主3从"><a href="#Redis的集群部署-推荐3主3从" class="headerlink" title="Redis的集群部署(推荐3主3从)"></a><code>Redis的集群部署(推荐3主3从)</code></h3><ol><li>下载Redis程序包(只需在一台服务器上执行操作) <pre><code class="hljs plaintext">方法1：    1. 去Redis官网找到并复制其链接地址    2. wget -P /opt/setups/ http://download.redis.io/releases/redis-3.2.9.tar.gz方法2：    1. 去Redis官网找到指定版本的gz包,下载到本地    2. 通过rz等上传工具将程序包上传到/opt/setups目录中去</code></pre></li><li>解压到指定目录并编译安装 <pre><code class="hljs plaintext"># mkdir -pv /usr/program# tar -xzf redis-3.2.9.tar.gz -C /usr/program/# cd /usr/program/redis-3.2.9# make</code></pre></li><li>配置环境变量,使用vim编辑&#x2F;etc&#x2F;profile.d&#x2F;my.sh文件 <pre><code class="hljs plaintext"># RedisREDIS_HOME=/usr/program/redis-3.2.9PATH=$REDIS_HOME/src:$PATHexport REDIS_HOMEexport PATH</code></pre> <pre><code class="hljs plaintext"># source /etc/profile.d/my.sh</code></pre></li><li>创建集群等相关目录 <pre><code class="hljs plaintext"># mkdir -pv $&#123;REDIS_HOME&#125;/cluster-conf/&#123;6379,6389&#125;# tree -d $&#123;REDIS_HOME&#125;# cp $&#123;REDIS_HOME&#125;/redis.conf $&#123;REDIS_HOME&#125;/cluster-conf/6379# cp $&#123;REDIS_HOME&#125;/redis.conf $&#123;REDIS_HOME&#125;/cluster-conf/6389</code></pre></li><li>配置集群参数 <pre><code class="hljs plaintext"># vim $&#123;REDIS_HOME&#125;/cluster-conf/6379/redis.conf-----------------# myself##端口号port 6379##指定了记录日志的文件logfile &quot;/usr/program/redis-3.2.9/cluster-conf/6379/redis.log&quot;##数据目录，数据库的写入会在这个目录##rdb、aof文件也会写在这个目录dir /usr/program/redis-3.2.9/cluster-conf/6379/##是否开启集群cluster-enabled yes##集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。##这个文件并不需要手动配置，这个配置文件有Redis生成并更新，每个Redis集群节点需要##一个单独的配置文件，请确保与实例运行的系统中配置文件名称不冲突cluster-config-file nodes.conf##节点互连超时的阀值。集群节点超时毫秒数cluster-node-timeout 5000##默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。##但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，##Append Only File是另一种持久化方式，可以提供更好的持久化特性。##Redis会把每次写入的数据在接收后都写入appendonly.aof 文件，每次启动时Redis都会##先把这个文件的数据读入内存里，先忽略RDB文件。appendonly yes##指定Redis只接收来自于该IP 地址的请求，如果不进行设置，那么将处理所有请求，##在生产环境中最好设置该项bind 0.0.0.0</code></pre> <pre><code class="hljs plaintext"># vim $&#123;REDIS_HOME&#125;/cluster-conf/6389/redis.conf-----------------# myselfport 6389logfile &quot;/usr/program/redis-3.2.9/cluster-conf/6389/redis.log&quot;dir /usr/program/redis-3.2.9/cluster-conf/6389/cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000appendonly yesbind 0.0.0.0</code></pre></li><li>使用scp命令将redis项目复制到另一台服务器,并在另一台机器上执行<code>步骤3</code> <pre><code class="hljs plaintext"># scp -r $&#123;REDIS_HOME&#125; root@192.168.9.230:/usr/program/</code></pre></li><li>启动 <pre><code class="hljs plaintext">另一台机器也要执行-----------------# redis-server $&#123;REDIS_HOME&#125;/cluster-conf/6379/redis.conf &amp;# redis-server $&#123;REDIS_HOME&#125;/cluster-conf/6389/redis.conf &amp;</code></pre></li><li>创建集群Cluster <pre><code class="hljs plaintext">让redis-trib程序创建一个包含二个主节点和二个从节点的集群。    给定redis-trib.rb程序的命令是create，表示希望创建一个新的集群。    选项--replicas 1表示为集群中的每个主节点创建一个从节点（百分比选举master,按先后顺序）。    之后跟着的其他参数则是实例的地址列表，我们希望程序使用这些地址所指示的实例来创建新集群。-----------------如在执行时提示/usr/bin/env: ruby: No such file or directory,需要安装ruby,因为redis-trib是用ruby写的    # yum install ruby-----------------如在执行时提示/usr/program/redis-3.2.9/src/redis-trib.rb:24:in `require&#x27;: no such file to load -- rubygems (LoadError)    # yum install rubygems-----------------如在执行时提示/usr/lib/ruby/site_ruby/1.8/rubygems/custom_require.rb:31:in `gem_original_require&#x27;: no such file to load -- redis (LoadError)    # gem install redis-----------------如在执行gem install redis提示redis requires Ruby version &gt;= 2.2.2.    1. 安装curl        yum install curl    2. 安装RVM        curl -L get.rvm.io | bash -s stable        gpg2 --keyserver hkp://pool.sks-keyservers.net --recv-keys 409B6B1796C2..(此命令可通过上个命令的输出中找到)        curl -L get.rvm.io | bash -s stable        echo &quot;ruby_url=https://cache.ruby-china.org/pub/ruby&quot; &gt; ~/.rvm/user/db(修改RVM的Ruby安装源到Ruby China的Ruby镜像服务器，这样能提高安装速度)        source /usr/local/rvm/scripts/rvm    3. 查看rvm库中已知的ruby版本        rvm list known    4. 安装一个ruby版本(贼TM慢)        rvm install 2.3.3    5. 使用一个ruby版本        rvm use 2.3.3    6. 设置默认版本        rvm use 2.3.3 --default    7. 卸载一个已知版本        rvm remove 2.0.0    8. 查看Ruby版本        ruby --version-----------------</code></pre> <pre><code class="hljs plaintext"># redis-trib.rb create --replicas 1 192.168.9.231:6379 192.168.9.230:6379 192.168.9.232:6379 192.168.9.231:6389 192.168.9.230:6389 192.168.9.232:6389</code></pre></li><li>查看 <pre><code class="hljs plaintext"></code></pre></li><li>关闭服务<pre><code class="hljs plaintext"># redis-cli -h 192.168.9.231 -p 6379 shutdown</code></pre></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务架构之 SpringBoot</title>
      <link href="/2019/04/04/af-springboot.html"/>
      <url>/2019/04/04/af-springboot.html</url>
      
        <content type="html"><![CDATA[<h1 id="微服务架构之-SpringBoot"><a href="#微服务架构之-SpringBoot" class="headerlink" title="微服务架构之 SpringBoot"></a>微服务架构之 SpringBoot</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8">快速入门</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是SpringBoot"><a href="#什么是SpringBoot" class="headerlink" title="什么是SpringBoot"></a><code>什么是SpringBoot</code></h3><pre><code class="hljs plaintext">SpringBoot是一个快速开发的框架,能够快速整合第三方框架,简化XML配置完全采用注解形式,内置Web服务器(Jetty和Tomcat),最终以java应用程序进行执行。SpringBoot不是微服务框架。</code></pre><h3 id="为什么要用SpringBoot"><a href="#为什么要用SpringBoot" class="headerlink" title="为什么要用SpringBoot"></a><code>为什么要用SpringBoot</code></h3><pre><code class="hljs plaintext">解决传统SSM项目的开发效率低、Jar冲突、配置多的问题。</code></pre><h3 id="与SpringMVC、SpringCloud之间的关系"><a href="#与SpringMVC、SpringCloud之间的关系" class="headerlink" title="与SpringMVC、SpringCloud之间的关系"></a><code>与SpringMVC、SpringCloud之间的关系</code></h3><pre><code class="hljs plaintext">SpringCloud：    是一套完整的微服务解决框架,采用Http+Json格式的通讯协议,底层依赖于SpringBoot框架(web组件集成springmvc),使用SpringMVC书写Http协议接口。    采用SpringBoot+Dubbo也能实现微服务。SpringMVC：    SpringBoot默认集成了SpringMVC作为web层的框架。总结：    如果需要做微服务的话,就需要整合SpringBoot+SpringCloud;如果项目中不需要实现微服务,可以只单纯使用SpringBoot而不使用SpringCloud。</code></pre><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol><li>创建一个普通 maven 工程,packaging类型为jar(可省略)</li><li>pom文件配置 <pre><code class="hljs plaintext">&lt;!-- 引入SpringBoot parent依赖 --&gt;&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;!-- 设置资源属性 --&gt;&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;!-- 引入dependency --&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre> <pre><code class="hljs plaintext">spring-boot-starter-parent作用    统一整合第三方框架依赖信息,以后再申明其它dependency的时候就不需要写版本号了。spring-boot-starter-web作用    把传统方式的SpringMVC依赖的所有jar全部给下载下来,spring-boot-maven-plugin作用    如果直接通过Main启动spring，那么以下plugin必须要添加，否则是无法启动的。如果使用 maven 的spring-boot:run的话是不需要此配置的。</code></pre></li><li>配置application.yml <pre><code class="hljs plaintext">server:  tomcat:    accept-count: 1000    max-connections: 2000    max-threads: 300    min-spare-threads: 50    uri-encoding: UTF-8 # 指定tomcat的编码格式    max-http-post-size: 100MB    accesslog:      enabled: true  port: 8080 # 设定web访问端口号，也是http监听端口  connection-timeout: 60000  servlet:    context-path: /monitor # 2.0之后的配置，应用的上下文路径，也可以称为项目路径，是构成url地址的一部分  compression:    enabled: true # 是否开启压缩，默认为false  http2:    enabled: true # 应用支持http2</code></pre></li><li>编写helloworld服务 <pre><code class="hljs plaintext">package top.lvzhiqiang.controller;@RestController@EnableAutoConfigurationpublic class IndexController &#123;    @RequestMapping(&quot;/index&quot;)    public String index()&#123;        return &quot;hello springboot!&quot;;    &#125;    public static void main(String[] args) &#123;        SpringApplication.run(IndexController.class,args);    &#125;&#125;</code></pre> <pre><code class="hljs plaintext">@RestController的作用    表示该Controller下所有的方法返回JSON格式,可以直接编写Restful接口;省略了在方法上加上@ResponseBody。    如果项目中的类加上了此注解,说明这个项目可能是一个微服务项目,需要统一接口,提供服务接口。@EnableAutoConfiguration的作用    表示让Spring Boot根据添加的jar依赖来对Spring框架进行自动配置。    由于spring-boot-starter-web添加了Tomcat和Spring MVC，所以auto-configuration将假定你正在开发一个web应用并相应地对Spring进行设置。@Configuration的作用    底层含有@Component,标注在类上,相当于把该类作为spring的xml配置文件中的&lt;beans&gt;    用来来配置spring容器(应用上下文)@Bean的作用    标注在方法上(返回某个实例的方法),相当于spring的xml配置文件中的&lt;bean&gt;    用来注册bean对象(实例化bean,并交给spring管理)</code></pre></li><li>启动应用 <pre><code class="hljs plaintext">方法1：    直接启动main方法,main方法中指定IndexController为启动入口,默认端口号为8080。方法2：    @ComponentScan(basePackages = &quot;top.lvzhiqiang.controller&quot;)    @EnableAutoConfiguration    public class App &#123;    public static void main(String[] args) &#123;    SpringApplication.run(App.class, args);    &#125;    &#125;    单独写个类并使用@ComponentScan注解添加自动扫包范围。方法3：    @SpringBootApplication    public class App &#123;        public static void main(String[] args) &#123;            SpringApplication.run(App.class, args);        &#125;    &#125;    单独写个类并使用@SpringBootApplication注解,等同于@ComponentScan + @EnableAutoConfiguration。    扫包范围：当前包下或者子包下所有的类都可以扫到。</code></pre></li></ol><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><h3 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h3><ul><li><code>静态资源访问</code>  <pre><code class="hljs plaintext">在我们开发Web应用的时候，需要引用大量的js、css、图片等静态资源。Spring Boot默认提供静态资源目录位置需置于classpath(src/main/java或者src/main/resources)下，目录命名如下：    static、public、resources、META-INF/resources</code></pre></li><li><code>渲染Web页面</code>  <pre><code class="hljs plaintext">如果需要返回html等页面时,Spring Boot提供了多种模板引擎,来帮助我们很快的上手开发动态网站。    Thymeleaf、FreeMarker、Velocity、Groovy、MustacheSpring Boot建议使用模板引擎(例如FreeMarker)，避免使用JSP，若一定要使用JSP将无法实现Spring Boot的多种特性。    如果使用模板引擎,它们默认的模板配置路径为：src/main/resources/templates。当然也可以修改这个路径。</code></pre></li><li><code>使用Freemarker模板引擎渲染Web视图</code>  <pre><code class="hljs plaintext">1.pom文件引入FreeMarker的依赖包    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;    &lt;/dependency&gt;2.在src/main/resources/创建一个templates文件夹,在templates下新建ftlIndex.ftl    @Controller    @EnableAutoConfiguration    public class IndexController &#123;        @RequestMapping(&quot;/ftlIndex&quot;)        public String ftlIndex(Model model) &#123;            model.addAttribute(&quot;name&quot;, &quot;张三&quot;);            model.addAttribute(&quot;sex&quot;, 1);            List&lt;String&gt; userList = new ArrayList&lt;&gt;();            userList.add(&quot;a&quot;);            userList.add(&quot;b&quot;);            userList.add(&quot;c&quot;);            model.addAttribute(&quot;userList&quot;, userList);            return &quot;ftlIndex&quot;;        &#125;        ...    &#125;3.在ftl文件中填充数据    $&#123;name&#125;    &lt;#if sex == 1&gt;男    &lt;#elseif sex == 2&gt;女    &lt;#else&gt;其他    &lt;/#if&gt;    &lt;#list userList as user&gt;$&#123;user&#125;    &lt;/#list&gt;4.新建src/main/resources/下新建application.properties文件进行Freemarker配置(可以不配置,采用默认)    spring.freemarker.allow-request-override=false    spring.freemarker.cache=true    spring.freemarker.check-template-location=true    spring.freemarker.charset=UTF-8    spring.freemarker.content-type=text/html    spring.freemarker.expose-request-attributes=false    spring.freemarker.expose-session-attributes=false    spring.freemarker.expose-spring-macro-helpers=false    #spring.freemarker.prefix=    #spring.freemarker.request-context-attribute=    #spring.freemarker.settings.*=    spring.freemarker.suffix=.ftl    spring.freemarker.template-loader-path=classpath:/templates/    #comma-separated list    #spring.freemarker.view-names= # whitelist of view names that can be resolved</code></pre></li><li><code>使用JSP渲染Web视图</code>  <pre><code class="hljs plaintext">1.pom文件引入Jsp相关的依赖包    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;        &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;    &lt;/dependency&gt;2.新建src/main/resources/下新建application.properties文件进行Jsp配置    spring.mvc.view.prefix=/WEB-INF/jsp/    spring.mvc.view.suffix=.jsp3.在src/main/webapp下创建/WEB-INF/jsp/目录,并在jsp目录下新建jspIndex.jsp    @Controller    @EnableAutoConfiguration    public class IndexController &#123;        @RequestMapping(&quot;/jspIndex&quot;)        public String jspIndex() &#123;            return &quot;jspIndex&quot;;        &#125;        ...    &#125;4.如果找不到页面,可在pom文件中改为war类型项目</code></pre></li><li><code>全局捕获异常</code>  <pre><code class="hljs plaintext">@ControllerAdvice(basePackages = &quot;top.lvzhiqiang.controller&quot;)public class GlobalExceptionHandler &#123;    @ExceptionHandler(RuntimeException.class)    @ResponseBody    public Map&lt;String, Object&gt; exceptionHandler() &#123;        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;errorCode&quot;, &quot;101&quot;);        map.put(&quot;errorMsg&quot;, &quot;系統错误!&quot;);        return map;    &#125;&#125;</code></pre>  <pre><code class="hljs plaintext">@ExceptionHandler表示拦截异常@ControllerAdvice是controller的一个辅助类，最常用的就是作为全局异常处理的切面类    @ControllerAdvice可以指定扫描范围    @ControllerAdvice约定了几种可行的返回值，如果是直接        返回json，需要使用@ResponseBody进行json转换        返回页面，返回值类型为ModelAndView或者String实际开发中,可在全局捕获异常中将异常日志信息写入nosql数据库中,如果是集群环境,可采用分布式日志收集系统(kafka,logstash等),方便排查</code></pre></li></ul><h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><ol><li><code>使用log4j记录日志</code> <pre><code class="hljs plaintext">1.pom文件引入log4j相关的依赖包    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;exclusions&gt;            &lt;!-- 排除自带的logback依赖 --&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt;        &lt;version&gt;1.3.8.RELEASE&lt;/version&gt;    &lt;/dependency&gt;2.新建src/main/resources/下新建log4j.properties文件进行log4j配置    log4j.rootLogger=info,error,CONSOLE,DEBUG    log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender    log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout    log4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;yyyy-MM-dd-HH-mm&#125; [%t] [%c] [%p] - %m%n    log4j.logger.info=info    log4j.appender.info=org.apache.log4j.DailyRollingFileAppender    log4j.appender.info.layout=org.apache.log4j.PatternLayout    log4j.appender.info.layout.ConversionPattern=%d&#123;yyyy-MM-dd-HH-mm&#125; [%t] [%c] [%p] - %m%n    log4j.appender.info.datePattern=&#x27;.&#x27;yyyy-MM-dd    log4j.appender.info.Threshold = info    log4j.appender.info.append=true    log4j.appender.info.File=D:\\log4j\\springbootdemo\\info    log4j.logger.error=error    log4j.appender.error=org.apache.log4j.DailyRollingFileAppender    log4j.appender.error.layout=org.apache.log4j.PatternLayout    log4j.appender.error.layout.ConversionPattern=%d&#123;yyyy-MM-dd-HH-mm&#125; [%t] [%c] [%p] - %m%n    log4j.appender.error.datePattern=&#x27;.&#x27;yyyy-MM-dd    log4j.appender.error.Threshold = error    log4j.appender.error.append=true    log4j.appender.error.File=D:\\log4j\\springbootdemo\\error    log4j.logger.DEBUG=DEBUG    log4j.appender.DEBUG=org.apache.log4j.DailyRollingFileAppender    log4j.appender.DEBUG.layout=org.apache.log4j.PatternLayout    log4j.appender.DEBUG.layout.ConversionPattern=%d&#123;yyyy-MM-dd-HH-mm&#125; [%t] [%c] [%p] - %m%n    log4j.appender.DEBUG.datePattern=&#x27;.&#x27;yyyy-MM-dd    log4j.appender.DEBUG.Threshold = DEBUG    log4j.appender.DEBUG.append=true    log4j.appender.DEBUG.File=D:\\log4j\\springbootdemo\\debug</code></pre></li><li><code>使用AOP统一处理Web请求日志</code> <pre><code class="hljs plaintext">1.pom文件新增aop依赖    &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;    &lt;/dependency&gt;2.aop代码    @Aspect    @Component    public class WebLogAspect &#123;        private static final Logger logger = LoggerFactory.getLogger(WebLogAspect.class);            @Pointcut(&quot;execution(public * top.lvzhiqiang.controller.*.*(..))&quot;)        public void webLog() &#123;        &#125;            @Before(&quot;webLog()&quot;)        public void doBefore(JoinPoint joinPoint) throws Throwable &#123;            // 接收到请求，记录请求内容            ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();            HttpServletRequest request = attributes.getRequest();            // 记录下请求内容            logger.info(&quot;URL : &quot; + request.getRequestURL().toString());            logger.info(&quot;HTTP_METHOD : &quot; + request.getMethod());            logger.info(&quot;IP : &quot; + request.getRemoteAddr());            Enumeration&lt;String&gt; enu = request.getParameterNames();            while (enu.hasMoreElements()) &#123;                String name = (String) enu.nextElement();                logger.info(&quot;name:&#123;&#125;,value:&#123;&#125;&quot;, name, request.getParameter(name));            &#125;        &#125;            @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;webLog()&quot;)        public void doAfterReturning(Object ret) throws Throwable &#123;            // 处理完请求，返回内容            logger.info(&quot;RESPONSE : &quot; + ret);        &#125;    &#125;</code></pre></li><li><code>Spring Boot集成lombok让代码更简洁</code> <pre><code class="hljs plaintext">0.IDE开发工具需要先安装lombok插件(lombok底层使用asm字节码技术,在编译时修改字节码文件,来生成相应的set,get等相应方法)1.pom文件引入lombok相关的依赖包    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;/dependency&gt;2.实体类测试    @Slf4j    @Setter    @Getter    public class UserEntity &#123;        // @Getter        // @Setter        private String userName;        // @Getter        // @Setter        private Integer age;            @Override        public String toString() &#123;            return &quot;UserEntity [userName=&quot; + userName + &quot;, age=&quot; + age + &quot;]&quot;;        &#125;            public static void main(String[] args) &#123;            UserEntity userEntity = new UserEntity();            userEntity.setUserName(&quot;zhangsan&quot;);            userEntity.setAge(20);            System.out.println(userEntity.toString());            log.info(&quot;####我是日志##########&quot;);        &#125;    &#125;</code></pre> <pre><code class="hljs plaintext">其他特性：    @Data: 自动生成set/get方法，toString方法，equals方法，hashCode方法，不带参数的构造方法    @Setter/@Getter: 自动生成set和get方法     @ToString: 自动生成toString方法     @NonNull: 让你不在担忧并且爱上NullPointerException     @CleanUp: 自动资源管理,不用再在finally中添加资源的close方法     @EqualsAndHashcode: 从对象的字段中生成hashCode和equals的实现     @NoArgsConstructor/@RequiredArgsConstructor/@AllArgsConstructor: 自动生成构造方法    @Value: 用于注解final类     @Builder: 产生复杂的构建器api类     @SneakyThrows: 异常处理（谨慎使用）     @Synchronized : 同步方法安全的转化     @Log: 支持各种logger对象，使用时用对应的注解，如：@Log4j</code></pre></li></ol><h3 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h3><ul><li><code>整合mybatis和HikariCP</code>  <pre><code class="hljs plaintext">1.pom文件中引入数据源驱动与mybatis依赖    &lt;!-- mybatis --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.1.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- mysql驱动 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.21&lt;/version&gt;    &lt;/dependency&gt;2.在application.yml中配置数据源和mybatis    ###########################################################    #    # 配置数据源信息    #    ###########################################################    spring:      datasource: # 数据源的相关配置        type: com.zaxxer.hikari.HikariDataSource # 数据源类型：HikariCP        driver-class-name: com.mysql.jdbc.Driver # mysql驱动        url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect        username: root        password: root      hikari: # Hikari连接池配置        connection-timeout: 30000 # 等待连接池分配连接的最大时长（毫秒），超过这个时长还没可用的连接则发生SQ        minimum-idle: 5 # 最小空闲连接数        maximum-pool-size: 20 # 最大连接数，默认是10        auto-commit: true # 自动提交        idle-timeout: 600000 # 连接超时的最大时长（毫秒），超时则被释放（retired），默认:10分钟        pool-name: DateSourceHikariCP # 连接池名字        max-lifetime: 1800000 # 此属性控制池中连接的最长生命周期（毫秒），值0表示无限生命周期，超时而且没被使用则被释放（retired），默认:30分钟        connection-test-query: SELECT 1    ###########################################################    #    # mybatis配置    #    ###########################################################    mybatis:      type-aliases-package: com.riskraider.monitor.entity # 所有POJO类所在包路径，只能指定具体的包，多个配置可以使用英文逗号隔开      mapper-locations: classpath:mapper/**/*.xml # mapper映射文件的路径，支持Ant风格的通配符，多个配置可以使用英文逗号隔开      configuration:        # 开启驼峰命名转换，如：Table(create_time) -&gt; Entity(createTime)。        # 不需要我们关心怎么进行字段匹配，mybatis会自动识别`大写字母与下划线`        map-underscore-to-camel-case: true3.Mapper代码    public interface UserMapper &#123;    @Select(&quot;SELECT * FROM USERS WHERE NAME = #&#123;name&#125;&quot;)    User findByName(@Param(&quot;name&quot;) String name);    @Insert(&quot;INSERT INTO USERS(NAME, AGE) VALUES(#&#123;name&#125;, #&#123;age&#125;)&quot;)    int insert(@Param(&quot;name&quot;) String name, @Param(&quot;age&quot;) Integer age);    &#125;4.在启动类上加上@MapperScan(basePackages = &quot;top.lvzhiqiang.mapper&quot;)    也可以在Mapper接口上加上@Mapper,不过这样比较繁琐</code></pre>  <pre><code class="hljs plaintext">Mybatis整合分页插件(pageHelper)    PageHelper是一款好用的开源免费的Mybatis第三方物理分页插件    支持常见的12种数据库。Oracle,MySql,MariaDB,SQLite,DB2,PostgreSQL,SqlServer等    支持多种分页方式    支持常见的 RowBounds(PageRowBounds)，PageHelper.startPage方法调用，Mapper接口参数调用------------------1.添加maven依赖    &lt;dependency&gt;        &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;        &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.2.5&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;        &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;        &lt;version&gt;3.7&lt;/version&gt;    &lt;/dependency&gt;2.添加配置    pagehelper.helperDialect=mysql    pagehelper.reasonable=true    pagehelper.supportMethodsArguments=true    pagehelper.params=count=countSql    pagehelper.page-size-zero=true3.service层    public PageInfo&lt;User&gt; findUserList(int pageNo, int pageSize) &#123;        // 开启分页插件,放在查询语句上面        PageHelper.startPage(pageNo, pageSize);        List&lt;User&gt; listUser = userMapper.findUserList();        // 封装分页之后的数据        PageInfo&lt;User&gt; pageInfoUser = new PageInfo&lt;User&gt;(listUser);        return pageInfoUser;    &#125;    //以上方法上的公共代码可用模板设计模式或者aop思想抽出来</code></pre></li><li><code>整合jdbcTemplate</code>  <pre><code class="hljs plaintext">1.pom文件引入jdbcTemplate相关的依赖包    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.21&lt;/version&gt;    &lt;/dependency&gt;2.修改application.properties    spring.datasource.jdbc-url=jdbc:mysql://localhost:3306/test    spring.datasource.username=root    spring.datasource.password=root    spring.datasource.driver-class-name=com.mysql.jdbc.Driver3.代码    @Service    public class UserServiceImpl implements UserService &#123;    @Autowired    private JdbcTemplate jdbcTemplate;    public void createUser(String name, Integer age) &#123;    jdbcTemplate.update(&quot;insert into users values(null,?,?);&quot;, name, age);    &#125;    &#125;</code></pre></li><li><code>整合多数据源</code>  <pre><code class="hljs plaintext">1.修改application.properties新增两个数据源    ###datasource1    spring.datasource.test1.driver-class-name = com.mysql.jdbc.Driver    spring.datasource.test1.jdbc-url = jdbc:mysql://localhost:3306/test01?useUnicode=true&amp;characterEncoding=utf-8    spring.datasource.test1.username = root    spring.datasource.test1.password = root    ###datasource2    spring.datasource.test2.driver-class-name = com.mysql.jdbc.Driver    spring.datasource.test2.jdbc-url = jdbc:mysql://localhost:3306/test02?useUnicode=true&amp;characterEncoding=utf-8    spring.datasource.test2.username = root    spring.datasource.test2.password = root2.在top/lvzhiqiang/下新建datasource目录(任意),新建DataSourceConfig类,采用分包(业务)机制来读取不同的数据源    //datasource1    @Configuration    @MapperScan(basePackages = &quot;top.lvzhiqiang.user1&quot;, sqlSessionFactoryRef = &quot;test1SqlSessionFactory&quot;)    public class DataSource1Config &#123;        @Bean(name = &quot;test1DataSource&quot;)        @Primary        @ConfigurationProperties(prefix = &quot;spring.datasource.test1&quot;)        public DataSource testDataSource() &#123;            return DataSourceBuilder.create().build();        &#125;        @Bean(name = &quot;test1SqlSessionFactory&quot;)        @Primary        public SqlSessionFactory testSqlSessionFactory(@Qualifier(&quot;test1DataSource&quot;) DataSource dataSource)                throws Exception &#123;            SqlSessionFactoryBean bean = new SqlSessionFactoryBean();            bean.setDataSource(dataSource);            //bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mybatis/mapper/test1/*.xml&quot;));            return bean.getObject();        &#125;        @Bean(name = &quot;test1TransactionManager&quot;)        @Primary        public DataSourceTransactionManager testTransactionManager(@Qualifier(&quot;test1DataSource&quot;) DataSource dataSource) &#123;            return new DataSourceTransactionManager(dataSource);        &#125;            @Bean(name = &quot;test1SqlSessionTemplate&quot;)        public SqlSessionTemplate testSqlSessionTemplate(@Qualifier(&quot;test1SqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory)                throws Exception &#123;            return new SqlSessionTemplate(sqlSessionFactory);        &#125;    &#125;    ------------------------------    //datasource2    @Configuration    @MapperScan(basePackages = &quot;top.lvzhiqiang.user2&quot;, sqlSessionFactoryRef = &quot;test2SqlSessionFactory&quot;)    public class DataSource2Config &#123;        @Bean(name = &quot;test2DataSource&quot;)        @ConfigurationProperties(prefix = &quot;spring.datasource.test2&quot;)        public DataSource testDataSource() &#123;            return DataSourceBuilder.create().build();        &#125;        ...    &#125;3.创建分包Mapper    public interface User1Mapper &#123;    @Insert(&quot;insert into users values(null,#&#123;name&#125;,#&#123;age&#125;);&quot;)    public int addUser(@Param(&quot;name&quot;) String name, @Param(&quot;age&quot;) Integer age);    &#125;4.多数据源事务注意事项    在多数据源的情况下，使用@Transactional注解时，应该指定事务管理器    @Transactional(transactionManager = &quot;test2TransactionManager&quot;)</code></pre></li></ul><h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><ul><li><code>SpringBoot整合事物管理</code>  <pre><code class="hljs plaintext">springboot默认集成并开启事物,只要在方法上加上@Transactional即可</code></pre></li><li><code>SpringBoot分布式事物管理</code>  <pre><code class="hljs plaintext">针对多数据源的分布式事务解决方案：jta+atomikos针对微服务的分布式事务解决方案：mq或者tcc等</code></pre>  <pre><code class="hljs plaintext">1.pom文件引入atomikos相关的依赖包    &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jta-atomikos&lt;/artifactId&gt;    &lt;/dependency&gt;2.新增多数据源配置信息,修改application.properties    # Mysql 1    mysql.datasource.test1.url = jdbc:mysql://localhost:3306/test01?useUnicode=true&amp;characterEncoding=utf-8    mysql.datasource.test1.username = root    mysql.datasource.test1.password = root    mysql.datasource.test1.minPoolSize = 3    mysql.datasource.test1.maxPoolSize = 25    mysql.datasource.test1.maxLifetime = 20000    mysql.datasource.test1.borrowConnectionTimeout = 30    mysql.datasource.test1.loginTimeout = 30    mysql.datasource.test1.maintenanceInterval = 60    mysql.datasource.test1.maxIdleTime = 60    # Mysql 2    mysql.datasource.test2.url =jdbc:mysql://localhost:3306/test02?useUnicode=true&amp;characterEncoding=utf-8    mysql.datasource.test2.username =root    mysql.datasource.test2.password =root    mysql.datasource.test2.minPoolSize = 3    mysql.datasource.test2.maxPoolSize = 25    mysql.datasource.test2.maxLifetime = 20000    mysql.datasource.test2.borrowConnectionTimeout = 30    mysql.datasource.test2.loginTimeout = 30    mysql.datasource.test2.maintenanceInterval = 60    mysql.datasource.test2.maxIdleTime = 603.读取多数据源配置信息,可在top/lvzhiqiang/下新建config目录(任意),新建2个config类    @Data    @ConfigurationProperties(prefix = &quot;mysql.datasource.test1&quot;)    public class DBConfig1 &#123;    private String url;    private String username;    private String password;    private int minPoolSize;    private int maxPoolSize;    private int maxLifetime;    private int borrowConnectionTimeout;    private int loginTimeout;    private int maintenanceInterval;    private int maxIdleTime;    private String testQuery;    &#125;    ----------------------    @Data    @ConfigurationProperties(prefix = &quot;mysql.datasource.test2&quot;)    public class DBConfig2 &#123;    private String url;    private String username;    private String password;    private int minPoolSize;    private int maxPoolSize;    private int maxLifetime;    private int borrowConnectionTimeout;    private int loginTimeout;    private int maintenanceInterval;    private int maxIdleTime;    private String testQuery;    &#125;4.将多数据源注册到atomikos中去,在top/lvzhiqiang/下新建datasource目录(任意),新建DataSourceConfig类    @Configuration    @MapperScan(basePackages = &quot;top.lvzhiqiang.test01&quot;, sqlSessionTemplateRef = &quot;testSqlSessionTemplate&quot;)    public class MyBatisConfig1 &#123;    @Primary    @Bean(name = &quot;testDataSource&quot;)    public DataSource testDataSource(DBConfig1 testConfig) throws SQLException &#123;    MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource();    mysqlXaDataSource.setUrl(testConfig.getUrl());    mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true);    mysqlXaDataSource.setPassword(testConfig.getPassword());    mysqlXaDataSource.setUser(testConfig.getUsername());    mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true);        AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean();    xaDataSource.setXaDataSource(mysqlXaDataSource);    xaDataSource.setUniqueResourceName(&quot;testDataSource&quot;);        xaDataSource.setMinPoolSize(testConfig.getMinPoolSize());    xaDataSource.setMaxPoolSize(testConfig.getMaxPoolSize());    xaDataSource.setMaxLifetime(testConfig.getMaxLifetime());    xaDataSource.setBorrowConnectionTimeout(testConfig.getBorrowConnectionTimeout());    xaDataSource.setLoginTimeout(testConfig.getLoginTimeout());    xaDataSource.setMaintenanceInterval(testConfig.getMaintenanceInterval());    xaDataSource.setMaxIdleTime(testConfig.getMaxIdleTime());    xaDataSource.setTestQuery(testConfig.getTestQuery());    return xaDataSource;    &#125;    @Primary    @Bean(name = &quot;testSqlSessionFactory&quot;)    public SqlSessionFactory testSqlSessionFactory(@Qualifier(&quot;testDataSource&quot;) DataSource dataSource)    throws Exception &#123;    SqlSessionFactoryBean bean = new SqlSessionFactoryBean();    bean.setDataSource(dataSource);    return bean.getObject();    &#125;    @Primary    @Bean(name = &quot;testSqlSessionTemplate&quot;)    public SqlSessionTemplate testSqlSessionTemplate(@Qualifier(&quot;testSqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory)            throws Exception &#123;    return new SqlSessionTemplate(sqlSessionFactory);    &#125;    &#125;    ----------------------    @Configuration    @MapperScan(basePackages = &quot;top.lvzhiqiang.test02&quot;, sqlSessionTemplateRef = &quot;test2SqlSessionTemplate&quot;)    public class MyBatisConfig2 &#123;    @Bean(name = &quot;test2DataSource&quot;)    public DataSource testDataSource(DBConfig2 testConfig) throws SQLException &#123;    MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource();    mysqlXaDataSource.setUrl(testConfig.getUrl());    mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true);    ...    &#125;        ...    &#125;5.在启动类加上此注解以开启读取配置文件    @EnableConfigurationProperties(value = &#123; DBConfig1.class, DBConfig2.class &#125;)</code></pre></li></ul><h3 id="监控管理"><a href="#监控管理" class="headerlink" title="监控管理"></a>监控管理</h3><ul><li><code>Actuator监控应用</code>  <pre><code class="hljs plaintext">什么是SpringBoot监控中心    Actuator是spring boot的一个附加功能,可帮助你在应用程序生产环境时监视和管理应用程序。    特别对于微服务管理十分有意义,缺点是没有可视化界面(返回json格式)。    默认情况下,监控中心只提供3个接口权限。    在SpringBoot2.0后,监控中心接口地址发生变化,需要在访问接口前面中上/actuator。主要用途    针对微服务服务器监控,包括服务器的内存变化(堆内存、线程、日志管理等)    检测服务配置连接地址(懒加载形式)是否可用(模拟访问)    统计当前Spring容器中有多少个bean    统计SpringMVC有多少个@RuquestMapping(http接口)应用场景    生产环境</code></pre>  <pre><code class="hljs plaintext">1.添加maven依赖    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;    &lt;/dependency&gt;2.yml配置    ###通过下面的配置启用所有的监控端点，默认情况下，这些端点是禁用的    management:        endpoints:            web:                exposure:                    include: &quot;*&quot;3.开始访问(通过actuator/+端点名就可以获取相应的信息)    /actuator/beans显示应用程序中所有Spring bean的完整列表。    /actuator/mappings显示所有@RequestMapping的url完整列表。    /actuator/configprops显示所有配置信息。    /actuator/env显示所有的环境变量。    /actuator/health显示应用程序运行状况信息,up表示成功,down失败。    /actuator/info查看自定义应用信息(显示在配置文件配置info开头的配置信息)</code></pre></li><li><h2 id="Admin-UI分布式微服务监控中心-Admin-UI底层基于actuator实现能够返回界面展示监控信息-原理是将所有服务的监控中心管理存放在admin-ui平台上。"><a href="#Admin-UI分布式微服务监控中心-Admin-UI底层基于actuator实现能够返回界面展示监控信息-原理是将所有服务的监控中心管理存放在admin-ui平台上。" class="headerlink" title="Admin-UI分布式微服务监控中心  - Admin-UI底层基于actuator实现能够返回界面展示监控信息,原理是将所有服务的监控中心管理存放在admin-ui平台上。"></a><code>Admin-UI分布式微服务监控中心</code><br>  - Admin-UI底层基于actuator实现能够返回界面展示监控信息,原理是将所有服务的监控中心管理存放在admin-ui平台上。</h2>  <pre><code class="hljs plaintext">Admin-UI-Server--------------------1.添加maven依赖    &lt;dependency&gt;        &lt;groupId&gt;de.codecentric&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;        &lt;version&gt;2.0.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.jolokia&lt;/groupId&gt;        &lt;artifactId&gt;jolokia-core&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.googlecode.json-simple&lt;/groupId&gt;        &lt;artifactId&gt;json-simple&lt;/artifactId&gt;        &lt;version&gt;1.1&lt;/version&gt;    &lt;/dependency&gt;2.yml配置    spring:        application:            name: spring-boot-admin-server3.启动server端    @Configuration    @EnableAutoConfiguration    @EnableAdminServer    public class AdminServerApplication &#123;    public static void main(String[] args) &#123;    SpringApplication.run(AdminServerApplication.class, args);    &#125;    &#125;4.访问    http://localhost:8080</code></pre>  <pre><code class="hljs plaintext">Admin-UI-Client--------------------1.添加maven依赖    &lt;dependency&gt;        &lt;groupId&gt;de.codecentric&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;        &lt;version&gt;2.0.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.jolokia&lt;/groupId&gt;        &lt;artifactId&gt;jolokia-core&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.googlecode.json-simple&lt;/groupId&gt;        &lt;artifactId&gt;json-simple&lt;/artifactId&gt;        &lt;version&gt;1.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;2.yml配置    spring:        boot:            admin:                client:                    url: http://localhost:8080    ###配置client端注册到admin-ui平台    server:        port: 8081    management:        endpoints:            web:                exposure:                    include: &quot;*&quot;            endpoint:                health:                    show-details: ALWAYS3.启动client端    @SpringBootApplication    public class AppClient &#123;    public static void main(String[] args) &#123;    SpringApplication.run(AppClient.class, args);    &#125;    &#125;</code></pre></li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul><li><code>JVM参数调优(运行优化)</code>  <pre><code class="hljs plaintext">-Xms和-Xmx最好设置成一样,不然会频繁造成GC外部运行调优使用：java -server -Xms32m -Xmx32m  -jar springboot.jar</code></pre></li><li><code>扫包优化(启动优化,非运行优化)</code>  <pre><code class="hljs plaintext">针对大项目时不要用@SpringBootApplication注解,会扫描到无用的包,可以采用@ComponentScan来扫描指定的包</code></pre></li><li><code>将Servlet容器变成Undertow</code>  <pre><code class="hljs plaintext">默认情况下，Spring Boot 使用 Tomcat 来作为内嵌的 Servlet 容器,可以将 Web 服务器切换到 Undertow 来提高应用性能。    Undertow 是一个采用 Java 开发的灵活的高性能 Web 服务器，提供包括阻塞和基于NIO的非堵塞机制。    Undertow 是红帽公司的开源产品，是 Wildfly 默认的 Web 服务器。可用jmeter作吞吐量测试,结果是tomcat吞吐量为5000,undertow为8000</code></pre>  <pre><code class="hljs plaintext">1.从依赖信息里移除Tomcat    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;2.添加Undertow依赖    &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre></li></ul><h3 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h3><ul><li><code>使用@Scheduled创建定时任务</code>  <pre><code class="hljs plaintext">在启动类中加入@EnableScheduling注解，启用定时任务的配置-------------------@Componentpublic class ScheduledTasks &#123;    private static final SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;HH:mm:ss&quot;);    @Scheduled(fixedRate = 5000)    public void reportCurrentTime() &#123;        System.out.println(&quot;现在时间：&quot; + dateFormat.format(new Date()));    &#125;&#125;</code></pre></li><li><code>使用@Async异步执行方法</code>  <pre><code class="hljs plaintext">在启动类加上@EnableAsync来开启异步调用,并在需要执行异步的方法上加上@Async    @Async注解使用AOP技术在运行时创建一个单线程来执行这个方法</code></pre></li><li><code>使用@Value自定义参数</code>  <pre><code class="hljs plaintext">application.properties文件    name=lvzhiqiang.top代码中@Value(&quot;$&#123;name&#125;&quot;)private String name;    @ResponseBody@RequestMapping(&quot;/getValue&quot;)public String getValue() &#123;return name;&#125;</code></pre></li><li><code>区分不同环境配置文件</code>  <pre><code class="hljs plaintext">1.在src/main/resources下新建各个环境的配置文件    application-dev.properties：开发环境    application-uat.properties：测试环境    application-pre.properties：生产环境2.在application.properties中进行切换    spring.profiles.active=uat</code></pre></li><li><code>修改端口号</code>  <pre><code class="hljs plaintext">server.port=8888server.context-path=/springbootdemo</code></pre></li><li><code>Spring Boot yml 使用</code>  <pre><code class="hljs plaintext">SpringBoot默认读取application.yml|propertiesYML比properties配置文件更加简约（结构）---------------server:  port: 8081  context-path: /springbootdemo</code></pre></li><li><code>发布打包</code>  <pre><code class="hljs plaintext">jar类型打包方式    1.使用mvn celan  package 打包    2.使用java –jar 包名war类型打包方式    1.使用mvn celan  package 打包    2.将war包放入到tomcat webapps下运行即可    注意:springboot2.0内置tomcat8.5.25，建议使用外部Tomcat9.0版本运行即可,否则报错版本不兼容。</code></pre>  <pre><code class="hljs plaintext">如果执行java -jar命令提示没有主清单属性时,可在pom文件中新增如下代码    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;mainClass&gt;top.lvzhiqiang.StartApp&lt;/mainClass&gt;                &lt;/configuration&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;goals&gt;                            &lt;goal&gt;repackage&lt;/goal&gt;                        &lt;/goals&gt;                    &lt;/execution&gt;                &lt;/executions&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;</code></pre></li><li><code>热部署</code>  <pre><code class="hljs plaintext">1.什么是热部署    在应用程序不停止的情况下，实现新的部署2.热部署原理    使用类加载器重新读取字节码文件到JVM中去3.纯手写实现一个热部署功能    监听class文件是否发生改变(版本号或者修改时间),如果class文件发生改变,就使用classloader进行得新读取4.优缺点    适合本地开发,提高运行效率,不用重启服务器;缺点是项目比较大时,非常卡,比较占内存.</code></pre>  <pre><code class="hljs plaintext">1.引入devtools依赖    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;        &lt;scope&gt;true&lt;/scope&gt;    &lt;/dependency&gt;2.Devtools原理    1.devtools会监听classpath下的文件变动，并且会立即重启应用（发生在保存时机），注意：因为其采用的虚拟机机制，该项重启是很快的。      2.devtools可以实现页面热部署（即页面修改后会立即生效，这个可以直接在application.properties文件中配置spring.thymeleaf.cache=false来实现(这里注意不同的模板配置不一样) 3.不推荐使用</code></pre></li><li><code>整合拦截器</code>  <pre><code class="hljs plaintext">1.创建拦截器    @Slf4j    @Component    //创建模拟登录拦截器，验证请求是否有token参数    public class LoginIntercept implements HandlerInterceptor &#123;        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)                throws Exception &#123;            log.info(&quot;开始拦截登录请求....&quot;);            String token = request.getParameter(&quot;token&quot;);            if (StringUtils.isEmpty(token)) &#123;                response.getWriter().println(&quot;not found token&quot;);                return false;            &#125;            return true;        &#125;    &#125;2.注册拦截器    @Configuration    public class WebAppConfig &#123;    @Autowired    private LoginIntercept loginIntercept;    @Bean    public WebMvcConfigurer WebMvcConfigurer() &#123;    return new WebMvcConfigurer() &#123;    public void addInterceptors(InterceptorRegistry registry) &#123;    registry.addInterceptor(loginIntercept).addPathPatterns(&quot;/*&quot;);    &#125;;    &#125;;    &#125;    &#125;</code></pre>  <pre><code class="hljs plaintext">拦截器与过滤器区别    拦截器是AOP( Aspect-Oriented Programming)的一种实现，底层通过动态代理模式完成。    （1）拦截器是基于java的反射机制的，而过滤器是基于函数回调。    （2）拦截器不依赖于servlet容器，而过滤器依赖于servlet容器。    （3）拦截器只能对Controller请求起作用，而过滤器则可以对几乎所有的请求起作用。    （4）在Controller的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。过滤器应用场景:设置编码字符、过滤铭感字符拦截器应用场景:拦截未登陆用户、审计日志</code></pre></li></ul><h3 id="2-0版本新特性"><a href="#2-0版本新特性" class="headerlink" title="2.0版本新特性"></a>2.0版本新特性</h3><ul><li><code>以Java 8 为基准</code>  <pre><code class="hljs plaintext">Spring Boot 2.0 要求 Java 版本必须 8 以上， Java 6 和 7 不再支持。</code></pre></li><li><code>内嵌容器包结构调整</code>  <pre><code class="hljs plaintext">为了支持reactive使用场景，内嵌的容器包结构被重构了的幅度有点大。EmbeddedServletContainer被重命名为WebServer，并且org.springframework.boot.context.embedded 包被重定向到了org.springframework.boot.web.embedded包下。举个例子，如果你要使用TomcatEmbeddedServletContainerFactory回调接口来自定义内嵌Tomcat容器，你现在应该使用TomcatServletWebServerFactory。</code></pre></li><li><code>Servlet-specific 的server properties调整</code>  <pre><code class="hljs plaintext">大量的Servlet专属的server.* properties被移到了server.servlet下：    Old propertyNew property    server.context-parameters.*server.servlet.context-parameters.*    server.context-pathserver.servlet.context-path    server.jsp.class-nameserver.servlet.jsp.class-name    server.jsp.init-parameters.*server.servlet.jsp.init-parameters.*    server.jsp.registeredserver.servlet.jsp.registered    server.servlet-pathserver.servlet.path由此可以看出一些端倪，那就是server不再是只有servlet了，还有其他的要加入。</code></pre></li><li><code>Actuator 默认映射</code>  <pre><code class="hljs plaintext">actuator的端点（endpoint）现在默认映射到/application，比如，/info 端点现在就是在/application/info。但你可以使用management.context-path来覆盖此默认值。</code></pre></li><li><code>Spring Loaded不再支持</code>  <pre><code class="hljs plaintext">由于Spring Loaded项目已被移到了attic了，所以不再支持Spring Loaded了。现在建议你去使用Devtools。Spring Loaded不再支持了。</code></pre></li><li><code>支持Quartz Scheduler</code>  <pre><code class="hljs plaintext">Spring Boot 2.0针对Quartz调度器提供了支持。你可以加入spring-boot-starter-quartz starter来启用。而且支持基于内存和基于jdbc两种存储。</code></pre></li><li><code>OAuth 2.0 支持</code>  <pre><code class="hljs plaintext">Spring Security OAuth 项目中的功能将会迁移到Spring Security中。将会OAuth 2.0。</code></pre></li><li><code>支持Spring WebFlux</code>  <pre><code class="hljs plaintext">WebFlux 模块的名称是 spring-webflux，名称中的 Flux 来源于 Reactor 中的类 Flux。该模块中包含了对反应式 HTTP、服务器推送事件和 WebSocket 的客户端和服务器端的支持。对于开发人员来说，比较重要的是服务器端的开发，这也是本文的重点。在服务器端，WebFlux 支持两种 不同的编程模型：第一种是 Spring MVC 中使用的基于 Java 注解的方式；第二种是基于 Java 8 的 lambda 表达式的函数式编程模型。这两种 编程模型只是在代码编写方式上存在不同。它们运行在同样的反应式底层架构之上，因此在运行时是相同的。WebFlux 需要底层提供运行时的支持， WebFlux 可以运行在支持 Servlet 3.1 非阻塞 IO API 的 Servlet 容器上，或是其他异步运行时环境，如 Netty 和 Undertow。</code></pre></li><li><code>版本要求</code>  <pre><code class="hljs plaintext">Jetty    要求Jetty最低版本为9.4。Tomcat    要求Tomcat最低版本为8.5。Hibernate    要求Hibernate最低版本为5.2。Gradle    要求Gradle最低版本为3.4。SendGrid    SendGrid最低支持版本是3.2。为了支持这次升级，username和password已经被干掉了。因为API key现在是唯一支持的认证方式。</code></pre></li></ul><h3 id="手写springboot框架"><a href="#手写springboot框架" class="headerlink" title="手写springboot框架"></a>手写springboot框架</h3><ul><li>springboot核心原理  <pre><code class="hljs plaintext">基于springmvc无配置文件完全注解化(纯java)+内置tomcat-embed-core来实现springboot框架,main函数启动快速整合第三方框架    原理:Maven继承依赖关系完全无配置文件采用注解化    原理:使用java代码(spring3内置注解)来对springmvc容器进行初始化内置web服务器    原理:Java提供内置Tomcat容器框架,使用java语言创建并操作tomcat容器,加载class文件</code></pre></li><li>内置web服务器  <pre><code class="hljs plaintext">1.添加pom依赖    &lt;!--Java语言操作tomcat --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;        &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;        &lt;version&gt;8.5.16&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- spring-web --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-web&lt;/artifactId&gt;        &lt;version&gt;5.0.4.RELEASE&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- spring-mvc --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;5.0.4.RELEASE&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- tomcat对jsp支持 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;        &lt;artifactId&gt;tomcat-jasper&lt;/artifactId&gt;        &lt;version&gt;8.5.16&lt;/version&gt;    &lt;/dependency&gt;2.创建servlet类    public class IndexServet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    doPost(req, resp);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    resp.getWriter().print(&quot;springboot2.0&quot;);    &#125;    &#125;3.创建tomcat运行    private static int PORT = 8080;// 端口号    private static String CONTEXTPATH = &quot;/demo&quot;;// 项目名称    public static void main(String[] args) throws LifecycleException &#123;        // 创建Tomcat服务器        Tomcat tomcatServer = new Tomcat();        // 设置Tomcat端口号        tomcatServer.setPort(PORT);        tomcatServer.getHost().setAutoDeploy(false);        // 创建Context上下文        StandardContext standardContext = new StandardContext();        standardContext.setPath(CONTEXTPATH);        standardContext.addLifecycleListener(new FixContextListener());        // tomcat容器添加standardContext        tomcatServer.getHost().addChild(standardContext);        // 创建servlet        tomcatServer.addServlet(CONTEXTPATH, &quot;IndexServet&quot;, new IndexServet());        // 添加servleturl映射        standardContext.addServletMappingDecoded(&quot;/index&quot;, &quot;IndexServet&quot;);        tomcatServer.start();        tomcatServer.getServer().await();    &#125;</code></pre></li><li>完全无配置文件采用注解化  <pre><code class="hljs plaintext">1.加载SpringMVC的DispatcherServlet    AbstractAnnotationConfigDispatcherServletInitializer这个类负责配置DispatcherServlet、初始化Spring MVC容器和Spring容器。    getRootConfigClasses()方法用于获取Spring应用容器的配置文件，这里我们给定预先定义的RootConfig.class；    getServletConfigClasses负责获取Spring MVC应用容器，这里传入预先定义好的WebConfig.class；    getServletMappings()方法负责指定需要由DispatcherServlet映射的路径，这里给定的是&quot;/&quot;，意思是由DispatcherServlet处理所有向该应用发起的请求。        public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;    // 加载根容器    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;    return new Class[] &#123; RootConfig.class &#125;;    &#125;        // 加载SpringMVC容器    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;    return new Class[] &#123; WebConfig.class &#125;;    &#125;    // SpringMVCDispatcherServlet 拦截的请求    protected String[] getServletMappings() &#123;    return new String[] &#123; &quot;/&quot; &#125;;    &#125;    &#125;2.加载SpringMVC容器    @Configuration    @EnableWebMvc    @ComponentScan(&quot;top.lvzhiqiang.controller&quot;)    public class WebConfig extends WebMvcConfigurerAdapter &#123;        // 创建SpringMVC视图解析器    @Bean    public ViewResolver viewResolver() &#123;    InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();    viewResolver.setPrefix(&quot;/WEB-INF/views/&quot;);    viewResolver.setSuffix(&quot;.jsp&quot;);    viewResolver.setExposeContextBeansAsAttributes(true);//可以在JSP页面中通过$&#123;&#125;访问beans    return viewResolver;    &#125;    &#125;3.加载RootConfig容器    @Configuration    @ComponentScan(basePackages = &quot;top.lvzhiqiang&quot;)    public class RootConfig &#123;    &#125;4.运行    public static void main(String[] args) throws ServletException, LifecycleException &#123;        start();    &#125;    public static void start() throws ServletException, LifecycleException &#123;        // 创建Tomcat容器        Tomcat tomcatServer = new Tomcat();        // 端口号设置        tomcatServer.setPort(9090);        // 读取项目路径,主要用来加载一些静态资源        StandardContext ctx = (StandardContext) tomcatServer.addWebapp(&quot;/&quot;, new File(&quot;src/main&quot;).getAbsolutePath());        // 禁止重新载入        ctx.setReloadable(false);        // class文件读取地址        File additionWebInfClasses = new File(&quot;target/classes&quot;);        // 创建WebRoot        WebResourceRoot resources = new StandardRoot(ctx);        // tomcat内部读取Class执行        resources.addPreResources(new DirResourceSet(resources, &quot;/WEB-INF/classes&quot;, additionWebInfClasses.getAbsolutePath(), &quot;/&quot;));        tomcatServer.start();        // 异步等待请求执行        tomcatServer.getServer().await();    &#125;</code></pre></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 性能调优：JVM</title>
      <link href="/2019/03/30/dl-java-jvm.html"/>
      <url>/2019/03/30/dl-java-jvm.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-性能调优：JVM"><a href="#Java-性能调优：JVM" class="headerlink" title="Java 性能调优：JVM"></a>Java 性能调优：JVM</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>整理下学习JVM时的知识点. </p><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><h3 id="JVM的整体架构"><a href="#JVM的整体架构" class="headerlink" title="JVM的整体架构"></a><code>JVM的整体架构</code></h3><pre><code class="hljs plaintext">1. 虚拟机是指以软件的方式模拟具有完整硬件系统功能、运行在一个完全隔离环境中的完整计算机系统，是物理机的软件实现。2. 常用的虚拟机有Vmware，Virtual Box，Java Virtual Machine(JVM)。3. JVM阵营：Sun HotSpot VM(oracle收购)、BEA JRockit VM(oracle收购)、IBM J9 VM、AZul VM、Apache Harmony、Google Dalvik VM、Microsoft JVM...。    jdk8用元空间取代了永久代,是为融合HotSpot JVM和JRockit JVM而做出的努力,因为JRockit没有永久代,不需要配置永久代。    jdk11出了一个zgc垃圾收集器。----------------------JVM由3个主要的子系统构成    类加载器子系统    运行时数据区(内存结构)    执行引擎</code></pre><p><img src="/2019/03/30/dl-java-jvm/dl-java-jvm-001.png" alt="抱歉,图片休息了"> </p><h3 id="类加载器子系统"><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a><code>类加载器子系统</code></h3><h3 id="运行时数据区-内存结构"><a href="#运行时数据区-内存结构" class="headerlink" title="运行时数据区(内存结构)"></a><code>运行时数据区(内存结构)</code></h3><pre><code class="hljs plaintext">本地方法栈(线程私有)    登记native方法,在Execution Engine执行时加载本地方法库。程序计数器(线程私有)    当前线程执行的字节码的行号指示器，通过改变此指示器由执行引擎来读取下一个需要执行的字节码指令,是一个非常小的内存空间,几乎可以忽略不记。    ------------------    特征：        在线程创建时创建;每个线程拥有一个;指向下一条指令的地址。Java栈(线程私有)    一个线程对应一个栈,每个方法在执行的同时都会创建一个栈帧(用于存储局部变量表,操作数栈,动态链接,方法出口等信息)。    方法从调用直至执行完成的过程,就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。    局部变量表所需的内存空间在编译期间完成分配,而且分配多大的局部变量空间是完全确定的,在方法运行期间不会改变其大小。    只要线程一结束该栈就释放了,不存在垃圾回收问题。    ------------------    JVM对该区域规范了2种异常：        1.线程请求的栈深度大于虚拟机栈所允许的深度,将抛出StackOverFlowError异常        2.若JVM栈可动态扩展,当无法申请到足够的内存空间时将抛出OutOfMemoryError,通过jvm参数-Xss指定栈空间,空间大小决定函数调用的深度方法区(线程共享)    存储静态变量+常量+类信息(构造方法/接口定义)+方法字节码。虽然JVM规范把方法区描述为堆的一个逻辑部分,但是它却有一个别名叫做Non-Heap(非堆),    目的是与Java堆区分开来。堆(线程共享)    虚拟机启动时创建,用于存放对象实例,几乎所有的对象(包含常量池)都在堆上分配内存,当对象无法在该空间申请到内存时将抛出OOM异常.同时也是GC管理    的主要区域.可通过-Xms -Xmx参数来分别指定最大堆和最小堆    ------------------    新生区：        类诞生,成长,消亡的区域,一个类在这里产生,应用,最后被垃圾回收器收集,结束生命。        包括伊甸区(Eden space)和幸存者区(Survivor space),所有的类都是在伊甸区被new出来的,幸存者区包括0区和1区,当伊甸区的空间用完时,程序还        需要创建对象,JVM的GC将对伊甸区进行Minor GC,将伊甸区中的不再被其他对象所引用的对象进行销毁,然后将伊甸区中剩余的对象移动到幸存0区.若0区        也满了,再对该区进行GC,然后移动到幸存1区,此时1区和0区的位置对调。    老年区：        当0区和1区GC依次轮询15次(可配置)后,新生区中的1区还有存活的对象时,对象将移动到老年区,若老年区也满了,这个时候将产生Major GC(Full GC),        来进行老年区的内存清理.若老年区执行了Full GC之后发现依然无法进行对象的保存,就会产生OOM异常。    元数据区：        取代了永久代(jdk1.8以前的),本质和永久代类似,都是对JVM规范中方法区(抽象)的实现,区别在于元数据区并不在虚拟机中,而是使用本地物理内存,永久代在虚拟        机中,永久代逻辑结构上属于堆,但物理上不属于堆,堆大小=新生生+老年代.元数据区也有可能发生OOM异常。        jdk6及之前：有永久代,常量池在方法区        jdk7：有永久代,但已逐步&quot;去永久代&quot;,常量池在堆        jdk8及之后：无永久代,常量池在元空间</code></pre><p><img src="/2019/03/30/dl-java-jvm/dl-java-jvm-002.png" alt="抱歉,图片休息了"><br><img src="/2019/03/30/dl-java-jvm/dl-java-jvm-005.png" alt="抱歉,图片休息了"><br><img src="/2019/03/30/dl-java-jvm/dl-java-jvm-003.png" alt="抱歉,图片休息了">  </p><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a><code>执行引擎</code></h3><pre><code class="hljs plaintext">读取运行时数据区的java字节码并逐个执行</code></pre><p><img src="/2019/03/30/dl-java-jvm/dl-java-jvm-004.png" alt="抱歉,图片休息了"> </p><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a><code>GC</code></h3><p>GC调优的目的：尽量让Full GC的次数变少,并且每一次Full GC的时间长度越短越好</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 新特性：8</title>
      <link href="/2019/03/30/dl-java-8.html"/>
      <url>/2019/03/30/dl-java-8.html</url>
      
        <content type="html"><![CDATA[<h1 id="JJava-新特性：8"><a href="#JJava-新特性：8" class="headerlink" title="JJava 新特性：8"></a>JJava 新特性：8</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>整理下 Java8 的所有新特性。 <ul><li><code>Lambda表达式</code></li><li><code>Stream API</code></li><li>全新时间日期 API</li><li>ConcurrentHashMap</li><li>MetaSpace</li></ul></li><li>Java8 的新特性对 java 的影响。<ul><li>更安全(Optional)</li><li>更效率(HashMap,HashSet,ConcurrentHashMap,MetaSpace)</li><li>简化书写(Lambda,Stream API)</li></ul></li></ul><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a><code>Lambda 表达式</code></h3><pre><code class="hljs plaintext">一、简介：    Lambda表达式相当于匿名内部类的更简化的写法，并且可以像数据一样进行传递。    它需要函数式接口的支持。二、基础语法：    Java8中引入了一个新的操作符 &quot;-&gt;&quot;，该操作符被称为箭头操作符或Lambda操作符，箭头操作符将Lambda表达式拆分成两部分：        左侧：指定了Lambda表达式需要的所有参数         右侧：指定了Lambda体，即Lambda表达式要执行的功能。    上联：左右遇一括号省    下联：左侧推断类型省    横批：能省则省</code></pre><pre><code class="hljs plaintext">语法格式一：无参数，无返回值，Lambda体只需一条语句    Runnable r1 = () -&gt; System.err.println(&quot;Hello Lambda!r1&quot;);    r1.run();语法格式二：有一个参数，无返回值    Consumer&lt;String&gt; con = (arg) -&gt; System.err.println(&quot;hello &quot; + arg);con.accept(&quot;consumer!&quot;);        若只有一个参数，参数的小括号可以省略不写        Consumer&lt;String&gt; con = arg -&gt; System.err.println(&quot;hello &quot; + arg);语法格式三：有两个以上的参数，有返回值，并且Lambda体中有多条语句    Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123;        System.out.println(&quot;函数式接口&quot;);        return Integer.compare(x, y);    &#125;;        若Lambda体中只有一条语句，return和大括号都可以省略不写        Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);语法格式四：Lambda表达式的参数列表的数据类型可以省略不写，因为JVM编译器根据程序的上下文推断出参数的数据类型，即“类型推断”    Comparator&lt;Integer&gt; com = (Integer x, Integer y) -&gt; Integer.compare(x, y);        例如：        String[] str = &#123;&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;&#125;;        List&lt;String&gt; list = new ArrayList&lt;&gt;();</code></pre><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a><code>函数式接口</code></h3><pre><code class="hljs plaintext">一、简介    1. 只包含一个抽象方法的接口，称为函数式接口。     2. 可以通过Lambda表达式来创建该接口的对象。（若Lambda表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明）。    3. 可以在任意函数式接口上使用@FunctionalInterface注解，可以检查它是否是一个函数式接口，同时javadoc也会包含一条声明，说明这个接口是一个函数式接口。二、自定义函数式接口    @FunctionalInterface    public interface MyFun&lt;T&gt;&#123;        public T getValue(T t);    &#125;    public String toUpperString(MyFun&lt;String&gt; mf, String str)&#123;        return mf.getValue(str);    &#125;    @Test    public void test()&#123;        String newStr = toUpperString((x) -&gt; str.toUpperCase, &quot;abcdeF&quot;);    &#125;</code></pre><pre><code class="hljs plaintext">Java8内置四大核心函数式接口    Consumer&lt;T&gt; 消费型接口        包含方法： void accept(T t)    Supplier&lt;T&gt; 供给型接口        包含方法：T get();    Function&lt;T, R&gt; 函数型接口        包含方法：R apply(T t);    Predicate&lt;T&gt; 断言型接口        包含方法：boolean test(T t)-------------------@Testpublic void test1()&#123;    happy(10000, (m) -&gt; System.out.println(&quot;团建每次消费：&quot; + m + &quot;元&quot;));&#125; public void happy(double money, Consumer&lt;Double&gt; con)&#123;    con.accept(money);&#125;@Testpublic void test2()&#123;    String newStr = strHandler(&quot;\t\t\t 函数型接口   &quot;, (str) -&gt; str.trim());    System.out.println(newStr);&#125;public String strHandler(String str, Function&lt;String, String&gt; fun)&#123;    return fun.apply(str);&#125;...</code></pre><h3 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a><code>方法引用与构造器引用</code></h3><pre><code class="hljs plaintext">方法引用：若Lambda体中的功能，已经有方法提供了实现，可以使用方法引用(可以将方法引用理解为Lambda表达式的另外一种表现形式)    对象::实例方法    类::静态方法    类::实例方法注意：    ①方法引用所引用的方法的参数列表与返回值类型，需要与函数式接口中抽象方法的参数列表和返回值类型保持一致！    ②若Lambda的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式： ClassName::MethodName------------------Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x);    等价于：Consumer&lt;String&gt; con = System.out::println;BinaryOperator&lt;Double&gt; bo = (x,y) -&gt; Math.pow(x,y);    等价于：BinaryOperator&lt;Double&gt; bo = Math::pow;BiPredicate&lt;String,String&gt; bp = (x,y) -&gt; x.equals(y);    等价于：BinaryOperator&lt;Double&gt; bo = String::equals;</code></pre><pre><code class="hljs plaintext">构造器引用：构造器的参数列表，需要与函数式接口中参数列表保持一致！    ClassName::new ------------------Function&lt;Integer,MyClass&gt; fun = (x) -&gt; new MyClass(x);    等价于：Function&lt;Integer,MyClass&gt; fun = Myclass::new;</code></pre><pre><code class="hljs plaintext">数组引用：    type[] :: new------------------Function&lt;Integer,String[]&gt; fun = (x) -&gt; new String[x];    等价于：Function&lt;Integer,String[]&gt; fun = String[]::new;</code></pre><h3 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a><code>Stream API</code></h3><pre><code class="hljs plaintext">一、简介：    Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。    通过操作Stream API,可以非常高效且方便对数据源进行查找、过滤和映射数据等操作。类似于写sql一样。二、注意：    Stream 自己不会存储元素。    Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。    Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。三、操作步骤：    1.创建 Stream        通过一个数据源（如：集合、数组），来获取一个流    2.中间操作        一个中间操作链，对数据源的数据进行处理     3.终止操作(终端操作)        通过一个终止操作，来执行中间操作链，并产生结果</code></pre><ul><li><em><strong>创建 Stream</strong></em></li></ul><pre><code class="hljs plaintext">1.使用Collection集合提供的stream()和parallelStream()     default Stream&lt;E&gt; stream() : 返回一个串行(顺序)流     default Stream&lt;E&gt; parallelStream() : 返回一个并行流2.使用Arrays类中的静态方法stream()获取数组流     static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流3.使用Stream类中的静态方法of(),通过显示值创建一个流,它可以接收任意数量的参数。     public static&lt;T&gt; Stream&lt;T&gt; of(T... values) : 返回一个流4.使用Stream类中的静态方法iterate()或者generate()创建无限流    迭代：public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)         eg：Stream&lt;Integer&gt; steram = Stream.iterate(0,(x) -&gt; x+2);    生成：public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)        eg：Stream&lt;Integer&gt; steram = Stream.generate(() -&gt; Math.random());</code></pre><ul><li><em><strong>中间操作</strong></em></li></ul><pre><code class="hljs plaintext">多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。------------------1.筛选与切片    filter(Predicate p)：接收Lambda，从流中排除某些元素。    limit(long maxSize)：截断流，使其元素不超过给定数量。    skip(long n)：跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n)互补。    distinct()：筛选，通过流所生成元素的hashCode()和equals()去除重复元素。2.映射(提取)    map(Function f)：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。        mapToDouble(ToDoubleFunction f)：接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream。         mapToInt(ToIntFunction f)：接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream。         mapToLong(ToLongFunction f)：接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream。    flatMap(Function f)：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。        注：map与flatMap类似于集合中的add和addAll之间的关系。3.排序    sorted()：产生一个新流，其中按自然顺序排序。    sorted(Comparator comp)：产生一个新流，其中按比较器顺序排序。</code></pre><ul><li><em><strong>终止操作</strong></em></li></ul><pre><code class="hljs plaintext">终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是void。------------------1.查找与匹配    allMatch(Predicate p)：检查是否匹配所有元素。    anyMatch(Predicate p)：检查是否至少匹配一个元素。    noneMatch(Predicate p)：检查是否没有匹配所有元素。    findFirst()：返回第一个元素。    findAny()：返回当前流中的任意元素。    count()：返回流中元素总数。    max(Comparator c)：返回流中最大值。    min(Comparator c)：返回流中最小值。    forEach(Consumer c)：内部迭代(使用Collection接口需要用户去做迭代，称为外部迭代。相反，Stream API使用内部迭代——它帮你把迭代做了)。2.归约    reduce(T iden, BinaryOperator b)：可以将流中元素反复结合起来，得到一个值。返回T     reduce(BinaryOperator b)：可以将流中元素反复结合起来，得到一个值。 返回 Optional&lt;T&gt;     注：map和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名。3.收集    collect(Collector c)：将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法。    注：Collector接口中方法的实现决定了如何对流执行收集操作(如收集到List、Set、Map)。但是Collectors实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：        List&lt;T&gt; toList  把流中元素收集到List            List&lt;Employee&gt; emps= list.stream().collect(Collectors.toList());         Set&lt;T&gt; toSet  把流中元素收集到Set            Set&lt;Employee&gt; emps= list.stream().collect(Collectors.toSet());         Collection&lt;T&gt; toCollection  把流中元素收集到创建的集合            Collection&lt;Employee&gt; emps =list.stream().collect(Collectors.toCollection(ArrayList::new));        Long counting  计算流中元素的个数            long count = list.stream().collect(Collectors.counting());         Integer summingInt  对流中元素的整数属性求和            int total=list.stream().collect(Collectors.summingInt(Employee::getSalary));         Double averagingInt  计算流中元素Integer属性的平均值             double avg= list.stream().collect(Collectors.averagingInt(Employee::getSalary));        IntSummaryStatistics summarizingInt  收集流中Integer属性的统计值。如：平均值             IntSummaryStatistics iss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary));        String joining  连接流中每个字符串             String str= list.stream().map(Employee::getName).collect(Collectors.joining());        Optional&lt;T&gt; maxBy  根据比较器选择最大值             Optional&lt;Emp&gt; max= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));         Optional&lt;T&gt; minBy  根据比较器选择最小值             Optional&lt;Emp&gt; min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));         归约产生的类型 reducing  从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值             int total=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum));         转换函数返回的类型 collectingAndThen  包裹另一个收集器，对其结果转换函数             int how= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));         Map&lt;K, List&lt;T&gt;&gt; groupingBy  根据某属性值对流分组，属 性为K，结果为V             Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus));         Map&lt;Boolean, List&lt;T&gt;&gt; partitioningBy  根据true或false进行分区             Map&lt;Boolean,List&lt;Emp&gt;&gt; vd= list.stream().collect(Collectors.partitioningBy(Employee::getManage));</code></pre><ul><li><em><strong>并行流与串行流</strong></em></li></ul><pre><code class="hljs plaintext">- 并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。- Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API可以声明性地通过parallel()与sequential()在并行流与顺序流之间进行切换。</code></pre><pre><code class="hljs plaintext">了解Fork/Join框架    Fork/Join 框架,就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行join汇总。Fork/Join框架与传统线程池的区别    采用 “工作窃取”模式（work-stealing）,        当执行新的任务时它可以将其拆分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。    相对于一般的线程池实现,fork/join框架的优势体现在对其中包含的任务的处理方式上,在一般的线程池中,如果一个线程正在执行的任务由于某些原因        无法继续运行,那么该线程会处于等待状态.而在fork/join框架实现中,如果某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子        问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间,提高了性能。</code></pre><hr><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Instant</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> Instant.now();        <span class="hljs-type">long</span> <span class="hljs-variable">reduce</span> <span class="hljs-operator">=</span> LongStream.rangeClosed(<span class="hljs-number">0L</span>, <span class="hljs-number">100000000000L</span>)                .parallel()                .reduce(<span class="hljs-number">0L</span>, Long::sum);        System.out.println(reduce);        <span class="hljs-type">Instant</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> Instant.now();        System.out.println(<span class="hljs-string">&quot;耗费时间:&quot;</span> + Duration.between(start, end).toMillis());    &#125;&#125;</code></pre><h3 id="接口中的默认方法与静态方法"><a href="#接口中的默认方法与静态方法" class="headerlink" title="接口中的默认方法与静态方法"></a><code>接口中的默认方法与静态方法</code></h3><ul><li>接口中的默认方法</li></ul><pre><code class="hljs plaintext">- Java 8中允许接口中包含具有具体实现的方法，该方法称为“默认方法”，默认方法使用default关键字修饰。- 接口默认方法的”类优先”原则    若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时,    1.选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。     2.接口冲突。如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突。</code></pre><ul><li>接口中的静态方法</li></ul><pre><code class="hljs plaintext">- Java8 中，接口中允许添加静态方法。静态方法使用static关键字修饰。</code></pre><h3 id="新时间日期-API"><a href="#新时间日期-API" class="headerlink" title="新时间日期 API"></a><code>新时间日期 API</code></h3><ul><li>LocalDate、LocalTime、LocalDateTime</li></ul><pre><code class="hljs plaintext">LocalDate、LocalTime、LocalDateTime类的实例是不可变的对象，分别表示使用ISO-8601日历系统的日期、时间、日期和时间。    它们提供了简单的日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法。</code></pre><pre><code class="hljs plaintext">now() 静态方法，根据当前时间创建对象     LocalDate localDate = LocalDate.now();     LocalTime localTime = LocalTime.now();     LocalDateTime localDateTime = LocalDateTime.now(); of() 静态方法，根据指定日期/时间创建对象     LocalDate localDate = LocalDate.of(2016, 10, 26);     LocalTime localTime = LocalTime.of(02, 22, 56);     LocalDateTime localDateTime = LocalDateTime.of(2016, 10, 26, 12, 10, 55);plusDays, plusWeeks, plusMonths, plusYears  向当前LocalDate对象添加几天、几周、几个月、几年minusDays, minusWeeks, minusMonths, minusYears  从当前LocalDate对象减去几天、几周、几个月、几年 plus, minus 添加或减少一个Duration或Period withDayOfMonth, withDayOfYear, withMonth, withYear  将月份天数、年份天数、月份、年份修改为指定的值并返回新的LocalDate对象---------getYear 获得年份 getMonthValue 获得月份(1-12)     getMonth 获得月份, 返回一个Month枚举值 getDayOfMonth 获得月份天数(1-31)     getDayOfYear 获得年份天数(1-366) getDayOfWeek 获得星期几(返回一个DayOfWeek枚举值) until 获得两个日期之间的 Period 对象，或者指定ChronoUnits的数字 isBefore, isAfter 比较两个LocalDateisLeapYear 判断是否是闰年</code></pre><ul><li>Instant</li></ul><pre><code class="hljs plaintext">用于“时间戳”的运算。它是以Unix元年(UTC时区1970年1月1日午夜时分)开始所经历的时间进行运算</code></pre><pre><code class="hljs plaintext">now() 静态方法，默认获取UTC时区</code></pre><ul><li>Duration、Period</li></ul><pre><code class="hljs plaintext">Duration:用于计算两个“时间”间隔    between(Temporal,Temporal)    toMillis()Period:用于计算两个“日期”间隔    between(LocalDate,LocalDate)    getYears    getMonths    getDays</code></pre><ul><li>日期的操纵</li></ul><pre><code class="hljs plaintext">TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。TemporalAdjusters : 该类通过静态方法提供了大量的常用TemporalAdjuster的实现。</code></pre><pre><code class="hljs plaintext">LocalDate nextSunday = LocalDate.now().with(TemporalAdjusters.next(DayOfWeek.FRIDAY));</code></pre><ul><li>解析与格式化</li></ul><pre><code class="hljs plaintext">java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：    预定义的标准格式    语言环境相关的格式    自定义的格式 ofPattern</code></pre><ul><li>时区的处理</li></ul><pre><code class="hljs plaintext">Java8 中加入了对时区的支持，带时区的时间为分别为：ZonedDate、ZonedTime、ZonedDateTime其中每个时区都对应着ID，地区ID都为“&#123;区域&#125;/&#123;城市&#125;”的格式,例如 ：Asia/Shanghai等----ZoneId类中包含了所有的时区信息    getAvailableZoneIds() : 可以获取所有时区时区信息    of(id) : 用指定的时区信息获取ZoneId对象例如指定时区构建时间：LocalDateTime now = LocalDateTime.now(ZoneId.of(&quot;Europe/Tallinn&quot;));</code></pre><h3 id="其他新特性"><a href="#其他新特性" class="headerlink" title="其他新特性"></a><code>其他新特性</code></h3><ul><li>Optional 类</li></ul><pre><code class="hljs plaintext">Optional&lt;T&gt; 类(java.util.Optional)是一个容器类，代表一个值存在或不存在。    原来用null表示一个值不存在，现在Optional可以更好的表达这个概念。并且可以避免空指针异常。</code></pre><pre><code class="hljs plaintext">常用方法：    Optional.of(T t) : 创建一个Optional实例    Optional.empty() : 创建一个空的Optional实例    Optional.ofNullable(T t) : 若t不为null,创建Optional实例,否则创建空实例    isPresent() : 判断是否包含值    orElse(T t) :  如果调用对象包含值，返回该值，否则返回t,类似mysql中的ifnull函数    orElseGet(Supplier s) : 如果调用对象包含值，返回该值，否则返回s获取的值    map(Function f) : 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty()    flatMap(Function mapper) : 与map类似，要求返回值必须是Optional</code></pre><ul><li>重复注解与类型注解</li></ul><pre><code class="hljs plaintext">Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。</code></pre><p><img src="/2019/03/30/dl-java-8/dl-java-8-001.png" alt="抱歉,图片休息了"> </p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 札记：基础</title>
      <link href="/2019/03/14/st-maven.html"/>
      <url>/2019/03/14/st-maven.html</url>
      
        <content type="html"><![CDATA[<h1 id="Maven-札记：基础"><a href="#Maven-札记：基础" class="headerlink" title="Maven 札记：基础"></a>Maven 札记：基础</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="maven是什么"><a href="#maven是什么" class="headerlink" title="maven是什么"></a><code>maven是什么</code></h3><pre><code class="hljs plaintext">Maven是Apache提供的一款跨平台的项目管理工具。主要服务于基于Java平台的项目构建，依赖管理和项目信息管理。    开发团队基本不用花多少时间就能自动完成工程的基础构建配置,因为maven使用了一个标准的目录结构和一个默认的构建生命周期。    采用了“约定大于配置”的设计理念，减少了配置和规范了工程结构。------------------什么是理想的项目构建？    高度自动化，跨平台，可重用的组件，标准化的什么是依赖？为什么要进行依赖管理？    自动下载，统一依赖管理有哪些项目信息？    项目名称描述等，开发人员信息，开发者信息等</code></pre><h3 id="为什么要用maven"><a href="#为什么要用maven" class="headerlink" title="为什么要用maven"></a><code>为什么要用maven</code></h3><pre><code class="hljs plaintext">IDE：    1. 手工操作较多，编译、测试、部署等工作都是独立的，很难一步完成    2. 每个人的IDE配置都不同，很容易出现本地代码换个地方编译就出错Ant：    1. 没有一个约定的目录结构    2. 必须明确让ant做什么，什么时候做，然后编译，打包    3. 没有生命周期，必须定义目标及其实现的任务序列    4. 没有集成依赖管理Maven：    1. 拥有约定的目录结构，知道你的代码在哪里，放到哪里去    2. 拥有一个生命周期，例如执行 mvn install 就可以自动执行编译，测试，打包等构建过程    3. 只需要定义一个pom.xml,然后把源码放到默认的目录，Maven帮你处理其他事情    4. 拥有依赖管理，仓库管理</code></pre><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a><code>安装与配置</code></h3><ol><li>确认当前系统正确的配置了JDK 环境变量 <pre><code class="hljs plaintext"># java -versionjava version &quot;1.8.0_91&quot;Java(TM) SE Runtime Environment (build 1.8.0_91-b15)Java HotSpot(TM) 64-Bit Server VM (build 25.91-b15, mixed mode)</code></pre></li><li>将Maven程序的压缩包解压到一个非中文无空格目录 <pre><code class="hljs plaintext">下载地址：    http://maven.apache.org/download.cgi安装目录介绍：    bin：含有mvn运行的脚本    boot：含有plexus-classworlds类加载器框架    conf：含有settings.xml配置文件    lib：含有Maven运行时所需要的java类库    LICENSE.txt, NOTICE.txt, README.txt针对Maven版本，第三方软件等简要介绍</code></pre></li><li>配置MAVEN_HOME或M2_HOME环境变量并添加到PATH中 <pre><code class="hljs plaintext">MAVEN_HOME=E:\Ebook\JavaSE\develop\apache-maven-3.0.5PATH=%MAVEN_HOME%\bin</code></pre></li><li>验证是否成功 <pre><code class="hljs plaintext">C:\Users\Tujide.lv&gt;mvn -vApache Maven 3.0.5 (r01de14724cdef164cd33c7c8c2fe155faf9602da; 2013-02-19 21:51:28+0800)Maven home: E:\Ebook\JavaSE\develop\apache-maven-3.0.5\bin\..Java version: 1.8.0_91, vendor: Oracle CorporationJava home: E:\Ebook\JavaSE\develop\Java\jdk1.8.0_91\jreDefault locale: zh_CN, platform encoding: GBKOS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;dos&quot;</code></pre></li><li>修改本地仓库的默认位置 <pre><code class="hljs plaintext">1. 修改E:\Ebook\JavaSE\develop\apache-maven-3.0.5\conf\settings.xml文件    &lt;localRepository&gt;E:\Ebook\JavaSE\workspace_maven\repository&lt;/localRepository&gt;2. 复制此文件到E:\Ebook\JavaSE\workspace_maven中    用户级别的仓库在全局配置中一旦设置，全局配置将不再生效，转用用户所设置的仓库，否则使用默认路径仓库</code></pre></li></ol><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a><code>项目结构</code></h3><pre><code class="hljs plaintext">src    main        java —— 存放项目的.java文件        resources —— 存放项目资源文件，如spring, hibernate配置文件        webapp —— web工程有    test        java —— 存放所有测试.java文件。类名必须以Test开头以及方法名以test开头。如果采用junit此约定失效而执行junit方法。        resources —— 存放测试资源文件target —— 运行会自动创建,项目输出位置pom.xml —— maven项目核心配置文件</code></pre><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a><code>核心概念</code></h3><ul><li>坐标  <pre><code class="hljs plaintext">Maven坐标主要组成    groupId：组织名称,定义当前Maven项目隶属项目    artifactId：项目名称,定义实际项目中的一个模块    version： 当前项目版本号,定义当前项目的当前版本    packaging：定义该项目的打包方式,jar或war,可省略。另外，值为pom时，表示这是一个父工程Maven为什么使用坐标？    Maven世界拥有大量构建，我们需要找一个用来唯一标识一个构建的统一规范    拥有了统一规范，就可以把查找工作交给机器</code></pre></li><li>依赖管理<br>  <img src="/2019/03/14/st-maven/st-maven-001.png" alt="抱歉,图片休息了"><br>  <img src="/2019/03/14/st-maven/st-maven-002.png" alt="抱歉,图片休息了">   <pre><code class="hljs plaintext">传递性依赖：    例如B中使用A,C中使用B,则称B是C的直接依赖,A是C的间接依赖可选依赖：    &lt;optional&gt;true/false&lt;/optional&gt; 设置自己的依赖是否向下传递排除依赖：    &lt;exclusions&gt;&lt;exclusion&gt; 设置当前依赖中是否使用间接依赖--------------依赖冲突：    如果直接与间接依赖中包含有同一个坐标不同版本的资源依赖，以直接依赖的版本为准（就近原则）    如果直接依赖中包含有同一个坐标不同版本的资源依赖，以配置顺序下方的版本为准（就近原则）</code></pre></li><li>生命周期  <pre><code class="hljs plaintext">Maven生命周期就是为了对所有的构建过程进行抽象和统一包括清理，编译，测试，报告，打包，安装，部署等几乎所有构建步骤    清理(mvn clean)：表示在编译代码前将之前生成的内容删除    编译(mvn compile)：将源代码编译为字节码    测试(mvn test)：运行单元测试用例程序    报告：测试程序的结果    打包(mvn package)：将 java 项目打成 jar 包；将 Web 项目打成 war 包    安装(mvn install)：将 jar 或 war 生成到 Maven 本地仓库中     部署(mvn deploy)：将 jar 或 war 从Maven 本地仓库复制到远程仓库中,以让其他开发人员与项目共享</code></pre>  <img src="/2019/03/14/st-maven/st-maven-003.png" alt="抱歉,图片休息了"> </li><li>插件和目标  <pre><code class="hljs plaintext">Maven的核心程序并不包含具体功能，仅定义了抽象的生命周期来负责宏观调度。具体功能由插件来完成。    Maven核心程序会到本地仓库中查找插件。如果本地仓库中没有就会从远程中央仓库下载。此时如果不能上网则无法执行Maven的具体功能。    为了解决这个问题，我们可以将Maven的本地仓库指向一个在联网情况下下载好的目录。 每个插件都能实现多个功能，每个功能就是一个插件目标Maven的生命周期与插件目标相互绑定，以完成某个具体的构建任务    例如compile就是插件maven-compiler-plugin的一个插件目标</code></pre>  <pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-comment">&lt;!--将源码打包的功能--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-source-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><span class="hljs-comment">&lt;!--设置插件的的执行位置 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><span class="hljs-comment">&lt;!--具体的的执行位置 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>jar-no-fork<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>verify<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>             <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></li><li>继承  <pre><code class="hljs plaintext">何为继承？    继承为了消除重复，把很多相同的配置提取出来    例如：grouptId，version等父工程设置为被继承    &lt;packaging&gt;pom&lt;/packaging&gt;子工程继承父工程    子工程中可以省略父工程中定义的坐标(artifactId除外)中的所有设定        &lt;parent&gt;        &lt;groupId&gt;…&lt;/groupId&gt;        &lt;artifactId&gt;… &lt;/artifactId&gt;        &lt;version&gt;… &lt;/version&gt;        &lt;relativePath&gt;../父工程项目名&lt;/relativePath&gt;    ----如果网络仓库上有父工程,这行可不写上    &lt;/parent&gt;</code></pre>  <pre><code class="hljs plaintext">父工程统一管理子工程依赖版本    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            //添加公共依赖包        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    子工程仅仅添加依赖包，无需添加版本，版本由父工程继承而来    为了进一步便于管理，将所有的版本管理设置在一起，设置为系统属性值    &lt;properties&gt;        &lt;junit.version&gt;4.9&lt;/junit.version&gt;        ……    &lt;/properties&gt;    引用使用$&#123;junit.version&#125;格式进行，只能在依赖范围设置父工程统一管理子工程依赖关系    如果所有子工程都需要依赖某些包，父工程可以通过设置依赖，将依赖关系传递到子工程中    &lt;dependencies&gt;        //添加公共依赖包    &lt;/dependencies&gt;</code></pre></li><li>聚合  <pre><code class="hljs plaintext">何为聚合？    如果我们想一次对多个项目模块进行快速构建，那我们就需要对多个项目模块进行聚合    &lt;modules&gt;        &lt;module&gt;../子项目名称1&lt;/module&gt;        &lt;module&gt;../子项目名称2&lt;/module&gt;         &lt;module&gt;../子项目名称3&lt;/module&gt;    &lt;/modules&gt;</code></pre></li><li>仓库管理  <pre><code class="hljs plaintext">何为Maven仓库？    用来统一存储所有Maven共享构建的位置Maven仓库布局    根据Maven坐标定义每个构建在仓库中唯一存储路径    大致为：groupId/artifactId/version/artifactId-version.packaging仓库的分类    本地仓库        每个用户只有一个本地仓库,默认在~/.m2/repository/    远程仓库        中央仓库：Maven默认的远程仓库，不包含版权资源            http://repo1.maven.org/maven2            http://repo2.maven.org/maven2        私服：是一种特殊的远程仓库，它是架设在局域网内的仓库            例如nexus</code></pre></li></ul><h3 id="Maven私服"><a href="#Maven私服" class="headerlink" title="Maven私服"></a><code>Maven私服</code></h3><ul><li>nexus私服搭建  <pre><code class="hljs plaintext">1.下载nexus.war包，然后拷贝到tomcat下的webapps目录中2.启动tomcat,并访问http://localhost:8080/nexus/3.点击右上角“log in”，输入username：admin 和Password：admin123登录4.点击Views/Repositories 中的Repositories    Nexus内置仓库说明：        （1）Central：该仓库代理Maven中央仓库，其策略为Release，因此只会下载和缓存中央仓库中的发布版本构件。        （2）Releases：这是一种策略为Release的宿主类型仓库，用来部署组织内部的发布版本构件。        （3）Snapshots：这是一个策略为Snapshot的宿主类型仓库，用来部署组织内部的快照版本构件。        （4）3rd party：这是一个策略为Release的宿主类型仓库，用来部署无法从公共仓库获得的第三方发布版本构件。例如oracel的驱动jar。        （5）Public Repositories：该仓库组将上述所有策略为Release的仓库聚合并通过一致的地址提供服务。5.创建宿主仓库和代理仓库    Hosted：宿主仓库，通常我们会部署自己的构件到这一类型的仓库。         包括3rd party仓库，Releases仓库，Snapshots仓库    Proxy：代理仓库，它们被用来代理远程的公共仓库，如maven中央仓库。     Group：仓库组，用来合并多个hosted/proxy仓库，通常我们配置maven依赖仓库组。6.创建仓库组    点击Public Repositories仓库，在Configurations栏中选取需要合并的仓库,点击箭头加到左边保存即可7.下载中央仓库Index索引并进行构建搜索（GAV搜索）    可自动下载,也可手动添加索引    拷贝indexer.zip/central-ctx目录下的的所有文件覆盖到~/sonatype-work/nexus/indexer/central-ctx下</code></pre></li><li>nexus私服相关配置<ol><li>配置所有构建均从私服下载(即本地仓库与nexus进行关联)，setting.xml(2个都要改)中配置如下 <pre><code class="hljs plaintext">方法1：    &lt;mirrors&gt;&lt;!--私服策略--&gt;        &lt;mirror&gt;            &lt;id&gt;alimaven&lt;/id&gt;            &lt;name&gt;aliyun maven&lt;/name&gt;            &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;!--此处配置所有的构建均从私有仓库中下载 *代表所有，也可以写central --&gt;            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;        &lt;/mirror&gt;        &lt;mirror&gt;            &lt;id&gt;repo2&lt;/id&gt;            &lt;name&gt;repo2 maven&lt;/name&gt;            &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;            &lt;url&gt;http://repo2.maven.org/maven2&lt;/url&gt;        &lt;/mirror&gt;    &lt;/mirrors&gt;方法2：    &lt;profiles&gt;        &lt;profile&gt;            &lt;id&gt;nexus&lt;/id&gt;            &lt;!—所有请求均通过镜像 --&gt;            &lt;repositories&gt;                &lt;repository&gt;                    &lt;id&gt;central&lt;/id&gt;                    &lt;url&gt;&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;                    &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;                    &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;                &lt;/repository&gt;            &lt;/repositories&gt;            &lt;pluginRepositories&gt;                &lt;pluginRepository&gt;                    &lt;id&gt;central&lt;/id&gt;                    &lt;url&gt;&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;                    &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;                    &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;                &lt;/pluginRepository&gt;            &lt;/pluginRepositories&gt;        &lt;/profile&gt;    &lt;/profiles&gt;    &lt;activeProfiles&gt;&lt;!--配置激活,指定profile才生效起作用--&gt;        &lt;activeProfile&gt;nexus&lt;/activeProfile&gt;    &lt;/activeProfiles&gt;</code></pre></li><li>(如项目不上传到私服可省略)部署构建到Nexus，包含Release和Snapshot， 一般在父工程中的根目录pom.xml中配置 <pre><code class="hljs plaintext">&lt;distributionManagement&gt; &lt;repository&gt;     &lt;id&gt;releases&lt;/id&gt;     &lt;name&gt;Internal Releases&lt;/name&gt;     &lt;url&gt;http://localhost:8000/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt;     &lt;id&gt;snapshots&lt;/id&gt;     &lt;name&gt;Internal Snapshots&lt;/name&gt;     &lt;url&gt;http://localhost:8000/nexus/content/repositories/snapshots/&lt;/url&gt;     &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt;</code></pre></li><li>(如不进行步骤2可省略)Nexus的访问权限控制，在setting.xml(2个都要改)中配置如下 <pre><code class="hljs plaintext">&lt;servers&gt; &lt;server&gt; &lt;id&gt;releases&lt;/id&gt;        &lt;username&gt;admin&lt;/username&gt;        &lt;password&gt;admin123&lt;/password&gt;    &lt;/server&gt;    &lt;server&gt;        &lt;id&gt;snapshots&lt;/id&gt;        &lt;username&gt;admin&lt;/username&gt;        &lt;password&gt;admin123&lt;/password&gt;    &lt;/server&gt;&lt;/servers&gt;</code></pre></li></ol></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件之 RocketMQ</title>
      <link href="/2019/03/10/af-mq-rocketmq.html"/>
      <url>/2019/03/10/af-mq-rocketmq.html</url>
      
        <content type="html"><![CDATA[<h1 id="消息中间件之-RocketMQ"><a href="#消息中间件之-RocketMQ" class="headerlink" title="消息中间件之 RocketMQ"></a>消息中间件之 RocketMQ</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>整理下学习RoctetMQ时的知识点.</p><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><h3 id="简介及历史"><a href="#简介及历史" class="headerlink" title="简介及历史"></a><code>简介及历史</code></h3><ul><li>什么是RocketMQ  <pre><code class="hljs plaintext">阿里开源的用 java 编写的以队列为模型的分布式消息中间件，具有高可用、高吞吐量等特点。- 消息    - 消息即为数据，数据就会有规则，有长度，有大小。    - 标准JMS（JSR914）：https://www.jcp.org/en/jsr/detail?id=914- 中间件    - 为我们提供发送消息的程序或者服务。    - 主流的有： RocketMQ(没有严格遵循jms规范)、 Kafka、ActiveMQ（严格遵循jms规范）、RabbitMQ、zeroMQ</code></pre></li><li>为什么要用消息中间件<br>  <img src="/2019/03/10/af-mq-rocketmq/af-mq-rocketmq-001.png" alt="抱歉,图片休息了"> </li><li>为什么选择 RocketMQ  <pre><code class="hljs plaintext">1. 稳定无单点故障,原生支持分布式,不会因为某台机器或者某个节点宕机而影响系统正常使用2. 可严格保证消息的顺序性3. 经历过双十一4. java语言实现,java版本的kafka5. 架构轻,分布式协调采用NameServer来代替了Zookeeper6. 开源社区活跃</code></pre></li><li>发展历史  <pre><code class="hljs plaintext">1. 2007年，淘宝实施了“五彩石”项目，“五彩石”用于将交易系统从单机变成分布式，也是在这个过程中产生了阿里巴巴第一代消息引擎——Notify。2. 2010年，阿里巴巴B2B部门基于ActiveMQ的5.1版本也开发了自己的一款消息引擎，称为Napoli。    这款消息引擎在B2B里面广泛地被使用，不仅仅是在交易领域，在很多的后台异步解耦等方面也得到了广泛的应用。3. 2011年，业界出现了现在被很多大数据领域所推崇的Kafka消息引擎，阿里巴巴在研究了Kafka的整体机制和架构设计之后，基于Kafka的设计使用Java进行了完全重写并推出了MetaQ 1.0版本。    主要是用于解决顺序消息和海量堆积的问题。4. 2012年，阿里巴巴对MetaQ进行了架构重组升级，开发出了MetaQ 2.0，这时就发现MetaQ原本基于Kafka的架构在阿里巴巴如此庞大的体系下很难进行水平扩展，所以在2012年的时候就开发了RocketMQ 3.0版本。    RocketMQ 3.0和MetaQ 3.0这两者是等价的版本，只不过阿里内部使用的称为MetaQ 3.0，外部开源称之为RocketMQ 3.0。5. 2015年，又基于RocketMQ开发了阿里云上的Aliware MQ和Notify 3.0。    MetaQ主要使用了拉模型，解决了顺序消息和海量堆积问题。    Notify主要使用了推模型，解决了事务消息。    Aliware MQ则是提供了商业化的版本。6. 2016年，阿里巴巴将RocketMQ的内核引擎捐赠给了Apache基金会。</code></pre></li></ul><h3 id="JMS基本概念及使用"><a href="#JMS基本概念及使用" class="headerlink" title="JMS基本概念及使用"></a><code>JMS基本概念及使用</code></h3><ul><li>JMS全称<code>Java消息服务(Java Message Service)</code>，是Java平台上有关面向MOM的技术规范,旨在提供标准的生产、发布、订阅和消费消息的API简化企业应用的开发。<ul><li>类似于JDBC和关系型数据通信方式的抽象。</li></ul></li><li>JMS提供的元素  <pre><code class="hljs plaintext">Provider提供方：服务提供者Producer生产者：生产和发布JMS消息的客户端Consumer消费者：订阅和消费JMS消息的客户端Client客户端：生产或订阅消息的基于Java的应用&amp;进程Message消息：服务端与客户端之间的传输数据对象Queue队列 ：包含待读取消息的准备区域（点对点）Topic主题：发布消息的分布机制（发布&amp;订阅）Destination：消息被寻址,发送以及接受的对象</code></pre></li><li>JMS消息的组成  <pre><code class="hljs plaintext">消息头：提供消息的接受端和发送端两个客户端和JMS规范的元数据,JMS消息的复杂性在这里    1. 由JMS规范提供的，客户端调用send()方法时，自动设置的消息头。        JMSDestination：            JMS发送消息的目的地。这对于使用来自多个目的地的消息的客户端很有价值。            相关方法：public abstract Destination getJMSDestination()        JMSDeliveryMode：            JMS传送模式。支持两种模式：持久模式和非持久模式。默认的传递模式是持久。            相关方法：public abstract int getJMSDeliveryMode()        JMSMessageID：            JMS消息ID。它是一个String类型的值，唯一标识了一条消息，并且必须以ID开头。            相关方法：public abstract String getJMSMessageID()        JMSTimestamp：            JMS时间戳。它包含的是JMS提供者接受消息的时间，而不是该消息实际传送的时间。这条消息头用于确认发送消息和它被消费者实际接受的时间间隔。            相关方法：public abstract long getJMSTimestamp()        JMSExpiration：            JMS消息的超时时间。这个头信息被用来阻止过期消息的传递。对于那些数据仅在某一个时间段内有效的消息来说，非常有用的。            相关方法：public abstract long getJMSExpiration()        JMSRedelivered：            JMS重发。表示该消息将被重新传送给消费者。如果该消息被重新传送，JMSRedelivered消息头就为true，否则为false。            相关方法：public abstract boolean getJMSRedelivered()        JMSPriority：            JMS优先级。在传送一条消息时，消息生产者能够为该消息分配一个优先级。            相关方法：public abstract int getJMSPriority()    2. 开发者分配的消息头。        JMSReplyTo：            JMS响应。一个JMS消息生产者可能会要求消费者对一条消息作出应答,JMSReplyTo消息头包含了一个javax.jms.Destination，表明JMS消费者应该应答的地址。            相关方法：public abstract Destination getJMSReplyTo()。        JMSCorrelationID：            JMS关联ID。提供了一个消息头，用于将当前的消息和先前的某些消息或应用程序特定的ID关联起来，这个消息头通常用于将响应消息与请求消息。            相关方法：public abstract String getJMSCorrelationID()。        JMSType：            JMS类型。用于语义标识消息类型，是由JMS客户端设置的一个可选消息头。它的主要作用是标示消息结构和有效负载的类型。            相关方法：public abstract String getJMSType()。消息属性：消息属性就像可以分配一条消息的附加消息头一样。它们允许开发者添加有关消息的不透明附加消息。它们还用于暴露消息选择器在消息过滤时使用的数据。    1. 应用程序特定的属性    2. JMS定义的属性    3. 提供者特定的属性消息体：消息的实际内容，JMS为消息体定义了六种类型载体,通过这个类型,你可以发送各种各样的数据。    1. StreamMessage：Java原始类型的流数据    2. MapMessage：key-value键值队作为数据载体。key一般使用字符串，value可以为Java原始类型。    3. TextMessage：文本消息、字符串数据载体,一般用来发送简单的文本,XML数据    4. ObjectMessage：序列化后的完整Java类。包括使用复杂Java类型。也支持集合    5. BytesMessage：使用一个二进制数据来做数据载体。    6. Message：最基础的消息体，没有数据载体。仅仅包含了消息体和属性，一般用做简单的时间通知。</code></pre></li><li>JMS消息模型(消息传递方式)  <pre><code class="hljs plaintext">点对点(P2P)：    使用queue作为Destination,消息可被同步或异步的发送和接受,每个消息只会给一个Consumer传送一次。发布/订阅(Pub/Sub)：    使用topic作为Destination,发布者向topic发送消息,订阅者接受来自topic的消息,发送到topic的任何消息都将自动传递给所有订阅者。</code></pre>  <img src="/2019/03/10/af-mq-rocketmq/af-mq-rocketmq-002.png" alt="抱歉,图片休息了"> </li><li>使用API创建一个应用程序的通用步骤  <pre><code class="hljs plaintext">1. 获取链接工厂ConnectionFactory2. 使用链接工厂创建连接Connection3. 启动连接并创建会话Session4. 获取Destination5. 创建Poducer或者Consumer6. 发送或者接收message7. 关闭资源</code></pre></li></ul><h3 id="特性介绍"><a href="#特性介绍" class="headerlink" title="特性介绍"></a><code>特性介绍</code></h3><ul><li>官网：<a href="http://rocketmq.apache.org/">http://rocketmq.apache.org/</a></li><li>Github: <a href="https://github.com/apache/rocketmq">https://github.com/apache/rocketmq</a></li></ul><hr><ul><li>基础特性  <pre><code class="hljs plaintext">1. 支持发布/订阅（Pub/Sub）和点对点（P2P）消息模型2. 在一个队列中可靠的先进先出（FIFO）和严格的顺序传递3. 支持拉（pull）和推（push）两种消息模式4. 单一队列百万消息的堆积能力5. 支持多种消息协议，如 JMS、MQTT 等7. 分布式高可用的部署架构,满足至少一次消息传递语义8. 提供docker镜像用于隔离测试和云集群部署9. 提供配置、指标和监控等功能丰富的Dashboard</code></pre></li><li>相关术语  <pre><code class="hljs plaintext">- Message    消息的载体。一个Message必须指定topic，相当于寄信的地址。    Message还有一个可选的tag设置，以便消费端可以基于tag进行过滤消息。也可以添加额外的键值对，例如你需要一个业务key来查找broker上的消息，方便在开发过程中诊断问题。- Message Queue    可以认为是一个长度无限的数组,offset就是下标。一个Topic下可以有多个Queue，Queue的引入使得消息存储可以分布式集群化，具有了水平扩展的能力。- Producer    消息生产者，负责产生消息，一般由业务系统负责产生消息。- Producer Group    生产者组，这类Producer通常发送一类消息，且发送逻辑一致。发送同一类消息的多个producer实例组成一个生产者组。    可以是多台机器，也可以是一台机器的多个进程。- Consumer    消息消费者，负责消费消息，一般是后台系统负责异步消费。- Consumer Group    消费者组，这类Consumer通常消费一类消息，且消费逻辑一致。消费同一类消息的多个consumer实例组成一个消费者组。    可以是多台机器，也可以是一台机器的多个进程。- Topic    消息主题(逻辑分类)，比如说你有订单类的消息，也有库存类的消息，那么就需要进行分类，一个是订单Topic存放订单相关的消息，一个是库存Topic存储库存相关的消息。- Tag    消息标签，可以被认为是对Topic进一步细化。一般在相同业务模块中通过引入标签来标记不同用途的消息。- Broker    消息中转角色，负责接收、存储、转发消息，一般也称为Server，在JMS规范中称为Provider。- Name Server    服务发现Server，用于生产者和消费者获取Broker路由信息的服务。</code></pre></li><li>概念模型&amp;部署模型  <pre><code class="hljs plaintext">Name Server：    1. NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步（类似ZK）。    2. NameServer用于存储Topic、Broker关系信息，功能简单，稳定性高。        多个NameServer之间相互没有通信，单台NameServer宕机不影响其他NameServer与集群。        即使整个NameServer集群宕机，已经正常工作的Producer，Consumer，Broker仍然能正常工作，但新起的Producer, Consumer，Broker就无法工作。    3. NameServer压力不会太大，平时主要开销是在维持心跳和提供Topic-Broker的关系数据。        但有一点需要注意，Broker向NameServer发心跳时，会带上当前自己所负责的所有Topic信息，如果Topic个数太多（万级别），        会导致一次心跳中，就Topic的数据就几十M，网络情况差的话，网络传输失败，心跳失败，导致NameServer误认为Broker心跳失败。Broker：    1. Broker 部署相对复杂，Broker分为Master 与 Slave，一个Master可以对应多个 Slave，但是一个Slave只能对应一个Master。    2. Master 与 Slave 的对应关系通过指定相同的BrokerName，不同的 BrokerId 来定义，BrokerId为0表示Master，非 0 表示 Slave。    3. Master可以部署多个。每个Broker与NameServer 集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。    4. producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer：    1. Producer 完全无状态，可集群部署。    2. Producer启动时，也需要指定NameServer的地址，从NameServer集群中选一台建立长连接。如果该NameServer宕机，会自动连其他NameServer。直到有可用的NameServer为止。    3. Producer每30秒从NameServer获取Topic跟Broker的映射关系，更新到本地内存中。        再跟Topic涉及的所有Broker建立长连接，每隔30秒发一次心跳。        在Broker端也会每10秒扫描一次当前注册的Producer，如果发现某个Producer超过2分钟都没有发心跳，则断开连接。    4. Producer发送时，会自动轮询当前所有可发送的broker，一条消息发送成功，下次换另外一个broker发送，以达到消息平均落到所有的broker上。    5. 假如某个Broker宕机，意味生产者最长需要30秒才能感知到。在这期间会向宕机的Broker发送消息。        当一条消息发送到某个Broker失败后，会往该broker自动再重发2次，假如还是发送失败，则抛出发送失败异常。业务捕获异常，重新发送即可。        客户端里会自动轮询另外一个Broker重新发送，这个对于用户是透明的。Consumer：    1. Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向 Master、Slave发送心跳。    2. Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。    3. Consumer启动时需要指定NameServer地址，与其中一个NameServer建立长连接。        消费者每隔30秒从NameServer获取所有Topic的最新队列情况，这意味着某个Broker如果宕机，客户端最多要30秒才能感知。        连接建立后，从NameServer中获取当前消费Topic所涉及的Broker，直连Broker。    4. Consumer跟Broker是长连接，会每隔30秒发心跳信息到Broker。        Broker端每10秒检查一次当前存活的Consumer，若发现某个Consumer 2分钟内没有心跳，就断开与该Consumer的连接，并且向该消费组的其他实例发送通知，触发该Consumer集群的负载均衡。</code></pre>  <img src="/2019/03/10/af-mq-rocketmq/af-mq-rocketmq-003.png" alt="抱歉,图片休息了"><br>  <img src="/2019/03/10/af-mq-rocketmq/af-mq-rocketmq-004.png" alt="抱歉,图片休息了"></li><li>RocketMQ高可用</li></ul><hr><table><thead><tr><th align="left">情况</th><th align="left">发送消息</th><th align="left">存储消息</th><th align="left">接收消息</th></tr></thead><tbody><tr><td align="left">停掉一个namesrv</td><td align="left">不受影响</td><td align="left">不受影响</td><td align="left">不受影响</td></tr><tr><td align="left">停掉全部namesrv</td><td align="left">受影响</td><td align="left">不受影响</td><td align="left">受影响</td></tr><tr><td align="left">停掉单个master broker</td><td align="left">不受影响</td><td align="left">受影响(很小)</td><td align="left">不受影响</td></tr><tr><td align="left">停掉全部master broker</td><td align="left">受影响</td><td align="left">受影响</td><td align="left">受影响</td></tr><tr><td align="left">停掉全部salve broker</td><td align="left">不受影响</td><td align="left">不受影响</td><td align="left">不受影响</td></tr><tr><td align="left">恢复任意master broker</td><td align="left">不受影响</td><td align="left">受影响(很小)</td><td align="left">不受影响</td></tr></tbody></table><ul><li>消息发布  <pre><code class="hljs plaintext">producer将消息发送给Broker时，会轮询的将消息发送到每个队列中（所有broker下的Queue合并成一个List去轮询）,来实现发送方的负载均衡。</code></pre></li><li>消息存储  <pre><code class="hljs plaintext">RocketMQ的消息的存储是由Consume Queue和Commit Log配合来完成的。    Consume Queue中只存储很少的数据，消息主体都是通过Commit Log来进行读写。Consume Queue：    消息的逻辑队列，相当于字典的目录，用来指定消息在物理文件commit log上的位置。    存储了这个Queue在Commit Log中的起始offset，log大小和MessageTag的hashCode。    每个Topic下的每个Queue都有一个对应的ConsumeQueue文件，默认位置如下，仍然可通过配置文件修改：$&#123;rocketmq.home&#125;/store/consumequeue/$&#123;topicName&#125;/$&#123;queueId&#125;/$&#123;fileName&#125;    ---------------------    1. 根据topic和queueId来组织文件,TopicA和QueueId=0组成一个ConsumeQueue,TopicA和QueueId=1组成另-个ConsumeQueue    2. 按照消费端的GroupName来分组重试队列，如果消费端消费失败，消息将被发往重试队列中，比如图中的%RETRY%ConsumerGroupA    3. 按照消费端的GroupName来分组死信队列，如果消费端消费失败，并重试指定次数后，仍然失败，则发往死信队列，比如图中的%DLQ%ConsumerGroupA        注：死信队列（Dead Letter Queue）一般用于存放由于某种原因无法传递的消息，比如处理失败或者已经过期的消息。    4. Consume Queue文件中的存储单元是一个20字节定长的二进制数据，顺序写顺序读,包括        CommitLog Offset：8 Byte,存储这条消息在Commit Log文件中的实际偏移量        Size：4 Byte,存储消息的大小        Message Tag HashCode：8 Byte,存储消息的Tag的哈希值，主要用于订阅时消息过滤（订阅时如果指定了Tag，会根据HashCode来快速查找到订阅的消息）Commit Log：    消息存放的物理文件，每台broker上的commitlog被本机所有的queue共享，不做任何区分。    文件的默认位置如下，仍然可通过配置文件修改：$&#123;user.home&#125; \store\$&#123;commitlog&#125;\$&#123;fileName&#125;    ---------------------    1. CommitLog文件中的存储单元长度不固定，文件顺序写，随机读。按照顺序以及编号对应的内容依次存储。Consumer消费消息过程中使用了零拷贝中的mmap+write方式,因为有小块数据传输的需求，效果会比 sendfile 更好。    1. 使用 mmap + write 方式        优点：即使频繁调用，使用小块文件传输，效率也很高。        缺点：不能很好的利用DMA方式，会比sendfile多消耗CPU，内存安全性控制复杂，需要避免JVM Crash问题。    2. 使用 sendfile 方式        优点：可以利用DMA方式，消耗CPU较少，大块文件传输效率高，无内存安全新问题。        缺点：小块文件效率低于mmap方式，只能是BIO方式传输，不能使用NIO。</code></pre>  <pre><code class="hljs plaintext">RocketMQ存储目录结构|-- abort |-- checkpoint |-- config| |-- consumerOffset.json| |-- consumerOffset.json.bak| |-- delayOffset.json| |-- delayOffset.json.bak| |-- subscriptionGroup.json.bak| |-- topics.json| |-- topics.json.bak |-- commitlog| |-- 00000003384434229248| |-- 000000033855079710| |-- 0000000338658171289|-- consumequeue  |-- %DLQ%ConsumerGroupA  | |-- 0  | | |-- 00000000000006000000  |-- %RETRY%ConsumerGroupA  | |-- 0  | | |-- 00000000000000000000  |-- %RETRY%ConsumerGroupB  | |-- 0  | | |-- 00000000000000000000  |-- SCHEDULE_TOPIC_XXXX  | |-- 2  | | |-- 00000000000006000000  | |-- 3  | | |-- 00000000000006000000  |-- TopicA  | |-- 0  | | |-- 00000000002604000000  | | |-- 00000000002610000000  | | |-- 00000000002616000000  | |-- 1  | | |-- 00000000002610000000  | | |-- 00000000002610000000  |-- TopicB  | |-- 0  | | |-- 00000000000732000000  | |-- 1  | | |-- 00000000000732000000  | |-- 2  | | |-- 00000000000732000000</code></pre>  <pre><code class="hljs plaintext">RocketMQ消息存储实现// Set the storage timemsg.setStoreTimestamp(System.currentTimeMillis());// Set the message body BODY CRC (consider the most appropriate settingmsg.setBodyCRC(UtilAll.crc32(msg.getBody()));StoreStatsService storeStatsService = this.defaultMessageStore.getStoreStatsService();synchronized (this) &#123;    long beginLockTimestamp = this.defaultMessageStore.getSystemClock().now();    // Here settings are stored timestamp, in order to ensure an orderly global    msg.setStoreTimestamp(beginLockTimestamp);    // MapedFile：操作物理文件在内存中的映射以及将内存数据持久化到物理文件中    MapedFile mapedFile = this.mapedFileQueue.getLastMapedFile();    // 将Message追加到文件commitlog    result = mapedFile.appendMessage(msg, this.appendMessageCallback);    switch (result.getStatus()) &#123;    case PUT_OK:break;    case END_OF_FILE:         // Create a new file, re-write the message         mapedFile = this.mapedFileQueue.getLastMapedFile();         result = mapedFile.appendMessage(msg, this.appendMessageCallback);     break;     DispatchRequest dispatchRequest = new DispatchRequest(                topic,// 1                queueId,// 2                result.getWroteOffset(),// 3                result.getWroteBytes(),// 4                tagsCode,// 5                msg.getStoreTimestamp(),// 6                result.getLogicsOffset(),// 7                msg.getKeys(),// 8                /**                 * Transaction                 */                msg.getSysFlag(),// 9                msg.getPreparedTransactionOffset());// 10    // 1.分发消息位置到ConsumeQueue    // 2.分发到IndexService建立索引    this.defaultMessageStore.putDispatchRequest(dispatchRequest);&#125;</code></pre></li><li>消息订阅  <pre><code class="hljs plaintext">RocketMQ消息订阅有两种模式，一种是Push模式，即MQServer主动向消费端推送；另外一种是Pull模式，即消费端在需要时，主动到MQServer拉取。    但在具体实现时，Push和Pull模式都是采用消费端主动拉取的方式。</code></pre></li><li>刷盘策略&amp;复制策略  <pre><code class="hljs plaintext">刷盘策略：    异步刷盘：ASYNC_FLUSH        消息被写入内存pagecache后，立即返回消息写成功的状态，吞吐量大；当内存里的消息积累到一定程度时，统一发出写磁盘动作，快速写入。    同步刷盘：SYNC_FLUSH        消息被写入内存pagecache后，线程等待,立即通知刷盘线程，刷盘完成后，唤醒等待线程,返回消息写成功的状态，此时消息已经被写入磁盘。</code></pre>  <pre><code class="hljs plaintext">复制策略：    异步复制：ASYNC_MASTER        只要master写成功就返回成功状态。好处是低延迟、高吞吐，缺点是如果master出故障，数据没有写入slave，就会有丢失。    同步复制(双写)：SYNC_MASTER        master和slave都写成功后返回成功状态。好处是如果master出故障，slave上有全部备份，容易恢复。缺点是增大延迟，降低吞吐量。</code></pre>  <pre><code class="hljs plaintext">推荐策略： 异步刷盘 + 同步复制。    如果要严格保证数据可靠，需采用同步刷盘和同步双写的方式，但性能会较其他方式低。</code></pre></li></ul><h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a><code>集群搭建</code></h3><ul><li>集群部署模式  <pre><code class="hljs plaintext">单master：    优点：除了配置简单没什么优点，适合个人学习使用。    缺点：不可靠，该机器重启或宕机，将导致整个服务不可用。多master：    多个master节点组成集群，单个master节点宕机或者重启对应用没有影响。    优点：所有模式中性能最高。    缺点：单个master节点宕机期间，未被消费的消息在节点恢复之前不可用，消息的实时性就受到影响。多master多slave异步复制：    在多master模式的基础上，每个master节点都有至少一个对应的slave。master节点可读可写，但是slave只能读不能写，类似于mysql的主备模式。    优点：在master宕机时，消费者可以从slave读取消息，消息的实时性不会受影响，性能几乎和多master一样。    缺点：使用异步复制的同步方式有可能会有消息丢失的问题。多master多slave同步双写：    同多master多slave异步复制模式类似，区别在于master和slave之间的数据同步方式。    优点：同步双写的同步模式能保证数据不丢失。    缺点：发送单个消息RT会略长，性能相比异步复制低10%左右。</code></pre></li><li>软件依赖  <pre><code class="hljs plaintext">rocketmq：https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.4.0/rocketmq-all-4.4.0-bin-release.zipjdk：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</code></pre></li><li>环境介绍(2M-2S-SYNC)  <pre><code class="hljs plaintext">192.168.9.230    NameServer、broker-a(master)、broker-b-s(slave)192.168.9.231    NameServer、broker-b(master)、broker-a-s(slave)</code></pre>  <pre><code class="hljs plaintext">防火墙设置：    如果是开发环境,直接关闭防火墙        CentOS6：# service iptables stop        CentOS7：# service firewalld stop    如果是生产环境,就需要配置防火墙，增加端口规则，默认nameserver端口是9876</code></pre></li><li>开始部署<ol><li>安装jdk并配置环境变量(省略,2台机器都要配置)</li><li>下载RocketMQ程序包(只需在一台服务器上执行操作) <pre><code class="hljs plaintext">方法1：    1. 去RocketMQ官网找到并复制其链接地址    2. wget -P /opt/setups/ http://mirrors.shu.edu.cn/apache/rocketmq/4.4.0/rocketmq-all-4.4.0-bin-release.zip方法2：    1. 去RocketMQ官网找到指定版本的zip包,下载到本地    2. 通过rz等上传工具将程序包上传到/opt/setups目录中去方法3：    1. 从GitHub中checkout源码    2. 打开BUILDING文件找到&quot;Build distribution packages&quot;处的mvn命令    3. 在Maven窗口执行命令,生成的压缩包在rockemq目录下的&quot;distribution\target&quot;</code></pre></li><li>解压到指定目录 <pre><code class="hljs plaintext"># mkdir -pv /usr/program# unzip rocketmq-all-4.4.0-bin-release.zip -d /usr/program/</code></pre></li><li>配置环境变量,使用vim编辑&#x2F;etc&#x2F;profile.d&#x2F;my.sh文件 <pre><code class="hljs plaintext"># RocketMQROCKETMQ_HOME=/usr/program/rocketmq-all-4.4.0-bin-releasePATH=$ROCKETMQ_HOME/bin:$PATHexport ROCKETMQ_HOMEexport PATH</code></pre> <pre><code class="hljs plaintext"># source /etc/profile.d/my.sh</code></pre></li><li>创建存储等相关目录 <pre><code class="hljs plaintext"># mkdir -pv $&#123;ROCKETMQ_HOME&#125;/data/store/&#123;commitlog,consumequeue,index,checkpoint,slave/&#123;commitlog,consumequeue,index,checkpoint&#125;&#125;# tree -d $&#123;ROCKETMQ_HOME&#125;</code></pre></li><li>配置集群参数 <pre><code class="hljs plaintext"># vim $&#123;ROCKETMQ_HOME&#125;/conf/2m-2s-sync/broker-a.properties-----------------#整个broker集群的名字，创建topic时需要指定brokerClusterName=rocketmq-cluster##broker名字，注意此处不同的配置文件填写的不一样brokerName=broker-a##0表示master,&gt;0表示SlavebrokerId=0#nameServer地址,分号分割namesrvAddr=192.168.9.230:9876;192.168.9.231:9876#强制指定本机IP，需要根据每台机器进行修改。官方介绍可为空，系统默认自动识别，但多网卡时IP地址可能读取错误#brokerIP=192.168.0.1#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数defaultTopicQueueNums=4#是否允许Broker自动创建topic，建议线下开启，线上关闭autoCreateTopicEnable=true#是否允许Broker自动创订阅组，建议线下开启，线上关闭autoCreateSubscriptionGroup=true##Broker对外服务的监听端口,同一台机器部署多个broker，端口号要不同，且端口号之间要相距大些listenPort=10911#删除文件时间点，默认凌晨4点deleteWhen=04#文件保留时间，默认72小时fileReservedTime=120#commitLog每个文件的大小,默认为1GmapedFileSizeCommitLog=1073741824#ConsumeQueue每个文件默认存30W条，根据业务情况调整mapedFileSizeConsumeQueue=3000000destoryMaoedFileIntervalForcibly=120000redeleteHangedFileInterval=120000#检测物理文件磁盘空间diskMaxUsedSpaceRatio=88##store存储路径,master与slave目录要不同storePathRootDir=$&#123;ROCKETMQ_HOME&#125;/data/store##commitLog存储路径storePathCommitLog=$&#123;ROCKETMQ_HOME&#125;/data/store/commitlog##消息队列存储路径storePathConsumeQueue=$&#123;ROCKETMQ_HOME&#125;/data/store/consumequeue##消息索引储路径storePathIndex=$&#123;ROCKETMQ_HOME&#125;/data/store/index##checkpoint文件存储路径storeCheckpoint=$&#123;ROCKETMQ_HOME&#125;/data/store/checkpoint#限制的消息大小maxMessageSize=65536flushCommitLogLeastPages=4flushConsumeQueueLeastPages=2flushCommitLogThoroughInterval=10000flushConsumeQueueThoroughInterval=60000checkTransactionMessageEnable=false#发消息线程池数量sendMessageThreadPoolNums=128#拉消息线程池数量pullMessageThreadPoolNums=128##Broker的角色#ASYNC_MASTER 异步复制master#SYNC_MASTER 同步双写master#SLAVE 从brokerRole=SYNC_MASTER##刷盘方式#ASYNC_FLUSH 异步刷盘#SYNC_FLUSH 同步刷盘flushDiskType=ASYNC_FLUSH</code></pre> <pre><code class="hljs plaintext"># vim $&#123;ROCKETMQ_HOME&#125;/conf/2m-2s-sync/broker-b-s.properties-----------------brokerClusterName=rocketmq-clusterbrokerName=broker-bbrokerId=1namesrvAddr=192.168.9.230:9876;192.168.9.231:9876defaultTopicQueueNums=4autoCreateTopicEnable=trueautoCreateSubscriptionGroup=truelistenPort=10921deleteWhen=04fileReservedTime=120mapedFileSizeCommitLog=1073741824mapedFileSizeConsumeQueue=3000000destoryMaoedFileIntervalForcibly=120000redeleteHangedFileInterval=120000diskMaxUsedSpaceRatio=88storePathRootDir=$&#123;ROCKETMQ_HOME&#125;/data/store/slavestorePathCommitLog=$&#123;ROCKETMQ_HOME&#125;/data/store/slave/commitlogstorePathConsumeQueue=$&#123;ROCKETMQ_HOME&#125;/data/store/slave/consumequeuestorePathIndex=$&#123;ROCKETMQ_HOME&#125;/data/store/slave/indexstoreCheckpoint=$&#123;ROCKETMQ_HOME&#125;/data/store/slave/checkpointmaxMessageSize=65536flushCommitLogLeastPages=4flushConsumeQueueLeastPages=2flushCommitLogThoroughInterval=10000flushConsumeQueueThoroughInterval=60000checkTransactionMessageEnable=falsesendMessageThreadPoolNums=128pullMessageThreadPoolNums=128brokerRole=SLAVEflushDiskType=ASYNC_FLUSH</code></pre> <pre><code class="hljs plaintext"># vim $&#123;ROCKETMQ_HOME&#125;/conf/2m-2s-sync/broker-a-s.properties-----------------brokerClusterName=rocketmq-clusterbrokerName=broker-abrokerId=1namesrvAddr=192.168.9.230:9876;192.168.9.231:9876defaultTopicQueueNums=4autoCreateTopicEnable=trueautoCreateSubscriptionGroup=truelistenPort=10921deleteWhen=04fileReservedTime=120mapedFileSizeCommitLog=1073741824mapedFileSizeConsumeQueue=3000000destoryMaoedFileIntervalForcibly=120000redeleteHangedFileInterval=120000diskMaxUsedSpaceRatio=88storePathRootDir=$&#123;ROCKETMQ_HOME&#125;/data/store/slavestorePathCommitLog=$&#123;ROCKETMQ_HOME&#125;/data/store/slave/commitlogstorePathConsumeQueue=$&#123;ROCKETMQ_HOME&#125;/data/store/slave/consumequeuestorePathIndex=$&#123;ROCKETMQ_HOME&#125;/data/store/slave/indexstoreCheckpoint=$&#123;ROCKETMQ_HOME&#125;/data/store/slave/checkpointmaxMessageSize=65536flushCommitLogLeastPages=4flushConsumeQueueLeastPages=2flushCommitLogThoroughInterval=10000flushConsumeQueueThoroughInterval=60000checkTransactionMessageEnable=falsesendMessageThreadPoolNums=128pullMessageThreadPoolNums=128brokerRole=SLAVEflushDiskType=ASYNC_FLUSH</code></pre> <pre><code class="hljs plaintext"># vim $&#123;ROCKETMQ_HOME&#125;/conf/2m-2s-sync/broker-b.properties-----------------brokerClusterName=rocketmq-clusterbrokerName=broker-bbrokerId=0namesrvAddr=192.168.9.230:9876;192.168.9.231:9876defaultTopicQueueNums=4autoCreateTopicEnable=trueautoCreateSubscriptionGroup=truelistenPort=10911deleteWhen=04fileReservedTime=120mapedFileSizeCommitLog=1073741824mapedFileSizeConsumeQueue=3000000destoryMaoedFileIntervalForcibly=120000redeleteHangedFileInterval=120000diskMaxUsedSpaceRatio=88storePathRootDir=$&#123;ROCKETMQ_HOME&#125;/data/storestorePathCommitLog=$&#123;ROCKETMQ_HOME&#125;/data/store/commitlogstorePathConsumeQueue=$&#123;ROCKETMQ_HOME&#125;/data/store/consumequeuestorePathIndex=$&#123;ROCKETMQ_HOME&#125;/data/store/indexstoreCheckpoint=$&#123;ROCKETMQ_HOME&#125;/data/store/checkpointmaxMessageSize=65536flushCommitLogLeastPages=4flushConsumeQueueLeastPages=2flushCommitLogThoroughInterval=10000flushConsumeQueueThoroughInterval=60000checkTransactionMessageEnable=falsesendMessageThreadPoolNums=128pullMessageThreadPoolNums=128brokerRole=SYNC_MASTERflushDiskType=ASYNC_FLUSH</code></pre></li><li>修改日志配置文件 <pre><code class="hljs plaintext"># mkdir -pv $&#123;ROCKETMQ_HOME&#125;/logs# cd $&#123;ROCKETMQ_HOME&#125;/conf &amp;&amp; sed -i &#x27;s#$&#123;user.home&#125;#$&#123;ROCKETMQ_HOME&#125;#g&#x27; *.xml</code></pre></li><li>修改启动参数 <pre><code class="hljs plaintext"># vim $&#123;ROCKETMQ_HOME&#125;/bin/runserver.sh-----------------JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx512m -Xmn256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</code></pre> <pre><code class="hljs plaintext"># vim $&#123;ROCKETMQ_HOME&#125;/bin/runbroker.sh-----------------JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn512m&quot;</code></pre></li><li>使用scp命令将mq项目复制到另一台服务器,并在另一台机器上执行<code>步骤4</code> <pre><code class="hljs plaintext"># scp -r $&#123;ROCKETMQ_HOME&#125; root@192.168.9.230:/usr/program/</code></pre></li><li>启动nameserver和broker服务(2台机器都要执行)<pre><code class="hljs plaintext">输入命令jps或者查看$&#123;ROCKETMQ_HOME&#125;/logs下日志是否输出正常-----------------# nohup sh mqnamesrv &amp;# jps# nohup sh mqbroker -c $&#123;ROCKETMQ_HOME&#125;/conf/2m-2s-sync/broker-a.properties &amp;# nohup sh mqbroker -c $&#123;ROCKETMQ_HOME&#125;/conf/2m-2s-sync/broker-b-s.properties &amp;# jps</code></pre><pre><code class="hljs plaintext">查看集群监控状态-----------------# sh mqadmin clusterlist -n 192.168.9.231:9876</code></pre><img src="/2019/03/10/af-mq-rocketmq/af-mq-rocketmq-005.png" alt="抱歉,图片休息了"> </li><li>停止nameserver和broker服务<pre><code class="hljs plaintext">或者通过jps命令查看进程号,kill -9 pid-----------------# sh mqshutdown broker# sh mqshutdown namesrv</code></pre></li></ol></li></ul><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a><code>性能测试</code></h3><h3 id="API-源码分析"><a href="#API-源码分析" class="headerlink" title="API&amp;源码分析"></a><code>API&amp;源码分析</code></h3><ul><li>mq源码模块划分</li></ul><hr><table><thead><tr><th align="left">名称</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>broker</code></td><td align="left"><code>broker模块：c和p端消息存储逻辑</code></td></tr><tr><td align="left">client</td><td align="left">客户端api：produce、consumer端 接受与发送api</td></tr><tr><td align="left">common</td><td align="left">公共组件：常量、基类、数据结构</td></tr><tr><td align="left">tools</td><td align="left">运维tools：命令行工具模块</td></tr><tr><td align="left"><code>store</code></td><td align="left"><code>存储模块：消息、索引、commitlog存储</code></td></tr><tr><td align="left"><code>namesrv</code></td><td align="left"><code>服务管理模块：服务注册topic等信息存储</code></td></tr><tr><td align="left">remoting</td><td align="left">远程通讯模块：netty+fastjson</td></tr><tr><td align="left">logappender</td><td align="left">日志适配模块</td></tr><tr><td align="left"><code>example</code></td><td align="left"><code>Demo列子</code></td></tr><tr><td align="left">filtersrv</td><td align="left">消息过滤器模块</td></tr><tr><td align="left">srvutil</td><td align="left">辅助模块</td></tr><tr><td align="left">filter</td><td align="left">过滤模块：消息过滤模块</td></tr><tr><td align="left"><code>distribution</code></td><td align="left"><code>部署、运维相关zip包中的代码</code></td></tr><tr><td align="left">openmessaging</td><td align="left">兼容openmessaging分布式消息模块</td></tr></tbody></table><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/453c6e7ff81c">https://www.jianshu.com/p/453c6e7ff81c</a><br><a href="https://www.jianshu.com/p/b090138cf52c">https://www.jianshu.com/p/b090138cf52c</a></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统应用：常用程序包的安装与配置</title>
      <link href="/2019/03/09/os-linux-packages-install.html"/>
      <url>/2019/03/09/os-linux-packages-install.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-系统应用：常用程序包的安装与配置"><a href="#Linux-系统应用：常用程序包的安装与配置" class="headerlink" title="Linux 系统应用：常用程序包的安装与配置"></a>Linux 系统应用：常用程序包的安装与配置</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>整理在 Linux 环境下常用软件包的安装和配置.</p><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><h3 id="JDK的安装和配置"><a href="#JDK的安装和配置" class="headerlink" title="JDK的安装和配置"></a><code>JDK的安装和配置</code></h3><ol><li>检查 CentOS 有没有安装其他版本的 JDK,例如 opentJDK等等 <pre><code class="hljs plaintext"># java -version# rpm -qa | grep &quot;java&quot;-----------------------注：如果有的话,可配合rpm命令或者yum命令先卸载掉,其中yum命令能自动解决依赖等问题.    eg：# rpm -e --nodeps tzdata-java-2016j-1.el6.noarch java-1.6.0-openjdk-1.6.0.41-1.13.13.1.el6_8.x86_64 java-1.7.0-openjdk-1.7.0.131-2.6.9.0.el6_8.x86_64</code></pre></li><li>下载 JDK 程序包,rpm或者tar.gz格式的都可以 <pre><code class="hljs plaintext">方法1：    1. 去jdk官网找到指定版本的jdk,并复制其链接地址    2. wget -P /opt/setups/ https://download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.tar.gz?AuthParam=1552124414_039c05a3b27cb7d09e715788bf78b6e0    3. 重命名即可方法2：    1. 去jdk官网找到指定版本的jdk,下载到本地    2. 通过rz等上传工具将程序包上传到/opt/setups目录中去</code></pre></li><li>解压到指定目录 <pre><code class="hljs plaintext"># mkdir -pv /usr/program# tar -zxf jdk-8u201-linux-x64.tar.gz -C /usr/program</code></pre></li><li>配置环境变量,使用vim编辑&#x2F;etc&#x2F;profile.d&#x2F;my.sh文件 <pre><code class="hljs plaintext"># JDKJAVA_HOME=/usr/program/jdk1.8.0_201JRE_HOME=$JAVA_HOME/jrePATH=$JAVA_HOME/bin:$PATHCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOMEexport JRE_HOMEexport PATHexport CLASSPATH</code></pre></li><li>重新读取配置文件,使之生效 <pre><code class="hljs plaintext"># source /etc/profile.d/my.sh</code></pre></li><li>测试是否安装成功 <pre><code class="hljs plaintext"># java -version</code></pre></li></ol><h3 id="TOMCAT的安装和配置"><a href="#TOMCAT的安装和配置" class="headerlink" title="TOMCAT的安装和配置"></a><code>TOMCAT的安装和配置</code></h3><ol><li><p>下载 TOMCAT 程序包,rpm或者tar.gz格式的都可以</p> <pre><code class="hljs plaintext">方法1：    1. 去jdk官网找到指定版本的jdk,并复制其链接地址    2. wget -P /opt/setups/ http://apache.fayea.com/tomcat/tomcat-8/v8.5.43/bin/apache-tomcat-8.5.43.tar.gz    3. 重命名即可方法2：    1. 去tomcat官网找到指定版本的tomcat,下载到本地    2. 通过rz等上传工具将程序包上传到/opt/setups目录中去</code></pre></li><li><p>解压到指定目录</p> <pre><code class="hljs plaintext"># mkdir -pv /usr/program# tar -zxf apache-tomcat-8.5.34.tar.gz -C /usr/program</code></pre></li><li><p>设置 iptables 规则</p><ul><li>一种是关闭iptables,另一种是在iptables中添加允许规则(Tomcat默认端口是8080)</li><li>CentOS 6系统  <pre><code class="hljs plaintext"># iptables -I INPUT -p tcp -m tcp --dport 8080 -j ACCEPT# service iptables save# service iptables restart</code></pre></li><li>CentOS 7系统  <pre><code class="hljs plaintext"># firewall-cmd --zone=public --add-port=8080/tcp --permanent # firewall-cmd --reload</code></pre></li></ul></li><li><p>测试安装好后的 Tomcat</p><ul><li>启动 Tomcat  <pre><code class="hljs plaintext"># sh /usr/program/apache-tomcat-8.5.34/bin/startup.sh# tail -200f /usr/program/apache-tomcat-8.5.34/logs/catalina.out</code></pre></li><li>访问 <code>http://服务器 IP 地址:8080/</code></li><li>停止 Tomcat  <pre><code class="hljs plaintext"># sh /usr/program/apache-tomcat-8.5.34/bin/shutdown.sh</code></pre></li></ul></li><li><p>优化(待更新)</p></li></ol><h3 id="RocketMQ的集群部署"><a href="#RocketMQ的集群部署" class="headerlink" title="RocketMQ的集群部署"></a><code>RocketMQ的集群部署</code></h3><p>详见”消息中间件之 RocketMQ”章节</p><h3 id="Redis的集群部署"><a href="#Redis的集群部署" class="headerlink" title="Redis的集群部署"></a><code>Redis的集群部署</code></h3><p>详见”分布式缓存框架之 Redis&amp;Ehcache”章节</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/judasn/Linux-Tutorial">https://github.com/judasn/Linux-Tutorial</a></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统应用：添加开机启动服务/脚本</title>
      <link href="/2019/03/09/os-linux-script-powerboot.html"/>
      <url>/2019/03/09/os-linux-script-powerboot.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-系统应用：添加开机启动服务-脚本"><a href="#Linux-系统应用：添加开机启动服务-脚本" class="headerlink" title="Linux 系统应用：添加开机启动服务&#x2F;脚本"></a>Linux 系统应用：添加开机启动服务&#x2F;脚本</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>线上环境对服务&#x2F;脚本的自启动设置.</p><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><ul><li><p><code>添加开机自启服务</code></p>  <pre><code class="hljs plaintext">在CentOS 7中添加开机自启服务非常方便，只需要两条命令(以Jenkins为例)：    systemctl enable/disable jenkins.service #设置jenkins服务为自启动服务    systemctl start/restart/stop/status jenkins.service #启动jenkins服务兼容CentOS 6：    service network start/restart/stop/status    chkconfig network on/off    chkconfig --list</code></pre></li><li><p><code>添加开机自启脚本</code></p>  <pre><code class="hljs plaintext">在centos7中增加脚本有两种常用的方法，以脚本autostart.sh为例：    #!/bin/bash    #description:开机自启脚本    /usr/local/tomcat/bin/startup.sh  #启动tomcat -------------------   方法一：    1、赋予脚本可执行权限（/opt/script/autostart.sh是你的脚本路径）        chmod +x /opt/script/autostart.sh    2、打开/etc/rc.d/rc.local或/etc/rc.local文件，在末尾增加如下内容        su - user -c &#x27;/opt/script/autostart.sh&#x27;    3、在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限        chmod +x /etc/rc.d/rc.local方法二：    1、将脚本移动到/etc/rc.d/init.d或/etc/init.d目录下        mv /opt/script/autostart.sh /etc/rc.d/init.d    2、增加脚本的可执行权限        chmod +x  /etc/rc.d/init.d/autostart.sh    3、添加脚本到开机自动启动项目中        cd /etc/rc.d/init.d        chkconfig --add autostart.sh        chkconfig autostart.sh on</code></pre></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/wang123459/article/details/79063703?utm_source=copy">https://blog.csdn.net/wang123459/article/details/79063703?utm_source=copy</a></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统应用：Mysql数据库自动备份脚本</title>
      <link href="/2019/03/09/os-linux-db-backup.html"/>
      <url>/2019/03/09/os-linux-db-backup.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-系统应用：Mysql数据库自动备份脚本"><a href="#Linux-系统应用：Mysql数据库自动备份脚本" class="headerlink" title="Linux 系统应用：Mysql数据库自动备份脚本"></a>Linux 系统应用：Mysql数据库自动备份脚本</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>线上环境对 mysql 数据库的备份.</p><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><ol><li>创建备份 Shell 脚本，并保存至相关目录，例如：mysql-backup.sh <pre><code class="hljs plaintext">#!/bin/bash# Mysql 数据库自动备份脚本# 数据库认证host=localhostusername=rootpassword=123456db_name=test# 备份路径backup_dir=/data/backup/mysql# 日期格式date=$(date +&quot;%Y%m%d&quot;)# Dump数据库到SQL文件mysqldump -h$host -u$username -p$password $db_name &gt; $backup_dir/$db_name-$date.sql#写创建备份日志echo &quot;create $backup_dir/$db_name-$date.sql&quot; &gt;&gt; $backup_dir/log.txt # 备份清理# 删除5天之前的就备份文件find $backup_dir/* -mtime +5 -exec rm &#123;&#125; \;</code></pre></li><li>添加可执行权限 <pre><code class="hljs plaintext">~]# chmod u+x mysql-backup.sh添加可执行权限之后先执行一下，看看脚本有没有错误，能不能正常使用；~]# ./mysql-backup.sh</code></pre></li><li>通过 <code>crontab -e</code> 命令添加计划任务，添加如下代码，即可实现每天定时备份 mysql 数据库 <pre><code class="hljs plaintext"># 每天的23点50分执行备份50 23 * * * /data/backup/mysql-backup.sh</code></pre></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li><li>附带<code>Crontab</code>的常用格式<pre><code class="hljs plaintext">第 1 列分钟 0～59第 2 列小时 0～23（0 表示子夜）第 3 列日 1～31第 4 列月 1～12第 5 列星期 0～6（0 表示星期天）第 6 列要运行的命令30 21 * * * /usr/local/apache/bin/apachectl restart上面的例子表示每晚的 21:30 重启 apache。45 4 1,10,22 * * /usr/local/apache/bin/apachectl restart上面的例子表示每月 1、10、22 日的 4 : 45 重启 apache。10 1 * * 6,0 /usr/local/apache/bin/apachectl restart上面的例子表示每周六、周日的 1 : 10 重启 apache。0,30 18-23 * * * /usr/local/apache/bin/apachectl restart上面的例子表示在每天 18 : 00 至 23 : 00 之间每隔 30 分钟重启 apache。0 23 * * 6 /usr/local/apache/bin/apachectl restart上面的例子表示每星期六的 11 : 00 pm 重启 apache。0 */1 * * * /usr/local/apache/bin/apachectl restart每一小时重启 apache#20160912 修正，感谢 @张琼的指正，之前写错了，*/1 和 * 表示的同样的意思，对于 / 的用法，可以参考另一篇文章 Crontab 中的除号到底怎么用？0 23-7/1 * * * /usr/local/apache/bin/apachectl restart晚上 11 点到早上 7 点之间，每隔一小时重启 apache0 11 4 * mon-wed /usr/local/apache/bin/apachectl restart每月的 4 号与每周一到周三的 11 点重启 apache0 4 1 jan * /usr/local/apache/bin/apachectl restart一月一号的 4 点重启 apache</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统管理：磁盘、文件系统、RAID、LVM2、程序包</title>
      <link href="/2019/01/21/os-linux-sysadmin-first.html"/>
      <url>/2019/01/21/os-linux-sysadmin-first.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-系统管理"><a href="#Linux-系统管理" class="headerlink" title="Linux 系统管理"></a>Linux 系统管理</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>与系统管理相关…</p><pre><code class="hljs plaintext">磁盘管理、文件系统管理RAID基础原理、LVM2网络管理：TCP/IP协议、Linux网络属性配置程序包管理：rpm, yum进程管理：htop, glance, tsar等sed和awkLinux系统开机流程内核管理基础知识：编译内核、模块Linux系统裁剪：kernel+busybox</code></pre><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><pre><code class="hljs plaintext">I/O设备：    磁盘：用来实现本地数据的持久存储功能    网卡：通过网络交换数据    键盘、鼠标、显示器等-----------------I/O设备在硬件层次上有I/O Ports来标识,即当前主机上的I/O设备地址I/O设备在操作系统层次上有设备文件来标识-----------------块设备：block device，存取单位“块”，支持以&quot;block&quot;为单位进行随机访问，磁盘字符设备：character device，存取单位“字符”，支持以&quot;character&quot;为单位进行线性访问，键盘</code></pre><ul><li><code>设备文件</code>  <pre><code class="hljs plaintext">特殊文件只有元数据(inode)，而没有数据关联至一个设备驱动程序，进而能够跟与之对应硬件设备进行通信-----------------设备号：    主设备号：major number, 标识设备类型，进而确定要加载的驱动程序    次设备号：minor number, 标识同一类型下的不同设备-----------------设备文件的命名：由ICANN    /dev/DEV_FILE</code></pre></li><li><code>硬盘接口类型</code>  <pre><code class="hljs plaintext">并行：    IDE：早期的个人桌面常用接口,后升级为SATA,133MB/s    SCSI(Small Computer System Interface)：与IDE同时代的企业级接口,640MB/s        使用时长,读写方面大概相当于IDE接口的4-8倍,它的rpm(转速,rotations per minute)很高串行：    SATA：6Gbps/8    SAS：6Gbps/8    USB：480MB/s以上皆为接口速率,非硬件设备速率</code></pre></li><li><code>磁盘设备的设备文件命名</code>  <pre><code class="hljs plaintext">CentOS5：    IDE: /dev/hd[a-z]    SCSI, SATA, SAS, USB: /dev/sd[a-z]CentOS6以后,全都统一为/dev/sd[a-z]    不同设备：a-z        /dev/sda, /dev/sdb, ...    同一设备上的不同分区(每个分区分完以后都会被当作一个独立设备来管理)：1,2, ...        主+扩展：/dev/sda[1-4]        逻辑：/dev/sda[5]</code></pre></li><li><code>机械式硬盘</code>  <pre><code class="hljs plaintext">磁道：track    扇区：sector,512bytes,现在最大可以到4K柱面：cylinder    分区根据柱面划分,一个柱面只能属于一个分区,多个柱面由外而内组合在一起当作一个分区来使用,靠外柱面的这些分区读写性能好一点-----------------0磁道0扇区：512bytes,被预留出来,不属于任何分区,常被成为MBR    MBR: Master Boot Record,主引导记录,引导启动OS        446bytes: bootloader, 引导加载器程序        64bytes：分区表,记录分了哪几个区,每个区从哪开始从哪结束            16bytes: 标识一个分区,所以一个磁盘最多只能有4个主分区        2bytes: 55AA,MBR有效性标记    4个主分区：        3主分区+1扩展分区(切割1个或多个逻辑分区)            扩展分区不能直接当空间使用,只是分区表的一个扩展指向-----------------现代的MBR机制无法识别2T以上的磁盘空间;现在的硬盘由UEFI进行引导并结合GPT机制以后,能支持更多的磁盘分区,能识别2T以上的磁盘空间</code></pre></li><li><code>分区管理工具(fdisk, parted, sfdisk)</code>  <pre><code class="hljs plaintext">fdisk：历久弥坚的,各大Linux发行版都默认有提供,能满足大多数场景中的管理需要,对于一块硬盘来讲，最多只能管理15分区。----------------------------查看指定设备磁盘分区信息：    # fdisk -l [device...]        后面不跟设备则显示所有设备的磁盘分区信息创建/管理分区：    # fdisk device        交互式界面，有许多子命令            p: print, 显示磁盘已有分区            n: new, 新建分区            w: write, 保存(写入磁盘)并退出            q: quit,  不保存(放弃更新)退出            ------------            m: 获取帮助            d: delete，删除分区            l: 列出所有分区ID            t: 调整分区ID查看内核是否已经识别新的分区：    # cat /proc/partitions通知内核重新读取硬盘分区表：    对于已经有分区处于使用状态的磁盘来讲，新建分区后需要让内核重读其分区表    CentOS 5:        # partprobe [DEVICE]    CentOS 6:        # partx -a [DEVICE]            -n M:N        # kpartx -af [DEVICE]</code></pre></li></ul><h3 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h3><pre><code class="hljs plaintext">Linux支持众多类型的文件系统: ext2, ext3, ext4, xfs, btrfs, reiserfs, jfs, swap    ext2,ext3,ext4: ext2,ext3在centos5上流行;ext4在centos6上流行,在centos7上依然可以使用    xfs, btrfs: xfs在centos6上支持,centos7上流行;btrfs是centos7上自带的非常流行的非常强大的支持64位的空间可自动扩展的文件系统    swap: 交换分区,缓解物理内存资源不够用的情况    iso9660：光盘Windows：fat32(在linux上被识别为vfat), ntfs(linux对ntfs的支持还不是特别好)Unix: FFS, UFS, JFS2网络文件系统：NFS, CIFS集群文件系统：GFS2, OCFS2分布式文件系统：ceph, moosefs, mogilefs, GlusterFS, Lustre---------------------------根据其是否支持&quot;journal(日志)&quot;功能：    日志型文件系统: ext3, ext4, xfs, ...        系统检测速度快,但每次文件的写操作都会多一次IO操作,因此性能上可能不如非日志型文件系统好,不过到现在为止这种差别是微乎其微的,但带来的好处却是显而易见的.        推荐使用    非日志型文件系统: ext2, vfat---------------------------文件系统的组成部分：    内核中的模块：ext4, xfs, vfat, ...        Linux内核是模块化的，这些模块支持动态装载和卸载；文件系统可能会被直接打包进内核，也可以被编译成内核模块；即任何一个文件系统想要被使用,对应的内核模块一定要被装载        查看内核中已装载的所有模块：# lsmod    用户空间的管理工具：mkfs.ext4, mkfs.xfs, mkfs.btrfs, mkfs.vfat, ...Linux的虚拟文件系统：VFS    程序员和各个文件系统的中间层---------------------------查看系统支持哪些文件系统类型：    # cat /proc/filesystems---------------------------超级块用来存储整个分区当中的整个结构划分的,例如有多少个块组,每个块组有多少个块,每个块有多大,每个组当中有多少块被占用多少块是free的等等为防止超级块损坏,需要对超级块做备份,通常格式化以后会显示超级块的位置(存放在块组当中的某些位置)---------------------------Linux启动过程：    1.加电自检    2.装载bootloader    3.而后bootloader去装载用户所选定的操作系统的内核(应用程序)    4.内核自身完成初始化以后,取得系统控制权,首先去装载根文件系统(rootfs)所在的分区,该分区跟内核所在的分区可以不是同一个分区        /etc,/bin,/sbin,/lib,/lib64,/proc,/sys,/dev等都在该分区上,且这些目录不能单独分区    5.内核启动/sbin/init程序,由它代替内核来完成一切跟用户相关的程序的启动        # pstree</code></pre><ul><li><code>创建文件系统(格式化)</code>  <pre><code class="hljs plaintext">即需要用户空间的管理工具来调用内核中所提供的功能方能实现我们所期望拥有到的文件系统所谓的管理功能---------------------------mkfs：build a Linux filesystem    (1) # mkfs.FS_TYPE /dev/DEVICE    (2) # mkfs -t FS_TYPE /dev/DEVICE    -L &#x27;LABEL&#x27;: 设定卷标,将来可以根据卷标来对这个分区执行调用操作    -f：强制mke2fs：ext系列文件系统专用管理工具    -t &#123;ext2|ext3|ext4&#125;：指定文件系统     -b &#123;1024|2048|4096&#125;：指定块大小,块是分区格式化以后的一个单独存储单位,一般包含2个、4个或8个扇区,即块大小为1k,2k,4k;    -L &#x27;LABEL&#x27;,设定卷标    -j: journal,相当于 -t ext3        mkfs.ext3 = mkfs -t ext3 = mke2fs -j = mke2fs -t ext3    -i #: 为数据空间中每多少个字节创建一个inode；此大小不应该小于block的大小；一个块只能属于一个文件,一个文件至少包含一个块    -N #：为数据空间创建个多少个inode；    -m #: 为管理人员预留的空间占据的百分比；默认为5    -O FEATURE[,...]：启用指定特性        -O ^FEATURE：关闭指定特性mkswap：创建交换分区    # mkswap [options] device        -L &#x27;LABEL&#x27;    前提：调整其分区的ID为82；</code></pre></li><li><code>其它常用工具</code>  <pre><code class="hljs plaintext">blkid：查看块设备属性信息    # blkid [OPTION]... [DEVICE]        -U UUID: 根据指定的UUID来查找对应的设备        -L LABEL：根据指定的LABEL来查找对应的设备e2label：管理ext系列文件系统的LABEL    # e2label DEVICE [LABEL]        除了可以查看块设备的LABEL,还可以设定LABEL,避免将来需要修改LABEL时要重新格式化了tune2fs：重新设定ext系列文件系统的可调整参数的值(块大小无法调整)    # tune2fs [OPTION]... DEVICE        -l：查看指定文件系统超级块信息；super block        -L &#x27;LABEL&#x27;：修改卷标        -m #：修预留给管理员的空间百分比        -j: 将ext2升级为ext3        -O [^]FEATURE: 文件系统属性启用或禁用        -o [^]mount-options: 调整文件系统的默认挂载选项        -U UUID: 修改UUID号dumpe2fs：查看ext系列文件系统的超级块信息,还能查看文件系统的组织结构信息(块组)    # dumpe2fs [OPTION]... DEVICE        -h：只查看超级块信息</code></pre></li><li><code>文件系统检测</code>  <pre><code class="hljs plaintext">因进程意外中止或系统崩溃等情况导入写入操作非正常中止时，或者非法关机时,可能会导致文件损坏；此时，应该修复文件系统虽然开机以后会自动检测,但是自动检测会导致开机速度过慢,因此很多非关键性的文件系统建议开机时不自动检测,而是开机以后可以手动检测---------------------------fsck: File System CheCk    (1) # fsck.FS_TYPE /dev/DEVICE    (2) # fsck -t FS_TYPE /dev/DEVICE    -a: 自动修复错误    -r: 交互式修复错误    Note: FS_TYPE一定要与分区上已有的文件系统类型相同；e2fsck：ext系列文件专用的检测修复工具    -y：自动回答为yes;     -f：强制进行检测修复；</code></pre></li><li><code>文件系统挂载</code>  <pre><code class="hljs plaintext">将额外的文件系统(分区)与根文件系统上某现存的目录建立起关联关系，进而使得此目录做为其它文件系统的访问入口的行为(过程)称之为挂载；    目录中(挂载点)的原有文件在挂载完成后会被临时隐藏    即把要关联的设备关联至挂载点(另一个文件系统的访问入口)默认只有管理员才有权限；解除此关联关系的过程称之为卸载；根文件系统(rootfs)无需挂载,它是由内核探测来实现装载的；---------------------------挂载：mount DEVICE MOUNT_POINT    查看所有已经挂载的设备：            # cat /etc/mtab            # mount                通过查看/etc/mtab文件显示当前系统已挂载的所有设备            # cat /proc/mounts                查看内核追踪到的已挂载的所有设备    # mount [-fnrsvw] [-t vfstype] [-o options] device dir        device：指明要挂载的设备；            (1) 设备文件：例如/dev/sda5            (2) 卷标：-L &#x27;LABEL&#x27;, 例如 -L &#x27;MYDATA&#x27;            (3) UUID, -U &#x27;UUID&#x27;：例如 -U &#x27;0c50523c-43f1-45e7-85c0-a126711d406e&#x27;            (4) 伪文件系统名称：proc, sysfs, devtmpfs, configfs        dir：挂载点            事先存在；建议使用空目录；        常用命令选项：            -t vfstype：指定要挂载的设备上的文件系统类型,可省略,会自动调用blkid命令来判断此目录的文件系统的类型；            -r: readonly，只读挂载；            -w: read and write, 读写挂载；            -n: 挂载时，不更新/etc/mtab文件；            -a：自动挂载所有支持自动挂载的设备；(定义在了/etc/fstab文件中，且挂载选项中有“自动挂载”功能)            -L &#x27;LABEL&#x27;: 以卷标指定要挂载的设备；            -U &#x27;UUID&#x27;: 以UUID指定要挂载的设备；            -B, --bind: 绑定目录到另一个目录上；        -o options：(文件系统挂载时所启用的特性)            async：异步模式；性能高,安全可靠性低            sync：同步模式；性能差,安全可靠性高            atime/noatime：文件和目录被访问时是否更新最近一次的访问时间戳            diratime/nodiratime：目录被访问时是否更新最近一次的访问时间戳            auto/noauto：是否支持(mount的-a选项)自动挂载            exec/noexec：是否支持将文件系统上应用程序运行为进程            dev/nodev：是否支持在此文件系统上使用设备文件；            suid/nosuid：是否支持在此设备的文件上使用suid            remount：重新挂载，通常用于不卸载的情况下重新指定挂载选项            ro：只读            rw：读写            user/nouser：是否允许普通用户挂载此设备            acl：启用此文件系统上的acl功能，默认不支持            注意：上述选项可多个同时使用，彼此使用逗号分隔；                  默认挂载选项：defaults                        rw, suid, dev, exec, auto, nouser, and async                  eg：# mount -o remount,ro /dev/sda3---------------------------卸载：    # umount DEVICE    # umount MOUNT_POINT        进程正在使用中的设备无法被卸载;挂载点没有被进程访问时方可以卸载    查看哪些进程正在访问指定文件系统：        # fuser -v MOUNT_POINT    终止所有正在访问指定的文件系统的进程：        # fuser -km MOUNT_POINT---------------------------挂载交换分区：    启用：# swapon [OPTION]... [DEVICE]            -a：激活所有的交换分区；            -p PRIORITY：指定优先级；    禁用：# swapoff [OPTION]... [DEVICE]            -a：禁用所有；---------------------------挂载光盘设备：    光盘设备文件：        IDE: /dev/hdc            对于红帽系列,RHEL6或CentOs6以后,统一为sr0...        SATA: /dev/sr0        符号链接文件：/dev/cdrom,/dev/cdrw,/dev/dvd,/dev/dvdrw    # mount -r /dev/cdrom /media/cdrom    # umount /dev/cdrom</code></pre>  <pre><code class="hljs plaintext">自动挂载的设备的配置文件：/etc/fstab     使用mount命令手动挂载的文件系统在系统重启以后会失效(不会被自动挂载),需要添加至/etc/fstab文件中才能自动挂载     因为系统初始化过程的脚本会读取此文件(每行定义一个要挂载的文件系统),并尝试使用mount/swapon来实现额外文件系统的挂载     ---------------------------     UUID=3437f1a0-f850-4f1b-8a7c-819c5f6a29e4 /   ext4    defaults,discard,noatime      1 1     UUID=ad1361f7-4ab4-4252-ba00-5d4e5d8590fb /boot   ext3    defaults     1 2          6字段：        要挂载的设备或伪文件系统：           设备文件、LABEL(LABEL=&quot;&quot;)、UUID(UUID=&quot;&quot;)、伪文件系统名称(proc, sysfs)        挂载点：        文件系统类型：        挂载选项：            defaults,挂载选项可以有多个，彼此间使用逗号分隔；        转储频率：            0：从不转储(不做备份)            1: 每天转储            2: 每隔一天转储        自检次序：            0：不自检，一般来讲,额外创建的文件系统都无须自动自检,也不要转储            1：首先自检，通常只有根文件系统(rootfs)需要首先自检            2：次级自检，不同的设备可以使用同一个自检次序            ...</code></pre></li><li><code>磁盘空间查看工具</code>  <pre><code class="hljs plaintext">查看内存及交换分区的使用信息：    # free [OPTION]        -m: 以MB为单位        -g: 以GB为单位    注：其中&quot;+/- buffer/cached&quot;的userd和free的值为Mem的值+/-(buffers+cached)的值查看文件系统空间占用等信息：    # df [OPTION]        -h: human-readable,人类易读的        -i：inodes instead of blocks,显示inode的使用信息而非默认的磁盘空间使用信息        -P: 以Posix兼容的格式输出,每个设备信息显示在同一行,防止路径长的设备多行显示查看某目录总体空间占用状态    # du [OPTION]... DIR        -h: human-readable        -s: summary,不加此选项默认显示DIR下的每个文件的大小,加上此选项显示此目录及目录下所有文件的大小之和</code></pre></li><li><code>文件系统上的其它概念</code>  <pre><code class="hljs plaintext">存储空间：    元数据区：        元数据：存放文件的大小，时间戳，权限，属主、属组以及对应的数据存储在哪些磁盘块上            注：文件名虽然是元数据,但并不包含在Inode当中        Inode: Index Node, 索引节点            每一个能存储单个文件的所有属性信息(元数据)并按照特定格式组织的这么一个存储空间,被称之为一个Inode            每个文件系统上可能有N个Inode,为了方便引用某一个Inode,会给Inode进行编号,每个inode都有其编号,可通过ls -i来查看        地址指针：            直接指针：直接指向几个磁盘块，由于Inode在指向Block(引用Block编号)的空间是有限的，这样引用的块的数量较少            间接指针：Inode存储的是指向另一块的区域,这样能引用更多的Block            三级指针：    数据区：        数据：-----------------------------------bitmap：位图索引    inode bitmap        对位标识每个inode空闲与否的状态信息    block bitmap        所以每个文件系统格式化以后,就分了n个block,并将这些block分成了N个块组,块组中包含元数据区和数据区,元数据区存放了Inode     table(存放Inode)以及为Inode和Block做索引的位图,而每个块组中的布局结构信息信息是保存在各自块组的GDT(块组描述符)当中        包括块组从第几个块开始到第几个块结束,其中哪一个块存的是Inode位图,哪一个块存的是Block位图,哪些块存的是Inode table的,剩余的哪些块是用来存放数据的-----------------------------------目录也是一个文件,在磁盘上也占据磁盘块,也包括元数据和数据,数据区存储的是（直接附属于此目录）文件名以及文件名对应的Inode编号    相当于前面所说的&quot;路径映射&quot;-----------------------------------链接文件：    硬链接：指向同一个inode的多个不同路径。创建文件的硬链接即为为inode创建新的引用路径，因此会增加其引用计数。        不能够对目录进行,容易导致循环引用;但目录也是有硬链接的,不过是文件系统自带的固有属性(.和..)        不能跨分区进行；                通俗的讲就是两个路径的文件名指向同一个inode，此时，一个文件就称为另一个文件的硬链接    软链接(符号链接)：指向的是另一个文件的路径。其链接文件的大小为指向的路径字符串的长度，不增加或减少目标文件inode的引用计数。        能够对目录进行；        能跨分区进行；# ln [-sv] SRC DEST   将源文件链接至哪个地方    -s：symbolic link，不加-s就是硬链接,加-s就是创建符号链接    -v: verbose，显示过程-----------------------------------文件管理操作对文件的影响：    文件删除：inode被标记为空闲(可用状态从1改为0)，此inode指向的磁盘块被标记为空闲(可用状态从1改为0)。        如果inode被引用了多次(Inode内部有计数器)，且此次删除未使得其引用计数降为0的话，Inode是不会被标记为未用的,这意味着文件被删除仅删除了一个访问路径。    文件复制：创建一个新的空文件，并将原文件中的所有数据在新文件指向的磁盘块中再写一次的过程。        所以这个操作包括读出数据,再写入数据的这么一个过程,所以速度比较慢,即使是在同一个分区中进行。    文件移动：如果在同一个分区移动,移动文件仅是改变了文件访问路径；如果是跨分区移动,在新分区创建文件，从原分区上把数据复制过去，删除原分区数据。        所以同分区移动速度快;跨分区移动速度慢,跟文件复制没太大区别。练习：-----------------------------------    1、创建一个20G的文件系统，块大小为2048，文件系统ext4，卷标为TEST，要求此分区开机后自动挂载至/testing目录，且默认有acl挂载选项；        (1) 创建20G分区：        (2) 格式化：            mke2fs -t ext4 -b 2048 -L &#x27;TEST&#x27; /dev/DEVICE        (3) 编辑/etc/fstab文件            LABEL=&#x27;TEST&#x27; /testing ext4 defaults,acl 0 0        (4) 测试            mount    2、写一个脚本，完成如下功能：        (1) 列出当前系统识别到的所有磁盘设备；            fdisk -l /dev/[hs]da        (2) 如磁盘数量为1，则显示其空间使用信息；否则，则显示最后一个磁盘上的空间使用信息；            disks=$(fdisk -l $(fdisk -l /dev/[sh]d[a-z] | grep -o &quot;^Disk /dev/[sh]d[a-z]&quot; | wc -l)            if [ $disks -eq 1 ]; then                 fdisk -l /dev/[hs]da            else                 fdisk -l $(fdisk -l /dev/[sh]d[a-z] | grep -o &quot;^Disk /dev/[sh]d[a-z]&quot; | tail -1 | cut -d&#x27; &#x27; -f2)            fi</code></pre></li><li><code>btrfs文件系统管理与应用</code>  <pre><code class="hljs plaintext">概述：    btrfs(B-tree FS,Butter FS,Better FS)在CentOS7上是技术预览版.采用GPL授权,由Oracle在2007年研发的64位FS.    主要设计目标是用来取代Linux的ext3/4系列FS.核心特性：    多物理卷支持：支持将多个底层物理设备组织成同一个FS来直接使用；原生支持RAID功能，以及联机“添加”、“移除”、“修改”物理卷；    写时复制更新机制(CoW)：修改文件时先复制一份,对目标新复制的一份进行更新,将文件名指向的原空间改为指向新空间,万一改错了还能恢复更新前的文件；        这种机制在需要快速修复文件的场景中是极其有用的    数据及元数据校验码机制(checksum)：存储文件时将数据以及元数据的校验码通过文件某些属性来保存下来,读取文件时方便快速去检测该文件是否受损了并进行自动修复；        这种机制极大的保证了数据的可靠性    子卷(sub_volume)：在一个卷上可以创建多个子卷,每一个子卷单独使用和挂载；    快照：子卷的一个非完全副本,基于Cow机制来实现,与LVM中的快照基本相同,但它比LVM有个增强的特性(增量快照机制),支持快照的快照；    透明压缩机制：当存储文件时想节约空间,能自动能够通过占据cpu的时钟周期来完成数据压缩以后存储,对用户来讲是不知道的,在读取时又能自动解压缩；        这种机制会消耗更多的cpu时钟周期</code></pre>  <pre><code class="hljs plaintext">现在的工具大多数都是将多个命令(或功能)合并成一个命令,而后将每一个功能使用子命令来实现,btrfs命令就是这样的--------------------------------------文件系统创建：    mkfs.btrfs [options...] &lt;devices...&gt;        -L &#x27;LABEL&#x27;: 指定卷标        -d &lt;type&gt;: 指明数据是如何存放的,支持raid0, raid1, raid5, raid6, raid10, single        -m &lt;profile&gt;: 指明元数据是如何存放的,支持raid0, raid1, raid5, raid6, raid10, single, dup        -O &lt;feature&gt;: 在格式化时直接开启btrfs的哪些特性,老版本内核未必支持所有特性            -O list-all: 列出支持的所有feature；    eg：mkfs.btrfs -L mydata /dev/sdb /dev/sdc文件系统挂载：    mount -t btrfs /dev/sdb MOUNT_POINT        透明压缩机制：mount命令在CentOS上支持的子选项&#x27;compress&#x27;        mount -o compress=&#123;lzo|zlib&#125; DEVICE MOUNT_POINT            单独挂载btrfs的子卷时,需要先将btrfs的父卷umount,再挂载子卷;只挂载父卷时,子卷中的数据通过父卷后面的路径都能访问到        umount /mydata        mount -o subvol=logs /dev/sdb /mnt                因此在CentOS7上指明要安装btrfs时,可以在btrfs上创建多个子卷,一个叫做root,用来挂载/,一个叫做usr,用来挂载/usr等等,那个时候可以只用来挂载子卷而不挂载父卷.将ext系列文件系统转换成btrfs：    # btrfs-convert /dev/sdd1将btrfs重新降级回ext系列FS：         # umount /dev/sdd1    # btrfs-convert -r /dev/sdd1--------------------------------------btrfs常用子命令：可用&#x27;man btrfs-子命令&#x27;查看说明    btrfs subvolume：管理btrfs当中的子卷        create：创建子卷,而非创建子目录            eg：# btrfs subvolume create /mydata/logs        delete：可通过其路径删除子卷,前提时先要挂载父卷            eg：# btrfs subvolume delete /mydata/logs        list：列出btrfs当中的所有子卷            eg：# btrfs subvolume list /            eg：# btrfs subvolume list /mydata        show：查看btrfs当中某个子卷的详细信息        snapshot：针对btrfs当中的子卷创建快照,快照卷与子卷必须在同一个父卷中            eg：# btrfs subvolume snapshot /mydata/logs /mydata/logs_snapshot            eg：# btrfs subvolume delete /mydata/logs_snapshot    btrfs filesystem：管理btrfs自己的        df：查看已挂载的btrfs的空间使用率情况        show：查看已有的btrfs属性信息        sync：将这个文件系统缓存的数据都同步到磁盘上去        resize：调整大小        label：指明或显示卷标    btrfs device：管理btrfs的底层设备        add：新增物理卷        delete：移除物理卷,不会影响其中原有的数据,拆除时会自动移动这个设备上的数据其他设备上去,比LVM2强大    btrfs balance：管理btrfs的数据均衡操作(重新均衡数据)        start：启动balance            -dconvert=single：修改数据的存储类型,移除物理卷时需要先做此操作            -mconvert=raid1：修改元数据的存储类型,移除物理卷时需要先做此操作        pause：暂停        resume：继续        status：</code></pre></li></ul><h3 id="RAID-基础原理"><a href="#RAID-基础原理" class="headerlink" title="RAID 基础原理"></a>RAID 基础原理</h3><pre><code class="hljs plaintext">RAID全称Redundant Arrays of Inexpensive Drives,廉价冗余磁盘阵列                           Independent 独立冗余磁盘阵列Berkeley: A case for Redundant Arrays of Inexpensive Disks RAID    这篇论文阐述了将多块廉价的硬盘(IDE接口)按照某种特别的结构给组织起来当作一个设备来使用,从而能够根据不同的组合方式来提高其IO能力或者提高其耐用性。    提高IO能力：        磁盘并行读写;将来去买RAID控制器时,尤其是带内存的,要检查有没有供电功能    提高耐用性：        磁盘冗余来实现        不会因为磁盘损坏而导致业务终止或数据丢失,但是人为的损坏丢失跟磁盘损坏没关系,该备份的策略一个也不能少    RAID实现的方式：        外接式磁盘阵列(硬件实现)：通过扩展卡提供适配能力,在BIOS当中实现        内接式RAID(硬件实现)：主板集成RAID控制器,在BIOS当中实现        Software RAID：主机压根没有硬件设备支持,可通过软件的方式实现RAID            在OS中看到的是多个基本的磁盘设备、磁盘分区等，而后将这多个块设备可以组织一个单独的设备使用，即为软RAID</code></pre><pre><code class="hljs plaintext">级别：level,多块磁盘组织在一起的工作方式有所不同    单一类型:        RAID-0：0, 条带卷，strip; 将文件切割成chunk,分散到各个磁盘上            读、写性能提升；            无容错能力            可用空间：N*min(S1,S2,...)            最少磁盘数：2, 2+        RAID-1: 1, 镜像卷，mirror;将文件切割成chunk,每个磁盘都要保存            读性能提升、写性能略有下降；            有冗余能力            可用空间：1*min(S1,S2,...)            最少磁盘数：2, 2+        ...        RAID-4: 至少3块盘,将文件chunk,第一块盘存chunk1,第二块盘存chunk2,第三块盘存前2块盘的chunk的校验码(异或操作:1101, 0110, 1011)            读、写性能提升；            有容错能力（最多坏一块磁盘）            可用空间：(N-1)*min(S1,S2,...)            最少磁盘数：3, 3+        RAID-5：由于RAID-4有一块盘是做为集中校验盘,有可能会有性能瓶颈存在,所以在RAID-4的基础上改进,采用轮流做校验盘的机制            读、写性能提升；            有容错能力（最多坏一块磁盘）            可用空间：(N-1)*min(S1,S2,...)            最少磁盘数：3, 3+        RAID-6: 在RAID-5的基础上,采用2块盘作为循环校验盘            读、写性能提升；            有容错能力（最多坏两块磁盘）            可用空间：(N-2)*min(S1,S2,...)            最少磁盘数：4, 4+    混合类型:         RAID-10: 先将所有硬盘两两一组作为镜像卷,再在此基础上做成条带卷            读、写性能提升；            有容错能力：每组镜像最多只能坏一块；            可用空间：N*min(S1,S2,...)/2            最少磁盘数：4, 4+        RAID-01: 先将所有硬盘分为2组,每组做成条带卷,再在此基础上做成镜像卷        RAID-50:        RAID-7: 某个公司的独有技术,是一个文件服务器,IO能力非常好,价格非常贵        JBOD：Just a Bunch Of Disks            功能：将多块磁盘的空间合并成一个大的连续空间使用；            可用空间：sum(S1,S2,...)    常用级别：RAID-0, RAID-1, RAID-5, RAID-10, RAID-50, JBOD</code></pre><pre><code class="hljs plaintext">CentOS 6上的软件RAID的实现    结合内核中的md(multi devices)模块         md: 支持将任何块设备组织成RAID    mdadm：模式化的工具        命令的语法格式：mdadm [mode] &lt;raiddevice&gt; [options] &lt;component-devices&gt;            &lt;raiddevice&gt;: /dev/md#,md设备的设备文件，一般在/dev目录下，以md开头，后跟一个数字来区别            &lt;component-devices&gt;: 任意块设备,可以是整个分区或者整个磁盘        支持的RAID级别：LINEAR(JBOD), RAID0, RAID1, RAID4, RAID5, RAID6, RAID10等等;         模式：            创建：-C，创建RAID            装配: -A，重新识别此前实现的RAID                在某OS上创建的软件RAID，被迁移到其它主机上，并启动OS之后，Linux auto detect            监控: -F            管理：-f, -r, -a        查看当前系统上所有已启用的软件RAID设备及其相关信息(观察md的状态):             # cat /proc/mdsta        创建模式: -C,需先将块设备的分区ID调整为&#x27;fd&#x27;(Linux raid auto)            -n #: 使用#个块设备来创建此RAID；            -l #：指明要创建的RAID的级别；            -a &#123;yes|no&#125;：自动创建目标RAID设备的设备文件；            -c CHUNK_SIZE: 指明块大小；            -x #: 指明空闲盘的个数；                        例如：创建一个10G可用空间的RAID0；                # mdadm -C /dev/md0 -a yes -n 2 -l 0 /dev/sdb&#123;1,2&#125;            例如：创建一个10G可用空间的RAID5；                3*5G，6*2G：(n-1)*2G                # mdadm -C /dev/md1 -a yes -n 3 -l 5 -x 1 /dev/sda&#123;3,5,6&#125; /dev/sdb3                # cat /proc/mdsta                # mke2fs -t ext4 /dev/md1                # mount /dev/md1 /mydata                # mount                # df -lh        管理模式：            -f: 标记指定磁盘为损坏                # mdadm /dev/md1 -f /dev/sda3                # watch -n1 &quot;cat /proc/mdsta&quot;                # mdadm -D /dev/md1            -a: 添加磁盘                # mdadm /dev/md1 -a /dev/sda3            -r: 移除磁盘                # mdadm /dev/md1 -r /dev/sda3        显示指定的软RAID的详细信息：-D            # mdadm -D /dev/md#        停止md设备：-S            # mdadm -S /dev/md#        重新启用RAID：            # mdadm -A /dev/md# /dev/DEVICE...            mdadm的配置文件/etc/mdadm.conf</code></pre><h3 id="LVM2"><a href="#LVM2" class="headerlink" title="LVM2"></a>LVM2</h3><pre><code class="hljs plaintext">LVM: Logical Volume Manager(逻辑卷管理器)， Version: 2    与软RAID很类似,使用纯软件的方式组织一个或多个底层硬件设备为一个抽象的逻辑设备来使用的解决方案    主要作用是支持动态扩展或收缩,以及支持快照功能结合内核中的dm(device mapper)模块     dm: 将一个或多个底层块设备组织成一个逻辑设备的模块；原理：    1. 将底层硬盘设备(磁盘或者分区或者RAID)在逻辑卷的架构中创建成PV(物理卷)    2. 将PV中所提供的存储空间划分成大小相同的N个存储单元PE(Physical Extent,物理盘区),并将存储单元合并在一个高层上,形成一个组件VG(卷组),卷组可以有多个物理卷        注：PE大小是在PV加入到VG之后决定的;VG的大小也可以通过增加PV来扩展或收缩    3. VG有点类似于扩展分区,没办法直接格式化使用,需要再次划分成逻辑分区    4. 在VG的基础上再次创建多个LV(逻辑卷)组件,这才是真正意义上的逻辑卷,每一个LV都是一个独立的文件系统,可以被格式化挂载使用        即指定特定数量的PE来组成一个逻辑存储空间的过程,逻辑卷的大小可以动态扩展或收缩而不影响到里面原先的数据        一旦PE分配给逻辑卷使用,此时PE叫做LE,    --------------------------------    所以在安装红帽系列OS并选择自动创建分区时,它首先创建一个boot分区,将其他剩余的空间统统创建为一个PV,再将这个PV创建为一个VG,在VG当中创建多个LV,    一个LV用来当/,一个LV用来当SWAP,一个LV用来当USR,一个LV用来当VAR等等LV的访问路径：    1. /dev/mapper/VG_NAME-LV_NAME/dev/mapper/vol0-root2. /dev/VG_NAME/LV_NAME/dev/vol0/root    此两者均为符号链接，指向的文件为/dev/dm-#</code></pre><pre><code class="hljs plaintext">pv管理工具：pvcreate, pvs, pvdisplay, pvremove, pvmove, pvscan    # pvs：显示pv的简要信息    # pvdisplay：显示pv的详细信息    # pvcreate /dev/DEVICE: 创建pv        需先将块设备的分区ID调整为&#x27;8e&#x27;(Linux LVM)    # pvremove        先做vgremovevg管理工具：vgcreate, vgs, vgdisplay, vgremove, vgextend, vgreduce, vgscan    # vgs    # vgdisplay    # vgcreate  [-s #[kKmMgGtTpPeE]] VolumeGroupName  PhysicalDevicePath [PhysicalDevicePath...]    # vgextend  VolumeGroupName  PhysicalDevicePath [PhysicalDevicePath...]    # vgreduce  VolumeGroupName  PhysicalDevicePath [PhysicalDevicePath...]        先做pvmove,将pv上的pe移动至同一个卷组当中的其他pv上去    # vgremove        先做lvremovelv管理工具：lvcreate, lvs, lvdisplay, lvremove, lvextend, lvreduce, lvscan, lvmconf    # lvs    # lvdisplay    # lvcreate -L #[kKmMgGtTpPeE] -n LV_NAME VolumeGroupName    # lvremove /dev/VG_NAME/LV_NAME        如果已经挂载过,需要先卸载再remove        扩展逻辑卷：逻辑卷支持在线修改大小        # lvextend -L [+]#[kKmMgGtTpPeE] /dev/VG_NAME/LV_NAME            扩展物理边界            先确定扩展的目标大小；并确保对应的卷组中有足够的空闲空间可用；如原大小为2G, 目标为4G,则可写为&#x27;-L +2G&#x27;或者&#x27;-L 4G&#x27;        # resize2fs /dev/VG_NAME/LV_NAME            扩展逻辑边界            重新修改逻辑卷的大小,没指定大小即使用这个分区上所有的可用大小    缩减逻辑卷：缩减很危险！！！！,所以缩减要离线        # umount /dev/VG_NAME/LV_NAME            先卸载文件系统        # e2fsck -f /dev/VG_NAME/LV_NAME            执行强制检测并修复        # resize2fs /dev/VG_NAME/LV_NAME #[mMgGtT]            缩减逻辑边界            先确定缩减后的目标大小；并确保对应的目标逻辑卷大小中有足够的空间可容纳原有所有数据；        # lvreduce -L [-]#[kKmMgGtTpPeE] /dev/VG_NAME/LV_NAME            缩减物理边界        # mount /dev/VG_NAME/LV_NAME MOUNT_POINT            重新挂载                创建快照卷：snapshot        工作机制：            快照卷刚创建时没有任何数据,只是将逻辑卷数据的元数据备份一份,将快照卷挂载后,通过快照卷也能访问原卷中的数据,所以快照卷其实是            原卷的另一个访问入口而已；同时立即创建逻辑卷元数据的一个监视器,随时监控着对方的元数据, 当监控到某一刻某个文件要变化            时,先将这个文件复制一份到快照卷上,然后原卷的数据再变化,将来通过快照卷访问数据时,没变化的仍通过原卷找文件,而发生变化的则访问            本卷中的数据;所以这样使得快照卷的空间体积很小,仅存储了快照创建以后原卷中发生变化的文件,没变化的仍找原卷.        注：快照卷是对某逻辑卷进行的，因此必须跟目标逻辑卷在同一个卷组中（类似于硬链接不能跨分区进行）；无须指明卷组；                # lvcreate -s -L #[kKmMgGtTpPeE] -n snapshot_lv_name -p r original_lv_name            eg：lvcreate -s -L 512M -n mylv-snap -p r /dev/myvg/mylv        # mount /dev/myvg/mylv-snap /mnt</code></pre><h3 id="程序包管理"><a href="#程序包管理" class="headerlink" title="程序包管理"></a>程序包管理</h3><pre><code class="hljs plaintext">API：Application Programming Interface    POSIX：Portable(可移植) OS        程序源代码(C, C++, perl等) --&gt; 预处理 --&gt; 编译(gcc) --&gt; 汇编(将目标代码转换成二进制指令的过程) --&gt; 链接 --&gt; 执行        动态(共享)编译：程序研发时调用了库函数，程序单独编译完后，明确指明库的调用入口(例如/lib或/lib64下的.so文件)，程序要运行必要要把库装在进内存            能够大大节约内存资源        静态编译：程序在编译时直接把要调用的库复制到程序内部来，程序体积比动态编译体积大            程序挪到任何系统上都能运行，缺点是对内存和体积都不利ABI：Application Binary Interface    Windows与Linux不兼容,但可以使用库级别的虚拟化让二者兼容起来.    库级别的虚拟化：能够使Windows系统上的应用程序(exe)运行在Linux系统上(elf),反之亦然.        Linux: WINE(能够虚拟windows运行环境)        Windows: Cywin(能够虚拟linux运行环境)虽然通过库级别的虚拟化技术能使程序在多平台上运行,但库可能是个小众产品,其次稳定性还有待考证,因此并不建议这样使用;但很多时候应用程序在一次编译以后期望能在各种平台上运行,可以提供更高级别的应用级别接口,例如JAVA的JVM.     这样用JAVA语言写的程序就不用直接跑在系统调用/库调用之上,只要跑在JVM之上就能执行.因此应用程序的开发可分为：    系统级开发：面对系统调用/库调用来实现,linux内核是由99%的c和1%的汇编写成的        C,C++,    应用级开发：面对特定应用程序自己专有的开发环境来实现        Java,Python,Ruby,Php,Perl</code></pre><pre><code class="hljs plaintext">linux应用程序的组成部分：二进制程序、库文件、配置文件、帮助文件二进制程序：可执行文件,一个应用程序可有多个二进制程序/bin,/sbin,/usr/bin,/usr/sbin,/usr/local/bin,/usr/local/sbin库文件：可执行文件,不能独立执行，只能被能独立运行的程序调用时执行,一般有2类,一类是多个程序之间的共享库,一类是自己能够被其他人做二次开发时调用的接口/lib,/lib64,/usr/lib,/usr/lib64,/usr/local/lib,/usr/local/lib64配置文件：可被查看其内容的文件/etc,/etc/DIRECTORY,/usr/local/etc帮助文件：可被查看其内容的文件/usr/share/man,/usr/share/doc,/usr/local/share/man,/usr/local/share/doc--------------------    查看二进制程序所依赖的库文件：        # ldd /PATH/TO/BINARY_FILE    管理及查看本机装载的库文件：        # ldconfig             /sbin/ldconfig -p: 显示本机已经缓存的所有可用库文件名及文件路径映射关系；        配置文件为：/etc/ld.so.conf, /etc/ld.so.conf.d/*.conf        缓存文件：/etc/ld.so.cache程序包管理器：    将编译好的应用程序的各组成文件(包括二进制程序,库文件,配置文件,帮助文件)打包成一个或几个程序包文件，从而方便快捷地实现程序包的安装、卸载、查询、升级和校验等管理操作.    不同的发行版所用的包管理器是不一样的.    --------------------    1、程序的组成清单 (每个包独有)        文件清单        安装或卸载时运行的脚本    2、数据库(公共)        程序包名称及版本        依赖关系        功能性说明        安装生成的各文件的文件路径及校验码信息    --------------------    debian,ubuntu：        包管理器：dpt            dpkg-deb/apt-get：deb包管理器前端工具        包格式：.deb    rhel,fedora,centos,S.u.S.e：        包管理器：rpm(Redhat Package Manager),RPM is Package Manager            yum：rpm包管理器的前端工具(补充和丰富了rpm的功能,而不是取代rpm的)            zypper: suse上的rpm包管理器的前端管理工具            dnf: Fedora 22+上的rpm包管理器的前端管理工具        包格式：.rpm</code></pre><ul><li><code>rpm包的简介</code>  <pre><code class="hljs plaintext">源代码：    name-VERSION.tar.&#123;gz,bz2,xz&#125;        VERSION: major.minor.releaserpm包命名方式：    name-VERSION-release.arch.rpm        VERSION: major.minor.release，同源代码        release：rpm包自身的发行号，与程序源码的发行号无关，仅用于标识对rpm包不同制作的修订；同时，release还包含此包适用的OS            OS例如centos5,el7(RHEL7)等等        arch：适用于的硬件平台            x86: i386, i486, i586, i686等；            x86_64: x64, x86_64, amd64            powerpc: ppc            noarch: 跟平台无关,依赖于虚拟机                     例如：            bash-4.2.3-3.centos5.x86_64.rpm            zlib-1.2.7-13.el7.i686.rpm    一个程序有20个功能：常用功能有8个，特殊A:3个，特殊B：6个，二次开发相关功能：3        分包机制：拆包            核心包，主包：命名与源程序一致                bash-4.2.3-3.centos7.x86_64.rpm            子包，支包：                bash-a-4.2.3-3.centos7.x86_64.rpm                bash-b-4.2.3-3.centos7.x86_64.rpm                bash-devel-4.2.3-3.centos7.x86_64.rpm    包之间：存在依赖关系        X, Y, Z获取rpm程序包的途径：    (1) 系统发行版的光盘或官方服务器(例如CentOS镜像站点等)；    (2) 项目官方站点    (3) 第三方组织：很多第三方机构或个人制作并公开发布许多rpm包        可靠的途径：来源合法性及完整性可以保证            Fedora-EPEL        搜索引擎：尽量不要使用,来源合法性及完整性难以保证            http://pkgs.org            http://rpmfind.net            http://rpm.pbone.net    (4) 自己制作rpm包来源合法性验正及完整性验正：    完整性验正：SHA256(单向加密)    来源合法性验正：RSA(公钥加密)    --------------------    包的制作者会在包制作完成后,使用单向加密算法计算并提取原始数据的特征码，而后使用自己的私钥加密这段特征码，最后附加在原始数据后面(数字签名)。    验正过程：        前提：必须有可靠机制获取到包制作者的公钥；        1、使用制作者的公钥解密加密的特征码，能解密则意味着来源合法；        2、使用与制作者同样的意向加密算法提取原始数据的特征码，并与解密出来的特征码作比对，相同，则意味着完整性没问题；        具体做法之一：        首先在当前系统上导入包的制作者的公钥：            rpm --import /PATH/FROM/GPG-PUBKEY-FILE                        显示所有已经导入的gpg格式的公钥：# rpm -qa gpg-pubkey*            显示密钥的详细信息：# rpm -qi gpg-pubkey-NAME        自动检查包：            安装过程中会自动执行        手动检查包：            rpm -K /path/to/package_file            rpm --checksig /path/to/package_file                不检查包完整性：                    rpm -K --nodigest                不检查来源合法性：                    rpm -K --nosignature         Tips：CentOS 7发行版光盘提供的密钥文件是`RPM-GPG-KEY-CentOS-7`管理rpm程序包的方式：    使用包管理器：rpm    使用前端工具：yum, dnf</code></pre></li><li><code>rpm命令的使用</code>  <pre><code class="hljs plaintext">CentOS系统上rpm命令管理程序包：    安装、升级、查询、卸载、校验、数据库维护(重建)---------------------------安装：    rpm &#123;-i|--install&#125; [install-options] PACKAGE_FILE ...        -v: verbose        -vv:         -h: 以#显示程序包管理执行进度；每个#表示2%的进度         常用组合选项：-ivh        [install-options]            --test: 测试安装，但不真正执行安装过程；dry run模式；            --nodeps：忽略依赖关系安装；能安装上，但有可能无法运行；            --replacepkgs: 重新安装；如果原有配置文件作了修改，很有可能不执行替换，而是将应该安装生成的配置文件重命名为.rpmnew；            --nosignature: 不检查来源合法性；            --nodigest：不检查包完整性；            --noscipts：不执行程序包脚本片断；                %pre: 安装前脚本； --nopre                %post: 安装后脚本； --nopost                %preun: 卸载前脚本； --nopreun                %postun: 卸载后脚本；  --nopostun升级：新版本替换老版本    rpm &#123;-U|--upgrade&#125; [install-options] PACKAGE_FILE ...    rpm &#123;-F|--freshen&#125; [install-options] PACKAGE_FILE ...        upgrage：安装有旧版程序包，则“升级”；如果不存在旧版程序包，则“安装”;        freeshen：安装有旧版程序包，则“升级”；如果不存在旧版程序包，则不执行升级操作；         常用组合选项：            1、升级或安装：-Uvh            2、纯升级：-Fvh        [install-options]            --oldpackage：降级；            --force: 强制升级；    注意：        (1) 不要对内核做升级操作,很有可能系统启动不了；Linux支持多内核版本并存，因此，直接安装新版本内核即可；        (2) 如果原程序包的配置文件安装后曾被修改，升级时，新版本的提供的同一个配置文件并不会直接覆盖老版本的配置文件，而把新版本的文件重命名(FILENAME.rpmnew)后保留；查询：基于数据库的    rpm &#123;-q|--query&#125; [select-options] [query-options]        查询某包是否安装：# rpm -q package_name...        [select-options]            -a: 查询所有已经安装的包,可配合grep进行条件过滤            -f /path/to/some_file: 查看指定的文件由哪个程序包安装生成            -p /PATH/TO/PACKAGE_FILE：针对尚未安装的程序包文件做查询操作             --whatprovides CAPABILITY：查询指定的CAPABILITY(功能)由哪个包所提供            --whatrequires CAPABILITY：查询指定的CAPABILITY(功能)被哪个包所依赖        [query-options]            --changelog package_name：查询rpm包制作的changlog            -c package_name: 查询某包安装生成了哪些配置文件            -d package_name: 查询某包安装生成了哪些帮助文件            -i package_name: information,查询包的描述信息            -l package_name: 查询某包安装生成了哪些文件；            --scripts package_name：查询程序包自带的脚本片断                preinstall：安装前脚本                postinstall: 安装后脚本                preuninstall: 卸载前脚本                postuninstall: 卸载后脚本            -R: 查询指定的程序包所依赖的CAPABILITY；            --provides: 列出指定程序包所提供的CAPABILITY；                    常用组合选项：            -qi PACKAGE, -qf FILE, -qc PACKAGE, -ql PACKAGE, -qd PACKAGE            -qpi PACKAGE_FILE, -qpl PACKAGE_FILE, ...            -qa卸载：    rpm &#123;-e|--erase&#125; [--allmatches] [--nodeps] [--noscripts] [--notriggers] [--test] PACKAGE_NAME ...        --nodeps：忽略依赖关系卸载;能卸载，但依赖于此包的程序包可能会运行不正常；    注意：        如果包的配置文件安装后曾被改动过，卸载时，此文件将不会卸载，而是被重命名并保留，例如warning: /etc/zprofile saved as /etc/zprofile.rpmsave校验：用于检查包安装生成的文件属性是否发生变化    rpm &#123;-V|--verify&#125; [select-options] [verify-options]       S file Size differs       M Mode differs (includes permissions and file type)       5 digest (formerly MD5 sum) differs       D Device major/minor number mismatch       L readLink(2) path mismatch       U User ownership differs       G Group ownership differs       T mTime differs       P caPabilities differ    注意：        某属性无变化，显示为.数据库重建：    数据库目录：/var/lib/rpm    rpm &#123;--initdb|--rebuilddb&#125;        initdb: 初始化            如果事先不存在数据库，则新建之；否则，则不新建,即不执行任何操作；        rebuilddb：重建            无论当前存在与否，直接重新创建数据库来覆盖原有的数据库；</code></pre></li><li><code>yum命令的使用</code>  <pre><code class="hljs plaintext">why：    rpm包管理器在实现程序管理时会有一些问题,比如必须手动解决依赖关系,非常麻烦,虽然在安装时可以忽略依赖关系,但在使用时可能存在问题.    所以需要有高于rpm或者deb这种本身底层的管理器,能实现在前端自动解决依赖关系,来完成程序的安装,解决用户的后顾之忧.所以yum等工具出现了.    但yum虽然解决了依赖关系,但它的工作机制和设计体系是有一定问题的,比如安装过程当中半道终止的话,下次再安装时将会无法解决,它无法分析上次是否安装成功与否.    因此dnf的出现主要是为了解决yum所面临的这个问题的.what：    yum,全称Yellow dog Updater, Modified    是一个基于RPM包管理的前端包管理器(工具),能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包.    它是由Yellow dog研发的,并非是取代rpm的,必须依赖于rpm才能存在的.---------------------------yum工作机制：yum自身并非cs架构,而是yum所依赖的这种文件访问机制是cs架构的.    1.当用户使用yum命令要去安装一个程序包时,即yum客户端接受到安装程序包的指令,    2.首先会尝试着根据yum配置文件去找指定的远程仓库,以获取仓库的元数据信息,并缓存至本地/var/cache/yum,    3.yum客户端程序在本地分析元数据文件，并结合本地系统环境(已安装的包)做出要安装的程序包的决策(依赖关系等),    4.根据决策联系Yum仓库，下载各程序包缓存于本地后，一并进行类似于rpm命令的安装操作.    5.yum安装完成以后,会自动删除程序包缓存以节约空间,元数据文件一般会存在本地,下次安装时会先对比此文件本地与仓库的校验码,相同则不更新,不同则更新,以节约网络带宽.yum仓库：rpm包的文件服务器    yum仓库的组成：        1.各个rpm包；        2.元数据文件(包名、版本信息、各包所包含的文件列表、依赖关系、包分组信息),放置于特定目录(repodata)下.            centos5: xml, centos6,7: sqlite            createrepo: 制作yum仓库元数据的工具    yum仓库的协议：repodata目录所在父目录就是一个可用仓库        ftp     ftp://server/path/to/repository        http    http://server/path/to/repository        nfs nfs://server/nfs_path        file    file:///path/to/repository    使用Centos镜像光盘搭建本地yum源(仓库)：        (1) 将默认Yum源备份(可选)            # mkdir /opt/centos-yum.bak            # mv /etc/yum.repos.d/* /opt/centos-yum.bak/        (2) 在虚拟机上挂载CentOS镜像文件至某目录，例如/media/cdrom            # mount -r -t iso9660 /dev/cdrom /media/cdrom        (3) 编写repo文件并指向镜像的挂载目录            # vim /etc/yum.repos.d/local.repo            [local]            name=local            baseurl=file:///media/cdrom            gpgcheck=0            enabled=1        (4) 清除本地缓存            # yum clean all        (5) 虽然本地yum源安装软件速度快,但可能有些包没有,所以添加aliyun,163等yum源用作第二考虑yum源            # cat /etc/redhat-release            # wget -O /etc/yum/repos.d/CentOS&#123;5,6,7&#125;-Base-aliyun.repo http://mirrors.aliyun.com/repo/Centos-&#123;5,6,7&#125;.repo            # wget -O /etc/yum/repos.d/CentOS&#123;5,6,7&#125;-Base-163.repo http://mirrors.163.com/.help/CentOS&#123;5,6,7&#125;-Base-163.repo        (6) 修改Yum源的优先级(当既有本地源又有163,aliyun等源时,希望先用本地源去安装,本地找不到可用的包再使用163,aliyun等源去安装软件)            (1) 查看系统是否安装了优先级的插件                # rpm -qa | grep &quot;yum-plugin-&quot;                    看看有没有yum-plugin-priorities.noarch插件                # yum search yum-plugin-priorities                    用search查看是否有此插件可用            (2) 安装yum-plugin-priorities.noarch插件                # yum -y install yum-plugin-priorities.noarch            (3) 查看插件是否启用                # cat /etc/yum/pluginconf.d/priorities.conf                    1为启用,0为禁用            (4) 修改本地Yum源优先使用                # vim /etc/yum.repos.d/local.repo                    在原基础上加入priority=1,数字越小优先级越高                    可以继续修改其他源的priority值,经测试仅配置本地源的优先级为priority=1就会优先使用本地源了    自建yum源：        (1) 安装httpd程序，并启动服务,并设置开机自启            # yum install httpd            # service httpd start            # chkconfig httpd on        (2) httpd的文档根目录为/var/www/html,创建子目录，存放某相关的所有rpm包        (3) 为仓库生成元数据文件，以使能够作为仓库使用            # yum install createrepo            # createrepo /path/to/rpm_repo/        (4) 配置yum客户端使用此仓库即可yum客户端：    配置文件：         /etc/yum.conf：主配置文件（中心配置文件）,为所有仓库提供公共配置            可使用whatis/man yum.conf查看帮助手册        /etc/yum.repos.d/*.repo：一个或几个相关仓库的配置信息可保存为一个文件，文件名都以.repo结尾,为仓库的指向提供配置    仓库指向的定义：        [repositoryID]        name=Some name for this repository        baseurl=url://path/to/repository/        enabled=&#123;1|0&#125;        gpgcheck=&#123;1|0&#125;        gpgkey=URL        enablegroups=&#123;1|0&#125;        mirrorlist=URL to a file            mirrorlist  Specifies a URL to a file containing a list of baseurls        failovermethod=&#123;roundrobin|priority&#125;            默认为：roundrobin，意为随机挑选；        cost=&#123;1..n&#125;            默认为1000，指定访问此仓库的开销    yum的repo配置文件中可用的变量：        $releasever: 程序的版本，对Yum而言指的是redhat-release版本；只替换当前OS的发行版的主版本号;         $arch: 系统架构(平台)        $basearch: 系统基本架构(平台)，如i686，i586等的基本架构为i386；        $YUM0-9: 在系统中定义的环境变量，可以在yum中使用；</code></pre>  <pre><code class="hljs plaintext">yum客户端命令的使用：    yum [options] [command] [package ...]---------------------------yum的options选项：    --nogpgcheck：禁止进行gpg check；    -y: 自动回答为“yes”；    -q：静默模式；    --disablerepo=repoidglob：临时禁用此处指定的repo；    --enablerepo=repoidglob：临时启用此处指定的repo；    --noplugins：禁用所有插件；---------------------------1、列出所有可用repo列表    yum repolist &#123;enabled|disabled|all&#125;2、列出rpm包(可配合less查看)    yum list &#123;all|installed|available&#125;    yum list KEYWORD*3、查询指定的特性(可以是某文件)是由哪个程序包安装生成的    yum provides|whatprovides /path/to/somefile4、清理本地缓存    yum clean &#123;all|packages|metadata|expire-cache|rpmdb|plugins&#125;5、安装程序包    yum install package_name [package_name...]        如果从其它处获得一个rpm包，且此包依赖于其它包（在仓库中）,也可以使用&#x27;yum install /path/to/packe_file&#x27;来安装本地程序包    yum reinstall package_name [package_name...]   (重新/覆盖安装)6、升级程序包    yum check-update: 检查可用的升级包    yum update package_name    yum downgrade package_name  (降级)7、查看程序包的描述信息    yum info package_name8、卸载程序包    yum remove|erase package_name9、以指定的关键字搜索程序包名及summary信息    yum search string1 [string2] [...]10、查看指定包所依赖的capabilities：    yum deplist package1 [package2] [...]11、查看yum事务历史(yum每一次的安装/更新操作都会开启yum事务)    yumhistory [info|list|packages-list|packages-info|summary|addon-info|redo|undo|rollback|new|sync|stats]12、包组管理的相关命令    yum grouplist    yum groupinfo &quot;GROUP NAME&quot;    yum groupinstall &quot;GROUP NAME&quot;    yum groupupdate &quot;GROUP NAME&quot;    yum groupremove &quot;GROUP NAME&quot;</code></pre></li><li><code>源程序包编译安装</code>  <pre><code class="hljs plaintext">源代码组织格式：    多文件：文件中的代码之间，很可能存在跨文件依赖关系；    C、C++：make (configure --&gt; Makefile.in(makefile文件的模板) --&gt; makefile)    java：maven 开源程序源代码的获取：    官方自建站点：        apache.org (ASF)        mariadb.org        ...    代码托管：        SourceForge        Github.com        code.google.comC代码编译安装三步骤：    建议：安装前查看INSTALL，README    前提：提供开发工具及开发环境        开发工具：make(项目管理工具), gcc(gnu c complier,编译工具)等            autoconf: 生成configure脚本,即生成编译环境检查及编译功能配置脚本            automake：生成Makefile.in模板文件        开发环境：开发库，头文件            glibc：标准库        -------------------------            通过“包组”提供开发组件            CentOS 6: &quot;Development Tools&quot;, &quot;Server Platform Development&quot;,    (1) ./configure脚本：        (1) 通过选项传递参数，指定编译特性(启用特性、安装路径等)；执行时会参考用户的指定以及Makefile.in文件生成makefile；        (2) 检查依赖到的外部环境；        -------------------------        ./configure脚本的使用：            1、获取其支持使用的选项                ./configure --help            2、较通用的一些选项                安装路径相关：                    --prefix=/path/to/somewhere: 指定默认安装位置；默认为/usr/local/                    --sysconfdir=/path/to/somewhere: 指定配置文件安装路径                指定启用/禁用的特性：                    --enable-FEATURE: 例如--enable-fpm                    --disable-FEATURE: 例如--disable-socket                指定所依赖的功能、程序或文件：                    --with-FUNCTION[=/path/to/somewhere]                    --without-FUNCTION                    --with-PACKAGE[=ARG]                    --without-PACKAGE    (2) make：        根据makefile文件并调用相应的编译器来构建应用程序；    (3) make install：调用install命令来复制文件到指定位置当中去安装后的配置：    程序运行：        (1) 导出二进制程序目录至PATH环境变量中,(让二进制程序直接运行，而无须输入路径)            编辑文件/etc/profile.d/NAME.sh                export PATH=/PATH/TO/BIN:$PATH        (2) 导出帮助手册            编辑/etc/man.config文件                添加一个MANPATH，路径为新安装的程序的man目录    程序开发：如果其它应用程序依赖此程序的开发环境，或针对此程序做二次开发        (1) 导出库文件路径            编辑/etc/ld.so.conf.d/NAME.conf,指定让系统搜索定制的路径                添加新的库文件所在目录至此文件中；            触发系统重新搜索所有的库文件并生成缓存                ldconfig [-v]        (2) 导出头文件            系统找头文件的路径是：/usr/include            基于链接的方式实现：                ln -sv /usr/local/nginx/include /usr/include/nginx</code></pre></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统入门：Shell 脚本</title>
      <link href="/2019/01/02/os-linux-shell.html"/>
      <url>/2019/01/02/os-linux-shell.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-系统入门：Shell-脚本"><a href="#Linux-系统入门：Shell-脚本" class="headerlink" title="Linux 系统入门：Shell 脚本"></a>Linux 系统入门：Shell 脚本</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>shell脚本编程笔记…</p><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li><code>shebang</code>  <pre><code class="hljs plaintext">#!/bin/bash#!/usr/bin/python#!/usr/bin/perl</code></pre></li><li><code>运行脚本</code>  <pre><code class="hljs plaintext">1.给予执行权限,通过具体的文件路径指定文件执行    eg: ~]# ./first.sh2.直接运行解释器,将脚本作为解释器程序的参数运行</code></pre></li><li><code>bash自定义退出状态码</code>  <pre><code class="hljs plaintext">exit [n]：注：脚本中一旦遇到exit命令,脚本会立即终止;终止退出状态取决于exit命令后面的数字注：如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执行的最后一条命令的状态码</code></pre></li><li><code>bash脚本编程之用户交互</code>  <pre><code class="hljs plaintext"># read [option]... [name ...]    从标准输入读入一行,并可将其切割成字段对位放入变量中     -p &#x27;PROMPT&#x27;：添加提示信息        也可这样写：$ echo -n &quot;Enter a user name:&quot;;read name        对bash而言,在同一行中使用分号隔开,2个命令会顺序执行    -t TIMEOUT：设置命令等待的超时时间,单位为秒,在交互中用户如果超时没输入可以在脚本中给默认值# bash -n /path/to/some_script检测脚本中的语法错误,不能检查逻辑错误# bash -x /path/to/some_script    调试(单步)执行,它能显示其中执行的每一个代码的详细过程</code></pre>  <pre><code class="hljs plaintext">#!/bin/bash# Version: 0.0.1# Author: MageEdu# Description: read testingread -p &quot;Enter a disk special file: &quot; diskfile[ -z &quot;$diskfile&quot; ] &amp;&amp; echo &quot;Fool&quot; &amp;&amp; exit 1if fdisk -l | grep &quot;^Disk $diskfile&quot; &amp;&gt; /dev/null; then    fdisk -l $diskfileelse    echo &quot;Wrong disk special file.&quot;    exit 2fi</code></pre></li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>强类型：定义变量时必须指定类型，参与运算必须符合类型要求;调用未声明的变量会产生错误<br>弱类型：无需指定类型,默认均为字符型,参与运算会自动进行隐式转换;变量无须事先定义可直接调用</p><hr><ul><li><code>变量类型会决定数据存储格式,存储空间大小,参与运算种类</code>  <pre><code class="hljs plaintext">字符型：数值型：整型,浮点型    declare -i name：声明一个整型变量</code></pre></li><li><code>变量命名法则</code>  <pre><code class="hljs plaintext">1.不能使用程序中的保留字,如if,for等2.只能使用数字,字母及下划线,且不能以数字开头3.见名知义</code></pre></li><li><code>只读变量</code>  <pre><code class="hljs plaintext">readonly namedeclare -r name</code></pre></li><li><code>bash中变量种类</code>  <pre><code class="hljs plaintext">根据变量的生效范围等标准：本地变量：生效范围为当前shell进程,对当前shell之外的其它shell进程,当前shell的子进程均无效变量赋值：name=&quot;value&quot;,将赋值符号后面的数据存储于变量名指向的内存空间value：可以使用引用1.可以是直接字串：name=&quot;username&quot;2.变量引用：name=&quot;$username&quot;3.命令引用：name=`COMMAND`,name=$(COMMAND),命令执行的返回值变量引用：$&#123;name&#125;,$name单引号：强引用，其中的变量引用不会被替换为变量值,而保持原字符串双引号：弱引用，其中的变量引用会被替换为变量值显示已定义的所有变量：set销毁变量：unset name环境变量：生效范围为当前shell进程及其子进程变量声明\赋值：export name=VALUEdeclare -x name=VALUE变量引用：同本地变量显示所有环境变量：exportenvprintenv销毁变量：同本地变量局部变量：生效范围为当前shell进程中某代码片段(通常指函数)位置变量：用于让脚本在脚本代码中调用通过命令行传递给它的参数$1,$2,...：对应调用第1,第2等参数$0：命令本身$*：传递个脚本的所有参数(当做一个字符串)$@：传递个脚本的所有参数(多个字符串)$#：传递个脚本的参数的个数特殊变量：$?</code></pre>  <img src="/2019/01/02/os-linux-shell/os-linux-shell-001.png" alt="抱歉,图片休息了"></li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li><code>逻辑运算符</code>  <pre><code class="hljs plaintext">短路与：&amp;&amp;短路或：||逻辑异或：^逻辑非：!</code></pre></li><li><code>算数运算符</code>  <pre><code class="hljs plaintext">+,-,*,/,%,++,--,----------实现算数运算：1.let var=算数表达式2.var=$[算数表达式]3.var=$((算数表达式))4.var=$(expr arg1 arg2 arg3 ...)乘法符号有些场景中需要转义bash中有内建的随机数生成器：$RANDOM    eg: ~]# echo $[$RANDOM%60+1]</code></pre>  <img src="/2019/01/02/os-linux-shell/os-linux-shell-002.png" alt="抱歉,图片休息了"></li><li><code>赋值运算符</code>  <pre><code class="hljs plaintext">增强型赋值：+=,-=,*=,/=,%=,let varOPERvalueeg:let count+=1自增：let var+=1 &lt;==&gt; let var++自减：let var-=1 &lt;==&gt; let var--</code></pre></li></ul><h3 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h3><p>判断某需求是否满足,需要由测试机制来实现,专用的测试表达式需要由测试命令辅助完成测试过程.</p><hr><ul><li><code>测试命令</code>  <pre><code class="hljs plaintext">test EXPRESSION[ EXPRESSION ][[ EXPRESSION ]]注：EXPRESSION前后必须有空白字符,否则语法错误</code></pre></li><li><code>bash的测试类型</code>  <pre><code class="hljs plaintext">数值测试：-gt：是否大于-ge：是否大于等于-eq：是否等于-ne：是否不等于-lt：是否小于-le：是否小于等于字符串测试：==：是否等于也可以用=&gt;：是否大于&lt;：是否小于!=：是否不等于=~：左侧字符串是否能够被右侧的PATTERN所匹配此表达式一般用于[[  ]]中-z &quot;STRING&quot;：测试字符串是否为空,空则为真,不空则为假-n &quot;STRING&quot;：测试字符串是否为不空,不空则为真,空则为假注：用于字符串比较时用到的操作数都应该使用引号文件测试：存在性测试：-a FILE-e FILE：文件存在性测试，存在为真，否则为假存在性及类别测试：-b FILE：是否存在且为块设备文件-c FILE：是否存在且为字符设备文件-d FILE：是否存在且为目录文件-f FILE：是否存在且为普通文件-h/L FILE：是否存在且为符号链接文件-p FILE：是否存在且为命名管道文件-S FILE：是否存在且为套接字文件文件权限测试：-r FILE：是否存在且可读-w FILE：是否存在且可写-x FILE：是否存在且可执行文件特殊权限测试：-g FILE：是否存在且拥有sgid权限-u FILE：是否存在且拥有suid权限-k FILE：是否存在且拥有sticky权限文件大小测试：-s FILE：是否存在且非空文件是否打开测试：-t fd：fd表示文件描述符是否已经打开且与某终端相关-N FILE：文件自上一次被读取之后是否被修改过-O FILE：当前有效用户是否为文件属主-G FILE：当前有效用户是否为文件属组双目测试：FILE1 -ef FILE2：FILE1与FILE2是否指向同一个设备上的相同inodeFILE1 -nt FILE2：FILE1是否新于FILE2    常用于备份中FILE1 -ot FILE2：FILE1是否旧于FILE2    常用于备份中</code></pre>  <img src="/2019/01/02/os-linux-shell/os-linux-shell-003.png" alt="抱歉,图片休息了"></li><li><code>组合测试条件</code>  <pre><code class="hljs plaintext">逻辑运算：第一种方式：COMMAND1 &amp;&amp; COMMAND2COMMAND1 || COMMAND2! COMMAND第二种方式：必须使用测试命令进行EXPRESSION1 -a EXPRESSION2EXPRESSION1 -o EXPRESSION2! EXPRESSION</code></pre>  <img src="/2019/01/02/os-linux-shell/os-linux-shell-004.png" alt="抱歉,图片休息了"></li></ul><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><ul><li><code>顺序执行</code></li><li><code>选择执行</code>  <pre><code class="hljs plaintext">判断条件：    a. 根据bash命令的执行状态结果(true或false),具体取决于用到的命令     b. 测试命令if语句可嵌套使用</code></pre>  <pre><code class="hljs plaintext">单分支：    if 判断条件; then        条件为真的分支代码    fi双分支：    if 判断条件; then        条件为真的分支代码    else        条件为假的分支代码    fi多分支：自上而下进行条件判断，第一次遇到为“真”的条件时，执行其分支，而后结束；    if CONDITION1; then        if-true    elif CONDITION2; then        if-ture     elif CONDITION3; then        if-ture     ...    esle        all-false    fi</code></pre></li><li><code>循环执行</code>  <pre><code class="hljs plaintext">循环：    循环次数已知：遍历        for    循环次数未知：        while        until循环可以嵌套</code></pre>  <pre><code class="hljs plaintext">for循环：    for 变量名 in 列表; do        循环体(要执行的代码；可能要执行n遍)    done    ---------------------    执行机制：        依次将列表中的元素赋值给“变量名”; 每次赋值后都要执行一次循环体; 直到列表中的元素耗尽，循环结束;     列表生成方式：        (1) 直接给出列表；        (2) 整数列表；            (a) &#123;start..end&#125;            (b) $(seq [start [step]] end)         (3) 返回列表的命令；例如ls /var等等            $(COMMAND)        (4) 文件名通配机制；            例如for file in /var/*;do        (b) 变量引用；            $@, $*while循环：    while 测试条件; do        循环体    done    ---------------------    执行机制：        测试条件为真，进入循环；测试条件为假，退出循环；        测试条件一般通过变量来描述，需要在循环体不变量地改变变量的值，以确保某一时刻测试条件为假，进而结束循环；until循环：    until 测试条件; do        循环体    done    ---------------------    执行机制：        测试条件为假，进入循环；测试条件为真，退出循环；        测试条件一般通过变量来描述，需要在循环体不变量地改变变量的值，以确保某一时刻测试条件为真，进而结束循环；</code></pre></li></ul><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul><li>写一个脚本,实现如下功能:如果user1用户存在,就显示其存在,否则添加之;显示添加的用户的id号等信息  <pre><code class="hljs plaintext">#!/bin/bashid user1 &amp;&gt; /dev/null &amp;&amp; echo &quot;user1 exists.&quot; || useradd user1id user1</code></pre></li><li>写一个脚本,完成如下功能:如果root用户登录了当前系统,就显示root用户在线,否则说明其未登录  <pre><code class="hljs plaintext">#!/bin/bashw | grep &#x27;^root\&gt;&#x27; &amp;&gt; /dev/null &amp;&amp; echo &quot;root logged.&quot; || echo &quot;root not logged.&quot;</code></pre></li><li>写一个脚本,计算&#x2F;etc&#x2F;passwd文件中的第10个用户和第20个用户的ID之和  <pre><code class="hljs plaintext">#!/bin/bashuserid1=$(head -n 10 /etc/passwd | tail -n 1 | cut -d: -f3)userid2=$(head -n 20 /etc/passwd | tail -n 1 | cut -d: -f3)useridsum=$[$userid1+$userid2]echo &quot;uid sum: $useridsum&quot;</code></pre></li><li>写一个脚本,传递两个文件路径作为参数给脚本,计算这两个文件中所有空白行之和  <pre><code class="hljs plaintext">#!/bin/bashspaceline1=$(grep &#x27;^[[:space:]]*$&#x27; $1 | wc -l)spaceline2=$(grep &#x27;^[[:space:]]*$&#x27; $2 | wc -l)echo &quot;The sum of space line: $[$spaceline1+$spaceline2]&quot;</code></pre></li><li>写一个脚本,统计&#x2F;etc,&#x2F;var,&#x2F;usr目录中共有多少个一级子目录和文件  <pre><code class="hljs plaintext">#!/bin/bashsumEtc=$(ls -l /etc | grep &#x27;^[dbclsp]&#x27; | wc -l)sumVar=$(ls -l /var | grep &#x27;^[dbclsp]&#x27; | wc -l)sumUsr=$(ls -l /usr | grep &#x27;^[dbclsp]&#x27; | wc -l)echo &quot;The total count of files: $[$&#123;sumEtc&#125;+$&#123;sumVar&#125;+$&#123;sumUsr&#125;] lines.&quot;</code></pre></li><li>写一个脚本,接受一个文件路径作为参数,如果参数个数小于1,则提示用户”至少应该给一个参数”,并立即退出;如果参数个数不小于1,则显示第一个参数所指向的文件中的空白行数  <pre><code class="hljs plaintext">#!/bin/bash[ &quot;$#&quot; -lt 1 ] &amp;&amp; echo &quot;The must one arg.&quot; &amp;&amp; exit 20[ -e &quot;$1&quot; ] || &#123; echo &quot;No such file or directory&quot; &amp;&amp; exit 30;&#125;echo &quot;The blankspace is $(grep &#x27;^[[:space:]]*$&#x27; $1 | wc -l) lines.&quot;</code></pre></li></ul><hr><ul><li>写一个脚本,添加用户  <pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment">#</span><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -lt 1 ]; <span class="hljs-keyword">then</span>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;At least one argument.&quot;</span>        <span class="hljs-built_in">exit</span> 1<span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span> <span class="hljs-variable">$1</span> &amp;&gt; /dev/null; <span class="hljs-keyword">then</span>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span> exists.&quot;</span>        <span class="hljs-built_in">exit</span> 0<span class="hljs-keyword">else</span>        useradd <span class="hljs-variable">$1</span>        [ $? -eq 0 ] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> | passwd --stdin <span class="hljs-variable">$1</span> &amp;&gt; /dev/null &amp;&amp; <span class="hljs-built_in">exit</span> 0 || <span class="hljs-built_in">exit</span> 2<span class="hljs-keyword">fi</span></code></pre></li><li>用户键入文件路径，脚本来判断文件类型  <pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment">#</span><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Enter a file path: &quot;</span> filename<span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$filename</span>&quot;</span> ]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: Enter a file path.&quot;</span>    <span class="hljs-built_in">exit</span> 2<span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> [ ! -e <span class="hljs-variable">$filename</span> ]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;No such file.&quot;</span>    <span class="hljs-built_in">exit</span> 3<span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> [ -f <span class="hljs-variable">$filename</span> ]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;A common file.&quot;</span><span class="hljs-keyword">elif</span> [ -d <span class="hljs-variable">$filename</span> ]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;A directory.&quot;</span><span class="hljs-keyword">elif</span> [ -L <span class="hljs-variable">$filename</span> ]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;A symbolic file.&quot;</span><span class="hljs-keyword">else</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Other type.&quot;</span><span class="hljs-keyword">fi</span></code></pre></li></ul><hr><ul><li>添加10个用户, user1-user10；密码同用户名  <pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment">#</span><span class="hljs-keyword">if</span> [ ! <span class="hljs-variable">$UID</span> -eq 0 ]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Only root.&quot;</span>    <span class="hljs-built_in">exit</span> 1<span class="hljs-keyword">fi</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;1..10&#125;; <span class="hljs-keyword">do</span>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span> user<span class="hljs-variable">$i</span> &amp;&gt; /dev/null; <span class="hljs-keyword">then</span>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;user<span class="hljs-variable">$i</span> exists.&quot;</span>    <span class="hljs-keyword">else</span>        useradd user<span class="hljs-variable">$i</span>        <span class="hljs-keyword">if</span> [ $? -eq 0 ]; <span class="hljs-keyword">then</span>            <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;user<span class="hljs-variable">$i</span>&quot;</span> | passwd --stdin user<span class="hljs-variable">$i</span> &amp;&gt; /dev/null            <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Add user<span class="hljs-variable">$i</span> finished.&quot;</span>        <span class="hljs-keyword">fi</span>    <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span></code></pre></li><li>判断某路径下所有文件的类型  <pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment">#</span><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">ls</span> /var); <span class="hljs-keyword">do</span>    <span class="hljs-keyword">if</span> [ -f /var/<span class="hljs-variable">$file</span> ]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Common file.&quot;</span>    <span class="hljs-keyword">elif</span> [ -L /var/<span class="hljs-variable">$file</span> ]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Symbolic file.&quot;</span>    <span class="hljs-keyword">elif</span> [ -d /var/<span class="hljs-variable">$file</span> ]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Directory.&quot;</span>    <span class="hljs-keyword">else</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Other type.&quot;</span>    <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span></code></pre></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统入门：常用命令</title>
      <link href="/2018/12/31/os-linux-command.html"/>
      <url>/2018/12/31/os-linux-command.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-系统入门：常用命令"><a href="#Linux-系统入门：常用命令" class="headerlink" title="Linux 系统入门：常用命令"></a>Linux 系统入门：常用命令</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>记录一些常用命令…</p><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><h3 id="未分类"><a href="#未分类" class="headerlink" title="未分类"></a><em><strong>未分类</strong></em></h3><ul><li><code>which</code><ul><li>命令功能  <pre><code class="hljs plaintext">显示命令的完整路径</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# which [options] [--] programname [...]</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">--skip-alias:忽略别名</code></pre></li></ul></li><li><code>whereis</code><ul><li>命令功能  <pre><code class="hljs plaintext">增强版的which命令，会显示路径、源码文件、手册页</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# whereis [options] [-BMS directory... -f] name...</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-b：仅搜索二进制程序路径-m：仅搜索使用手册文件路径</code></pre></li></ul></li><li><code>whatis</code><ul><li>命令功能  <pre><code class="hljs plaintext">查看COMMAND在哪些章节下有手册    使用mkwhatis命令可将当前系统上所有的帮助手册及与之对应的关键字创建为一个数据库,并且此数据库当中会保存关键字的简要说明信息    whatis能够在数据库里以我们指定的关键字去查找相应的说明</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# whatis [-dlv?V] [-r|-w] [-s list] [-m system[,...]] [-M path] [-L locale] [-C file] name ...</code></pre></li></ul></li><li><code>echo</code><ul><li>命令功能  <pre><code class="hljs plaintext">常用于显示变量值</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# echo [SHORT-OPTION]... [STRING]...    STRING可以使用引号，单引号和双引号均可用</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-n：不进行换行-e：让转义生效\n：换行\t：制表符</code></pre></li><li>命令实例  <pre><code class="hljs plaintext">[root@host ~]# echo &quot;how \tare you&quot;how \tare you[root@host ~]# echo -e &quot;how \tare you&quot;how     are you[root@host ~]# echo -e &quot;how \nare you&quot;how are you[root@host ~]# echo &#x27;$SHELL&#x27;$SHELL[root@host ~]# echo &quot;$SHELL&quot;/bin/bash</code></pre></li></ul></li><li><code>watch</code><ul><li>命令功能  <pre><code class="hljs plaintext">阶段性地执行指定的COMMAND</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# watch [-n #] &lt;COMMAND&gt;</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-n #: 指定刷新间隔时间，单位是秒</code></pre></li><li>命令实例  <pre><code class="hljs plaintext">[root@host ~]watch -n1 &#x27;ifconfig eth0&#x27;</code></pre></li></ul></li></ul><h3 id="待处理"><a href="#待处理" class="headerlink" title="待处理"></a><em><strong>待处理</strong></em></h3><pre><code class="hljs plaintext">virt-what   用于查看服务器是kvm还是xen架构的虚拟化netstat -tunlp | grep 端口号    用于查看指定端口号的进程情况-t  tcp协议相关-u  udp协议相关-n  以数字显示IP和端口-l  处于监听状态-p  显示相关进程及PIDps：显示进程状态    常用组合：aux        u: 以用户为中心组织进程状态信息显示        a: 与终端相关的进程；        x: 与终端无关的进程；    常用组合：-ef        -e: 显示所有进程        -f: 显示完整格式程序信息    # ps -Lf pid | wc -l 查看线程个数（方便查看程序是否有误）top：显示当前系统中耗费资源最多的进程    有许多内置命令：        排序：            P：以占据的CPU百分比；            M：占据内存百分比；            T：累积占据CPU时长；        首部信息显示：            uptime信息：l命令            tasks及cpu信息：t命令                cpu分别显示：1 (数字)            memory信息：m命令        退出命令：q        修改刷新时间间隔：s        终止指定进程：k    选项：        -d #: 指定刷新时间间隔，默认为3秒；        -b: 以批次方式；        -n #: 显示多少批次；kill：向进程发送控制信号，以实现对进程管理    显示当前系统可用信号：        # kill -l        # man 7 signal    常用信号：        1) SIGHUP: 无须关闭进程而让其重读配置文件；        2) SIGINT: 中止正在运行的进程；相当于Ctrl+c；        9) SIGKILL: 杀死正在运行的进程；        15) SIGTERM：终止正在运行的进程；        18) SIGCONT：        19) SIGSTOP：    指定信号的方法：        (1) 信号的数字标识；1, 2, 9        (2) 信号完整名称；SIGHUP        (3) 信号的简写名称；HUP    向进程发信号：        kill [-SIGNAL] PID...lsof -i:端口号    用于查看某一端口的占用情况crontab：定时任务    crontab [-u user] [-l | -r | -e] [-i]         -l: 列出所有任务；        -e: 编辑任务；        -r: 移除所有任务；        -i：同-r一同使用，以交互式模式让用户有选择地移除指定任务；        -u user: 仅root可运行，代为为指定用户管理cron任务；chkconfig：开机自启    --list：查看哪些服务开机自动运行    --add SRV_SCRIPT：添加脚本到开机自动启动项目中    --del SRV_SCRIPT：删除    SRV_SCRIPT on｜off：配置某服务是否开机自动运行wget：网络客户端工具    wget [option]... [URL]...        -q: 静默模式        -c: 续传        -P 指定下载文件的存放目录        -O 指定下载文件的名字，重命名        --limit-rates=: 指定传输速率rzszscphostname: 查看主机名</code></pre><h3 id="日期相关"><a href="#日期相关" class="headerlink" title="日期相关"></a><em><strong>日期相关</strong></em></h3><pre><code class="hljs plaintext">主板上有个纽扣电池为主板上的硬件时钟(晶体振荡器)供电，所以关机后再开机时间也是对的Linux系统启动时从硬件时钟读取日期和时间信息，读取完成以后，就不再与硬件相关联，并设为当前系统时间，之后靠内核振动次数计时（100次1秒）如时间不对，还可以和全球的时间服务器进行对表，精确度很高，最精确的是元子震荡时钟，价值1亿英镑系统时钟:由linux内核通过cpu的工作频率进行的计时硬件时钟</code></pre><ul><li><code>date</code><ul><li>命令功能  <pre><code class="hljs plaintext">显示或设定系统时钟</code></pre></li><li>命令格式  <pre><code class="hljs bash">~]<span class="hljs-comment"># date [OPTION]... [+FORMAT]</span>~]<span class="hljs-comment"># date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</span></code></pre></li><li>命令参数  <pre><code class="hljs plaintext">FORMAT：格式符date +&quot;%F %T&quot;      2016-04-12 20:35:20date +%Y-%m-%d-%H-%M-%S         2016-04-12-20-41-17date +%s           从1970年1月1号（unix元年）</code></pre></li></ul></li><li><code>clock/hwclock</code><ul><li>命令功能  <pre><code class="hljs plaintext">显示或设定硬件时钟</code></pre></li><li>命令格式  <pre><code class="hljs bash">~]<span class="hljs-comment"># hwclock [function] [option...]</span></code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-s ,--hctosys ：以硬件为准，把系统时间调整为与硬件时钟相同-w ,--systohc ：以系统为准，把硬件时间调整为与系统时钟相同</code></pre></li></ul></li><li><code>cal</code><ul><li>命令功能  <pre><code class="hljs plaintext">日历</code></pre></li><li>命令格式  <pre><code class="hljs bash">~]<span class="hljs-comment"># cal [options] [[[day] month] year]</span></code></pre></li></ul></li></ul><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a><em><strong>目录操作</strong></em></h3><ul><li><code>pwd</code><ul><li>命令功能  <pre><code class="hljs plaintext">printing working directory,显示工作目录(当前目录)    一定意义上是读取$PWD变量的内容并显示</code></pre></li><li>命令格式  <pre><code class="hljs bash">~]<span class="hljs-comment"># pwd [OPTION]...</span></code></pre></li></ul></li><li><code>cd</code><ul><li>命令功能  <pre><code class="hljs plaintext">change directory,切换工作目录(当前目录)----------相关的环境变量：PWD：保存了当前工作目录的路径OLDPWD：保存了上一次的工作目录的路径cd后面可以跟相对路径和绝对路径，根据实际需求选择用哪个，相对路径中.或..经常使用</code></pre></li><li>命令格式  <pre><code class="hljs bash">~]<span class="hljs-comment"># cd [-L|[-P [-e]]] [/PATH/TO/SOMEDIR]</span></code></pre></li><li>常用操作  <pre><code class="hljs plaintext">~]# cd：切换回家目录，注意：bash中，~表示家目录(主目录)~]# cd ~：切换回自己的家目录~]# cd ~USERNAME：切换至指定用户的家目录~]# cd -：在上一次所在目录与当前目录之间来回切换,一定意义上是执行了cd $OLDPWD</code></pre></li></ul></li><li><code>ls</code><ul><li>命令功能  <pre><code class="hljs plaintext">list,显示指定路径下的文件列表</code></pre></li><li>命令格式  <pre><code class="hljs bash">~]<span class="hljs-comment"># ls [OPTION]... [FILE]...</span></code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-a,--all：显示所有文件，包括隐藏文件-A：显示除.和..之外的所有文件-l：长格式列表，即显示文件的详细属性信息-rw-------. 1 root root 1302 4月   4 22:39 initial-setup-ks.cfg-：指的是Linux系统上的文件类型，并非通过file命令查看的文件内容格式的类型-：普通(常规)文件，即f，有诸多变种格式，可通过file命令查看d：directory，目录文件b：block device，块设备文件，支持以&quot;block&quot;为单位进行随机访问c：character device，字符设备文件，支持以&quot;character&quot;为单位进行线性访问major number：主设备号，用于标识设备类型，进而确定要加载的驱动程序minor number：次设备号，用于标识同一类型中的不同设备l：sysmbolic link，符号链接文件s：socket，套接字文件;有很多服务器支持2种方式通信,如果跨主机只能基于协议通信,如果不跨主机建议使用套接字文件的方式通信p：pipe，(命名)管道文件rw-------：访问权限rw-：文件属主的权限---：文件属组的权限---：其他用户（非属主、属组）的权限1：表示文件被硬链接的次数root：文件的属主(owner)root：文件的属组(group)1302：表示文件的大小(size)，单位是字节4月   4 22:39：文件最近一次被修改的时间    注:每个文件都有3个时间戳(访问,修改,改变),修改指的是文件内容发生的改变,改变指的是文件的属性发生的改变;修改一定会改变,改变不一定会修改initial-setup-ks.cfg：文件名-h：对文件大小单位换算，换算后结果可能为非精确值-d：显示目录自身的相关属性而非其内部的文件列表，一般与-l结合使用-r：reverse，逆序显示,没有-r时默认升序显示-R：recursive，递归显示</code></pre></li><li>命令实例  <pre><code class="hljs bash">[root@host ~]<span class="hljs-comment"># ls -lhd /etc</span>drwxr-xr-x. 79 root root 4.0K Dec 24 19:42 /etc</code></pre></li></ul></li><li><code>basename</code><ul><li>命令功能  <pre><code class="hljs plaintext">显示路径的基名</code></pre></li><li>命令格式  <pre><code class="hljs bash">~]<span class="hljs-comment"># basename /PATH/TO/SOMEFILE</span>    SOMEFILE</code></pre></li></ul></li><li><code>dirname</code><ul><li>命令功能  <pre><code class="hljs plaintext">显示路径的目录名</code></pre></li><li>命令格式  <pre><code class="hljs bash">~]<span class="hljs-comment"># dirname /PATH/TO/SOMEFILE</span>    /PATH/TO</code></pre></li></ul></li></ul><h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a><em><strong>目录管理</strong></em></h3><ul><li><code>mkdir</code><ul><li>命令功能  <pre><code class="hljs plaintext">make directories</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# mkdir [OPTION]... DIRECTORY...</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-p：自动按需创建父目录;不会报错,即便目录已经存在-v：verbose，显示详细过程-m MODE：创建目录时直接给定权限</code></pre></li></ul></li><li><code>rmdir</code><ul><li>命令功能  <pre><code class="hljs plaintext">remove empty directories</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# rmdir [OPTION]... DIRECTORY...</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-p：删除某目录后，如果其父目录为空，则一并删除之-v：显示过程</code></pre></li></ul></li><li><code>tree</code><ul><li>命令功能  <pre><code class="hljs plaintext">以树状结构来显示目录的层级结构</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# tree [options] [directory]</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-d：只显示目录-L level：指定要显示的层级，如果不指定则显示所有的层级-P pattern：只显示由指定pattern匹配到的路径</code></pre></li></ul></li></ul><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a><em><strong>文件管理</strong></em></h3><ul><li><p><code>dd</code></p><ul><li>命令功能  <pre><code class="hljs plaintext">convert and copy a file(转换并复制文件),cp是通过文件系统复制的,而dd是通过块接口复制的,虽然都是复制但dd要底层的多,效率更高</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# dd if=/PATH/FROM/SRC of=/PATH/TO/DEST [OPTIONS...]</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">bs=#：block size, 复制单元大小,单位是字节；count=#：复制多少个bs；</code></pre></li><li>命令实例  <pre><code class="hljs plaintext">磁盘拷贝：    ~]# dd if=/dev/sda of=/dev/sdb备份MBR：    ~]# dd if=/dev/sda of=/tmp/mbr.bak bs=512 count=1破坏MBR中的bootloader：使用bs=512可以快速清除磁盘上的分区表    ~]# dd if=/dev/zero of=/dev/sda bs=256 count=1        两个特殊设备：        /dev/null: 数据黑洞；        /dev/zero：吐零机；</code></pre></li></ul></li><li><p><code>cp</code></p><ul><li>命令功能  <pre><code class="hljs plaintext">copy,默认下源文件不能是目录，除非加上相应的选项-r</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">单源复制：cp [OPTION]... [-T] SOURCE DEST如果DEST不存在，则事先创建此文件，并复制源文件的数据流至DEST中如果DEST存在如果DEST是非目录文件，则覆盖目标文件,此时建议使用-i选项如果DEST是目录文件，则先在DEST目录下创建一个与源文件同名的文件，并复制其数据流多源复制：cp [OPTION]... SOURCE... DIRECTORYcp [OPTION]... -t DIRECTORY SOURCE...    前一形式的变种如果DEST不存在，错误如果DEST存在如果DEST是非目录文件，错误如果DEST是目录文件，分别复制每个文件至目标目录中，并保持原名</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-i：交互式复制，即覆盖之前提醒用户确认-f：强制覆盖目标文件-r,-R：递归复制目录及内部的所有内容-d：复制符号链接文件本身，而非其指向的源文件-a：相当于-dR --preserve=all          archive，用于实现归档(备份)--preserve=mode：权限ownership：属主和属组timestamps：时间戳context：安全标签xattr：扩展属性links：符号链接all：上述所有属性-v：verbose，显示详细过程</code></pre></li></ul></li><li><p><code>mv</code></p><ul><li>命令功能  <pre><code class="hljs plaintext">move(rename),此时源文件不区分目录或是文件;如果source和dest都在同一目录,即是重命名操作</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# mv [OPTION]... [-T] SOURCE DEST~]# mv [OPTION]... SOURCE... DIRECTORY~]# mv [OPTION]... -t DIRECTORY SOURCE...前一形式的变种</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-i：交互式移动，即移动之前提醒用户确认-f：强制移动</code></pre></li></ul></li><li><p><code>rm</code></p><ul><li>命令功能  <pre><code class="hljs plaintext">remove,默认下不能删除目录的，除非加上相应的选项-r    注意：所有不用的文件建议不要直接删除，而是移动至某个专用目录。也就是模拟回收站。</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# rm [OPTION]... FILE...</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-i：interactive,删除时提醒,管理员账号默认加上此选项-f：force,删除时不提醒-r,-R：recursive删除目录</code></pre></li><li>命令实例  <pre><code class="hljs plaintext">例如：rm -rf /PATH/TO/DIR危险操作：rm -rf /*</code></pre></li></ul></li></ul><h3 id="文本文件查看"><a href="#文本文件查看" class="headerlink" title="文本文件查看"></a><em><strong>文本文件查看</strong></em></h3><ul><li><code>cat</code><ul><li>命令功能  <pre><code class="hljs plaintext">文件连接并显示的命令</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# cat [OPTION]... [FILE]...</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-n：给显示的文本行编号-E：显示行结束符$，文本文件在磁盘上存储是没有行的，之所以显示出有行，是因为文本文件查看工具可以读取行结束符并将他们显示为行</code></pre></li></ul></li><li><code>tac</code><ul><li>命令功能  <pre><code class="hljs plaintext">与cat命令相反显示文件文件内容</code></pre></li></ul></li><li><code>more</code><ul><li>命令功能  <pre><code class="hljs plaintext">分页显示文本文件内容，空格向后，b向前特点：操作方式同man命令,翻屏至文件尾部后自动退出</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# more [OPTION...] FILE...</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-d：显示翻页及退出提示</code></pre></li></ul></li><li><code>less</code><ul><li>命令功能  <pre><code class="hljs plaintext">分页显示文本文件内容，空格向后，b向前特点：man命令就是调用less命令</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# less [OPTION...] FILE...</code></pre></li></ul></li><li><code>head</code><ul><li>命令功能  <pre><code class="hljs plaintext">查看文件的前n行</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# head [OPTION...] FILE...</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-c #：指定获取前#字节-n #：指定获取前#行-#：简写没有该选项默认10行</code></pre></li></ul></li><li><code>tail</code><ul><li>命令功能  <pre><code class="hljs plaintext">查看文件的后n行注：tailf命令等同于tail -f -n 10</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# tail [OPTION...] FILE...</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-c #：指定获取后#字节-n #：指定获取后#行-#：简写没有该选项默认10行-f：查看文件尾部内容结束后不退出，跟随显示新增的行。常用于人工监控日志增长的新行内容-F：同上，与f不同的是会保持重试，即该文件被删除或改名后，如果再次创建相同的文件名，会继续追踪，而f会停止追踪</code></pre></li></ul></li></ul><h3 id="文本文件处理"><a href="#文本文件处理" class="headerlink" title="文本文件处理"></a><em><strong>文本文件处理</strong></em></h3><ul><li><code>wc</code><ul><li>命令功能  <pre><code class="hljs plaintext">统计文本的行数,单词数,字符数/字节数</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# wc [OPTION...] FILE...</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-l：lines-w：words-c：characters</code></pre></li><li>命令实例  <pre><code class="hljs plaintext">[root@host ~]# ifconfigeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 144.34.204.26  netmask 255.255.224.0  broadcast 144.34.223.255        inet6 fe80::a8aa:ff:fe12:2acd  prefixlen 64  scopeid 0x20&lt;link&gt;        ether aa:aa:00:12:2a:cd  txqueuelen 1000  (Ethernet)        RX packets 258312  bytes 18661074 (17.7 MiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 224427  bytes 24548808 (23.4 MiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (Local Loopback)        RX packets 64  bytes 5568 (5.4 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 64  bytes 5568 (5.4 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0[root@host ~]# ifconfig | wc -l18</code></pre></li></ul></li><li><code>cut</code><ul><li>命令功能  <pre><code class="hljs plaintext">以指定字符作为分隔符对每行进行切割</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# cut OPTION... FILE...</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-d DELIMITER：指明分隔符,默认空白字符-f FILEDS：要显示哪些字段#：第#个字段#,#[,#]：离散的多个字段,例如1,3,6#-#：连续的多个字段,例如1-6混合使用：1-3,7--output-delimiter=STRING：修改输出时的分隔符</code></pre></li><li>命令实例  <pre><code class="hljs plaintext">[root@host ~]# cat /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologingames:x:12:100:games:/usr/games:/sbin/nologinftp:x:14:50:FTP User:/var/ftp:/sbin/nologinnobody:x:99:99:Nobody:/:/sbin/nologinsystemd-bus-proxy:x:999:998:systemd Bus Proxy:/:/sbin/nologinsystemd-network:x:192:192:systemd Network Management:/:/sbin/nologindbus:x:81:81:System message bus:/:/sbin/nologinpolkitd:x:998:997:User for polkitd:/:/sbin/nologintss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologinsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologinpostfix:x:89:89::/var/spool/postfix:/sbin/nologinchrony:x:997:995::/var/lib/chrony:/sbin/nologin[root@host ~]# cut -d: -f1,7 --output-delimiter=&#x27; &#x27; /etc/passwdroot /bin/bashbin /sbin/nologindaemon /sbin/nologinadm /sbin/nologinlp /sbin/nologinsync /bin/syncshutdown /sbin/shutdownhalt /sbin/haltmail /sbin/nologinoperator /sbin/nologingames /sbin/nologinftp /sbin/nologinnobody /sbin/nologinsystemd-bus-proxy /sbin/nologinsystemd-network /sbin/nologindbus /sbin/nologinpolkitd /sbin/nologintss /sbin/nologinsshd /sbin/nologinpostfix /sbin/nologinchrony /sbin/nologin</code></pre></li></ul></li><li><code>sort</code><ul><li>命令功能  <pre><code class="hljs plaintext">对文件内容进行排序</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# sort [OPTION...] FILE...</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-f：忽略字符大小写-r：逆序排序-t DELIMITER：字段分隔符-k #：以指定字段为标准排序-n：以数值大小进行排序,默认是以字符进行排序-u：uniq,排序后去重</code></pre></li><li>命令实例  <pre><code class="hljs plaintext">~]# sort -t: -k3 -n /etc/passwd | tail -1 | cut -d: -f1  #显示/etc/passwd文件中ID号最大的用户的用户名~]# history | cut -d&#x27;&#x27; -f5 | sort -u</code></pre></li></ul></li><li><code>uniq</code><ul><li>命令功能  <pre><code class="hljs plaintext">对文件中连续且完全相同的内容去重,一般先排序再去重</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# uniq [OPTION...] FILE...</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-c：显示每行重复出现的次数-d：仅显示重复过的行-u：仅显示不曾重复的行</code></pre></li><li>命令实例  <pre><code class="hljs plaintext">~]# history | cut -d&#x27;&#x27; -f5 | sort | uniq -c</code></pre></li></ul></li></ul><h3 id="文件的时间戳管理"><a href="#文件的时间戳管理" class="headerlink" title="文件的时间戳管理"></a><em><strong>文件的时间戳管理</strong></em></h3><ul><li><code>stat</code><ul><li>命令功能  <pre><code class="hljs plaintext">display file or file system status,显示文件的元数据信息---------------------文件：两类数据元数据：metadata数据：data时间戳：每个文件都有3个时间戳最近访问时间(access time)：2016-04-24 21:20:42.477903125 +0800   读取文件内容最近修改时间(modify time)：2016-04-24 20:40:08.887958504 +0800数据(文件内容)改变最近改变时间(change time)：2016-04-24 20:40:08.887958504 +0800元数据改变</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# stat [OPTION]... FILE...</code></pre></li></ul></li><li><code>touch</code><ul><li>命令功能  <pre><code class="hljs plaintext">change file timestamps,修改文件元数据中的时间戳信息(atime或mtime改了ctime也会改),也可以创建文件</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# touch [OPTION]... FILE...</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-c：指定的文件路径不存在时，默认会创建空文件，使用此选项时将不予创建。-a：仅修改access time-m：仅修改modify time-t STAMP：[[CC]YY]MMDDhhmm[.ss]</code></pre></li></ul></li></ul><h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a><em><strong>系统管理</strong></em></h3><ul><li><code>关机/重启命令</code>  <pre><code class="hljs plaintext">CentOS 7：~]# systemctl poweroff~]# systemctl reboot*（通用）：~]# poweroff || ~]# halt~]# reboot-f：强制,不调用shuwdown-p：切断电源shutdown：安全关机重启方式,会先保存未保存的数据shutdown [OPTIONS...] TIME [MESSAGE]OPTIONS：-h：halt  关机-r：reboot  重启-c：cancel  取消关机或重启TIME：now：立刻hh:mm：绝对时间表示法,指明具体时间+m：相对时间表示法,从命令提交开始多久之后,例如+3,单位是分钟MESSAGE：关机或重启提示语</code></pre></li><li><code>用户登录信息查看命令</code>  <pre><code class="hljs plaintext">whoami：显示当前登录的有效用户who：查看系统当前所有的登录信息(会话)who [option]... ，-b：系统此次启动的时间-r：运行级别w：增强版的who命令，查看系统当前所有的登录信息(会话)及所做的操作</code></pre></li></ul><h3 id="用户和组管理"><a href="#用户和组管理" class="headerlink" title="用户和组管理"></a><em><strong>用户和组管理</strong></em></h3><ul><li><code>id</code><ul><li>命令功能  <pre><code class="hljs plaintext">查看用户相关的ID信息</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# id [OPTION]... [USER]</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-u：UID-g：GID-G：Groups</code></pre></li></ul></li><li><code>su</code><ul><li>命令功能  <pre><code class="hljs plaintext">切换用户或以其他用户身份执行命令----------------切换用户的方式：su Username：非登录式切换,即不会读取目标用户的配置文件su - Username：登录式切换(完全切换),即会读取目标用户的配置文件注：root su至其他用户无须密码,非root用户切换时需要密码</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# su [options...] [-] [user [args...]]</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-c &#x27;COMMAND&#x27;：换个身份执行命令</code></pre></li><li>命令实例  <pre><code class="hljs plaintext">~]# su - user7 -c &#x27;echo $PATH&#x27;</code></pre></li></ul></li><li><code>useradd</code><ul><li>命令功能  <pre><code class="hljs plaintext">用户创建</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# useradd [options] LOGIN</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-u UID：[UID_MIN,UID_MAX],最小值和最大值定义在/etc/login.defs文件中没有该选项默认使用最近一个最大UID值+1-g GID：指明用户所属基本组,可为组名,也可为GID,组必须事先存在-c &quot;COMMENT&quot;：指明用户的注释信息-d /PATH/TO/HOME_DIR：指明用户的家目录,一般来讲此目录事先不要已存在-s SHELL：指明用户的默认shell,可用shell列表在/etc/shells文件中-G GROUP1[,GROUP2,...[,GROUPN]]：指明用户的附加组,组必须事先存在-r：创建系统用户-D 选项：默认值设定,可在/etc/default/useradd文件中查看</code></pre></li><li>命令实例  <pre><code class="hljs plaintext">~]# useradd -D -s /bin/tcsh</code></pre></li></ul></li><li><code>usermod</code><ul><li>命令功能  <pre><code class="hljs plaintext">用户属性修改</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# usermod [options] LOGIN</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-u UID：新UID-g GID：新GID-G GROUP1[,GROUP2,...[,GROUPN]]：新附加组,原来的附加组将会被覆盖;若要保留原有,则要同时使用-a选项,表示append-c &quot;COMMENT&quot;：新的注释信息-d /PATH/TO/HOME_DIR：新的家目录,原有家目录中的文件不会同时移动至新的家目录;若要移动,则同时使用-m选项-s SHELL：新的默认shell-l login_name：新的名-------L：lock指定用户-U：unlock指定用户-------e YYYY-MM-DD：指明用户账号过期日期-f INACTIVE：设定非活动期限</code></pre></li></ul></li><li><code>userdel</code><ul><li>命令功能  <pre><code class="hljs plaintext">用户删除</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# userdel [OPTION]... LOGIN</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">&#x27;-r：删除用户家目录,默认不删除用户的家目录</code></pre></li></ul></li><li><code>groupadd</code><ul><li>命令功能  <pre><code class="hljs plaintext">组添加</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# groupadd [OPTIONS...] group_name</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-g GID：指定GID，[GID_MIN,GID_MAX],最小值和最大值定义在/etc/login.defs文件中没有该选项默认是上一个组的GID+1-r：创建系统组</code></pre></li><li>命令实例  <pre><code class="hljs plaintext">~]# groupadd -r -g 306 mariadb   创建一个系统组mariadb，并且指定GID为306</code></pre></li></ul></li><li><code>groupmod</code><ul><li>命令功能  <pre><code class="hljs plaintext">组属性修改</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# groupmod [OPTIONS...] GROUP</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-g GID：修改GID</code></pre></li><li>命令实例  <pre><code class="hljs plaintext">~]# groupmod -g 702 mariadb    group -n  perconaserver mariadb</code></pre></li></ul></li><li><code>groupdel</code><ul><li>命令功能  <pre><code class="hljs plaintext">组删除</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# groupdel [选项] GROUP</code></pre></li></ul></li><li><code>passwd</code><ul><li>命令功能  <pre><code class="hljs plaintext">给用户添加密码</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# passwd [OPTIONS] UserName：修改指定用户的密码 ,仅root用户权限~]# passwd：修改自己的密码</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-l：锁定指定用户-u：解锁指定用户-n mindays：指定最短使用期限-x maxdays：指定最大使用期限-w warndays：提前多少天开始警告-i inactivedays：非活动期限-S：查看最后一次密码修改的日期--stdin：从标准输入接收用户密码,passwd默认是交互式的从标准输入接收密码</code></pre></li><li>命令实例  <pre><code class="hljs plaintext">echo &quot;PASSWORD&quot; | passwd --stdin USERNAME~]# echo &#x27;centos&#x27; |passwd --stdin user1 &amp;&gt; /dev/null~]# echo $?</code></pre></li></ul></li><li><code>gpasswd</code><ul><li>命令功能  <pre><code class="hljs plaintext">组密码添加</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# gpassed [OPTION]... GROUP</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-u user：将user添加至指定组中-d user：删除用户user的以当前组为组名的附加组-A user1,user2,...：设置有管理权限的用户列表</code></pre></li></ul></li><li><code>newgrp</code><ul><li>命令功能  <pre><code class="hljs plaintext">临时切换基本组    如果用户本不属于此组,则需要密码</code></pre></li></ul></li><li><code>chage</code><ul><li>命令功能  <pre><code class="hljs plaintext">修改用户属性(密码相关)</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# chage [OPTION]... LOGIN</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">-d：LAST_DAY-E,--expiredate EXPIRE_DATE-I,--inactive INACTIVE-m,--mindays MIN_DAYS-M,--maxdays MAX_DAYS-W,--warndays WARN_DAYS</code></pre></li></ul></li></ul><h3 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a><em><strong>文件权限管理</strong></em></h3><ul><li><code>chmod</code><ul><li>命令功能  <pre><code class="hljs plaintext">change mode,修改文件权限</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# chmod [OPTION]... OCTAL-MODE FILE...-R：递归修改权限~]# chmod [OPTION]... MODE[,MODE]... FILE...MODE：修改一类用户的所有权限：u=g=o=ug=a=u=,g=修改一类用户的某位或某些权限u+u-~]# chmod [OPTION]... --reference=RFILE FILE...参考RFILE文件的权限,将FILE的权限修改为同RFILE</code></pre></li><li>命令实例  <pre><code class="hljs plaintext">[root@host ~]# chmod 640 a.txt----------[root@host ~]# chmod u=rwx a.txt[root@host ~]# chmod g= a.txt[root@host ~]# chmod ug=rw a.txt[root@host ~]# chmod u=rwx,g=r a.txt[root@host ~]# chmod a=r a.txt----------[root@host ~]# chmod u+w,o-r a.txt[root@host ~]# chmod +x a.txt----------[root@host ~]# chmod --reference=./c.txt a.txt</code></pre></li></ul></li><li><code>chown</code><ul><li>命令功能  <pre><code class="hljs plaintext">修改文件的属主,仅root可用</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# chown [OPTION]... [OWNER][:[GROUP]] FILE...-R：递归命令中的冒号可用.替换用法：OWNEROWNER:GROUP:GROUP~]# chown [OPTION]... --reference=RFILE FILE...</code></pre></li><li>命令实例  <pre><code class="hljs plaintext">[root@host ~]# chown tom fstab[root@host ~]# chown jerry:jerry fstab[root@host ~]# chown :root fstab[root@host ~]# chown -R tom:tom /home/fedora</code></pre></li></ul></li><li><code>chgrp</code><ul><li>命令功能  <pre><code class="hljs plaintext">修改文件的属组,仅root可用</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# chgrp [OPTION]... GROUP FILE...~]# chgrp [OPTION]... --reference=RFILE FILE...</code></pre></li></ul></li></ul><h3 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a><em><strong>文本编辑</strong></em></h3><p><strong>行编辑器</strong></p><ul><li><code>sed</code><ul><li>命令功能  <pre><code class="hljs plaintext">==&gt; Linux文本处理三剑客</code></pre></li></ul></li></ul><p><strong>全屏编辑器</strong></p><ul><li><code>nano</code><ul><li>常用操作  <pre><code class="hljs plaintext">^O，Ctrl+O，保存当前文件^X，Ctrl+X，退出编辑文本^W，Ctrl+W，搜索文本位置-------------------^G，Ctrl+G，显示帮助文本^R，Ctrl+R，读取其他文件并插入光标位置^Y，Ctrl+Y，跳至上一屏幕^K，Ctrl+K，剪切当前一行^C，Ctrl+C，显示光标位置^J，Ctrl+J，对其当前段落（以空格为分隔符）^V，Ctrl+V，跳至下一屏幕^U，Ctrl+U，粘贴文本至光标处^T，Ctrl+T，运行拼写检查</code></pre></li></ul></li><li><code>vi</code><ul><li>命令功能  <pre><code class="hljs plaintext">Visual Interface(可视化接口),vim的前身,linux上著名的功能极其强大的入门曲线非常陡峭的文本编辑器</code></pre></li></ul></li><li><code>vim</code><ul><li>命令功能  <pre><code class="hljs plaintext">Vi IMproved(vi增强版),可视化模式化的编辑</code></pre></li><li>常用操作  <pre><code class="hljs plaintext">打开文件：~]# vim [OPTION]... FILE...+#：打开文件后，直接让光标处于第#行的行首;没有#光标默认处于尾部+/PATTEN：打开文件后，直接让光标处于第一个被PATTEN匹配到的行的行首关闭文件：:q退出:q!强制退出,丢弃做出的修改:wq保存退出:x保存退出ZZ保存退出(命令模式下)基本模式：编辑模式：也叫命令模式，默认处于此模式，对文本进行复制，剪切， 粘贴等输入模式：也叫插入模式，对文件内容进行编辑末行模式：内置的命令行接口，可实现许多强大的功能模式转换：编辑模式--&gt;输入模式i：insert,在光标所在处输入a：append,在光标所在处后面输入o：open,在当前光标所在行的下方打开一个新行输入I：在当前光标所在行的行首输入A：在当前光标所在行的行尾输入O：在当前光标所在行的上方打开一个新行输入c：change,C：输入模式--&gt;编辑模式ESC编辑模式--&gt;末行模式:末行模式--&gt;编辑模式ESC光标跳转：字符间跳转：h(左),j(下),k(上),l(右)#COMMAND：跳转由#指定一次跳转的字符数单词间跳转：w：下一个单词的词首e：当前或下一个单词的词尾b：当前或前一个单词的词首#COMMAND：跳转由#指定一次跳转的单词数行首行尾跳转：^：跳转至行首的第一个非空白字符0：跳转至行首$：跳转至行尾行间移动：#G：跳转至由#指定行G：跳转至最后一行1G或gg：跳转至第一行句间移动：了解即可)(段落间移动：了解即可&#125;&#123;ctrl+g显示当前光标所在行位置及文件状态信息编辑命令：剪切命令：x：删除光标处的字符#x：删除光标处起始的#个字符xp：交换光标所在处的字符及其后面字符的位置d(常用)：可结合光标跳转字符，实现范围删除d$,d^,d0,dw,de,db,#COMMAND...dd：删除光标所在行#dd：多行删除粘贴命令(p,put,paste)：p(小写)：缓冲区存储的如果为整行,则粘贴至当前光标所在行的下方;否则粘贴至当前光标所在处的后面P(大写)：缓冲区存储的如果为整行,则粘贴至当前光标所在行的上方;否则粘贴至当前光标所在处的前面复制命令(y,yank)：y：工作行为相似于d命令y$,y^,y0,yw,de,yb,#COMMAND...yy：复制光标所在行#yy：多行复制改变命令(c,change)：c：修改，同d命令,但同时会进入插入模式c$,c^,c0,cw,ce,cb,#COMMAND...cc：#cc：可视化模式：经常结合编辑命令中的d,y进行复制剪切v(小写)：按字符选定光标划过的区域V(大写)：按行选定光标划过的区域撤销命令：u(undo)：撤销此前的操作#u：撤销指定次数的操作撤销此前的撤销操作：Ctrl+r重复前一个编辑操作：常用于和dd配合使用.%可以在当前有括号的光标处查找配对的括号)&#125;],常用于程序调试时查找不配对的括号r输入一个字符可替换光标所在位置的字符末行命令：1.地址定界：:start_pos,end_pos#：具体第#行,例如2表示第2行#,#：从左侧#表示行起始,到右侧#表示行结尾#,+#：从左侧#表示行起始,加上右侧#表示的行数.：当前行$：最后一行%：全文,相当于1,$使用方法：后跟一个编辑命令d,y,...w /APTH/TO/SOMEWHERE：将范围内的行另存至指定文件中r /APTH/FROM/SOMEWHERE：在指定位置插入指定文件中的所有内容2.查找：同less命令的查找/PATTERN：从当前光标所在处向文件尾部查找?PATTERN：从当前光标所在处向文件首部查找n:与查找命令方向相同N:与查找命令方向相反3.查找并替换：需结合地址定界一起使用s/要查找的内容/替换为的内容/修饰符要查找的内容：可使用模式替换为的内容：不能使用模式,但可以使用\1,\2,...等后向引用符号;还可以使用&quot;&amp;&quot;引用前面查找时查找到的整个内容修饰符：i：忽略大小写g：全局替换,默认情况下,每一行只替换第一次出现的内容c：询问用户是否替换查找替换中的分隔符/可替换为其他字符,例如s@@@s###练习：1.复制/etc/grub2.cfg至/tmp/目录,用直接替换命令删除/tmp/grub2.cfg文件中的行首的空白字符%s/^[[:space:]]\+//g2.复制/etc/rc.d/init.d/functions文件至/tmp目录,用查找替换命令为/tmp/functions的每行开头为空白字符的行的行首添加一个#号%s/^[[:space:]]/#&amp;/4.多文件模式下的操作：一般窗口没有分割时:next   下一个:prev   前一个:first  第一个:last   最后一个:wall   保存所有:qall   退出所有:wqall  保存退出所有5.获取帮助:help:help keywords6.执行外部命令:! COMMAND  用于执行一个外部命令:r ! COMMAND  读取外部命令的输出放到光标处窗口分割模式：窗口间切换：Ctrl+w,Arrow单文件：Ctrl+w,s：split,水平分割Ctrl+w,v：vertical,垂直分割多文件：vim -o|O FILE1 FILE2 FILE3...-o：水平分割-O：垂直分割定制vim的工作特性：配置文件：永久有效全局：/etc/vimrc个人(需手动创建该文件)：~/.vimrc末行命令：当前vim进程有效1.行号显示：set number,简写为set nu取消显示：set nonumber,简写为set nonu2.括号匹配匹配：set showmatch,简写为set sm取消匹配：set noshowmatch,简写为set nosm3.自动缩进(autoindent)启用：set ai禁用：set noai4.高亮(HighLight)搜索启用：set hlsearch禁用：set nohlsearch5.语法(syntax)高亮启用:syntax on禁用：syntax off6.忽略字符大小写(ignorecase)启用:set ic禁用:set noic翻屏操作：ctrl+f：向文件尾部翻一屏ctrl+b：向文件首部翻一屏ctrl+d：向文件尾部翻半屏ctrl+u：向文件首部翻半屏vim自带的练习教程：vimtutor</code></pre></li></ul></li></ul><h3 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a><em><strong>文件查找</strong></em></h3><p><code>在文件系统上查找符合条件的文件；分为非实时查找(数据库查找)和实时查找</code></p><ul><li><code>locate</code><ul><li>命令功能  <pre><code class="hljs plaintext">依赖于事先构建好的索引;索引的构建是在系统较为空闲时自动进行(周期性任务);可手动更新数据库(updatedb),与makewhatis类似,索引构建过程中需要遍历整个根文件系统,极消耗资源-----------------------工作特点：查找速度快模糊查找：根据整个路径名和文件名非实时查找</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# locate KEYWORD</code></pre></li></ul></li><li><code>find</code><ul><li>命令功能  <pre><code class="hljs plaintext">实时查找工具,通过遍历指定路径下的文件系统完成文件查找-----------------------工作特点：查找速度略慢精确查找：根据文件本身的名字而非整个路径名实时查找</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# find [OPTION]... [查找路径] [查找条件] [处理动作]查找路径：指定具体目标路径,可以多个;默认为当前目录查找条件：指定的查找标准,可以是文件名/大小/类型/权限等标准进行;默认为找出指定路径下的所有文件根据文件名：-name &quot;文件名称&quot;：支持使用文件名通配（globbing）*,?,[],[^]-iname &quot;文件名称&quot;：不区分字母大小写-regex &quot;PATTEN&quot;：以PATTE匹配整个文件路径字符串，而不仅仅是文件名称根据属主/属组：-user USERNAME：查找属主为指定用户的文件-group GROUPNAME：查找属组为指定组的文件-uid UserID：查找属主为指定UID号的文件-gid GroupID：查找属组为指定GID号的文件-nouser：查找没有属主的文件,如用户删了-nogroup：查找没有属组的文件,如用户删了,私有组也没了根据文件类型：-type TYPE：可参考ls命令中的各类型代表字符根据文件大小：-size [+|-]#UNIT常用单位：K,M,G#UNIT：(#-1,#]-#UNIT：(0,#-1]+#UNIT：(#,无穷大)根据时间戳：以&quot;天&quot;为单位：-atime [+|-]##：[#,#+1)+#：[#+1,无穷大)-#：[0,#)-mtime [+|-]#-ctime [+|-]#以&quot;分钟&quot;为单位：-amin [+|-]#-mmin [+|-]#-cmin [+|-]#根据权限：-perm [/|-]MODEMODE：精确权限匹配/MODE：任何一类(u,g,o)对象的权限中只要能有一位匹配即可-MODE：每一类对象都必须同时拥有为其指定的权限标准组合条件：与：-a,可以省略或：-o非：-not,!            摩根定律：                !A -a !B 相当于 !(A -o B)                !A -o !B 相当于 !(A -a B)处理动作：对符合条件的文件做什么操作;默认输出至屏幕-print：默认的处理动作,显示至屏幕-ls：类似于对查找到的文件执行&quot;ls -l&quot;命令-delete：删除查找到的文件-fls /PATH/TO/SOMEFILE：查找到的所有文件的长格式信息保存至指定文件中-ok COMMAND &#123;&#125; \：对查找到的每个文件执行由COMMAND指定的命令对于每个文件执行命令之前,都会交互式要求用户确认-exec COMMAND &#123;&#125; \：对查找到的每个文件执行由COMMAND指定的命令,不会要求用户确认&#123;&#125;：用于引用查找到的文件名称自身注：find传递查找到的文件至后面指定的命令时,查找到所有符合条件的文件会一次性传递个后面的命令,有些命令不能接受过多参数,此时命令可能会失败,另一种方式可规避此问题：find | xargs COMMAND</code></pre></li><li>命令实例  <pre><code class="hljs plaintext">练习1：查找/var目录下属主为root,且属组为mail的所有文件或目录    ~]# find /var -user root -group mail练习2：查找/usr目录下不属于root、bin或hadoop的所有文件或目录    ~]# find /usr -not -user root -a -not -user bin -a -not -user hadoop    ~]# find /usr -not \( -user root -o -user bin -o -user hadoop \)练习3：查找/etc目录下最近一周内其内容被修改过,同时属主不为root,也不是hadoop的文件或目录    ~]# find /etc -mtime -7 -a -not -user root -a  -not -user hadoop    ~]# find /etc -mtime -7 -a -not \( -user root -o -user hadoop \)练习4：查找当前系统上没有属主或属组,且最近一个周内曾被访问过的文件或目录    ~]# find / -nouser -a -nogroup -a -atime -7练习5：查找/etc目录下大于1M且类型为普通文件的所有文件或目录    ~]# find /etc -size +1M -type f练习6：查找/etc目录下所有用户都没有写权限的文件    ~]# find /etc -not -perm /222 -ls练习7：查找/etc目录下至少有一类用户没有执行权限的文件    ~]# find /etc -not -perm -111 -ls练习8：查找/etc/init.d目录下,所有用户者都有执行权限,且其他用户有写权限的文件    ~]# find /etc/itit.d -perm -113 -ls</code></pre>  <img src="/2018/12/31/os-linux-command/os-linux-command-001.png" alt="抱歉,图片休息了"></li></ul></li></ul><h3 id="文本处理三剑客"><a href="#文本处理三剑客" class="headerlink" title="文本处理三剑客"></a><em><strong>文本处理三剑客</strong></em></h3><ul><li><code>grep</code><ul><li>命令功能  <pre><code class="hljs plaintext">Global search REgular expression and Print out the line,文本过滤(搜索)工具-----------------------作用：根据用户指定的&quot;模式&quot;对目标文本逐行进行匹配检查,并打印匹配到的行-----------------------egrep：默认支持扩展正则表达式来匹配fgrep：不支持正则表达式搜索(即不基于正则表达式引擎做模式匹配),而仅仅是找给定的字符串,因此执行性能快很多</code></pre></li><li>命令格式  <pre><code class="hljs plaintext">~]# grep [OPTIONS] PATTERN [FILE...]</code></pre></li><li>命令参数  <pre><code class="hljs plaintext">--color=auto：对匹配到的文本着色显示    有些系统默认没带此参数时可设置别名：alias grep=&#x27;grep --color=auto&#x27;-v：显示不能够被pattern匹配到的行-i：忽略字符大小写-o：仅显示匹配到的字符串-q：静默模式,不输出任何信息-A #：after,显示匹配到的后#行-B #：before,显示匹配到的前#行-C #：context,显示匹配到的前后各#行-E：支持使用扩展的正则表达式ERE,相当于egrep</code></pre></li><li>常用操作  <pre><code class="hljs plaintext">模式：由正则表达式字符及文本字符所编写的过滤条件基本正则表达式：BRE元字符：字符匹配：.：匹配任意单个字符[]：匹配指定范围内的任意单个字符[^]：匹配指定范围外的任意单个字符次数匹配：用在要指定次数的字符后面,用于指定前面的字符要出现的次数\?：0或1次*：0或多次(任意次)\+：1次或多次\&#123;m\&#125;：恰好m次\&#123;m,n\&#125;：最少m次,最多n次\&#123;0,n\&#125;：最多n次\&#123;m,\&#125;：最少m次位置锚定：^：行首锚定，用于模式的最左侧$：行尾锚定，用于模式的最右侧^PATTERN$：用于模式匹配整行^$：空行(不包括空白字符)^[[:space:]]*$：\&lt;或\b：词首锚定,用于单词模式的左侧\&gt;或\b：词尾锚定,用于单词模式的右侧\&lt;PATTERN\&gt;：匹配整个单词分组：\(\)：将一个或多个字符捆绑在一起,当作一个整体进行处理注：分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部(greb程序)的变量中,这些变量的命名方式为\1,\2,\3,...\1：从左侧起,第一个左括号以及与之匹配右括号之间的模式所匹配到的字符后向引用：引用前面的分组括号中的模式所匹配字符,而非模式本身~]# grep &#x27;\([[:alpha:]]\&#123;1,3\&#125;t\).*\1&#x27; /etc/passwd扩展正则表达式：ERE    元字符：    字符匹配,次数匹配,位置锚定,分组：    同BRE,其中?,+,&#123;&#125;,()不需要转义    或者：    a|b    C|cat：C或cat</code></pre></li><li>命令实例  <pre><code class="hljs plaintext">练习1：显示/proc/meminfo文件中以大小s开头的行(要求:使用2种方式)    ~]# grep -i &#x27;^s&#x27; /proc/meminfo      grep &#x27;^[Ss]&#x27; /proc/meminfo练习2：显示/etc/passwd文件中不以/bin/bash结尾的行    ~]# grep -v &#x27;/bin/bash$&#x27; /etc/passwd练习3：如果用户root存在,显示其默认的shell程序    ~]# id root &amp;&gt; /dev/null &amp;&amp; grep &#x27;^root\&gt;&#x27; /etc/passwd | cut -d: -f7练习4：找出/etc/passwd中的两位或三位数    ~]# grep &#x27;\&lt;[0-9]\&#123;2,3\&#125;\&gt;&#x27; /etc/passwd练习5：显示/etc/grub2.cfg(或conf)文件中,至少以一个空白字符开头的行且后面存在非空白字符的行    ~]# grep &#x27;^[[:space:]]\+[^[:space:]]&#x27; /etc/grub2.cfg练习6：找出&quot;netstat -tan&quot;命令的结果中以&quot;LISTEN&quot;后跟0,1或多个空白字符结尾的行    ~]# netstat -tan | grep &#x27;LISTEN[[:space:]]*$&#x27;练习7：添加用户bash,testbash,basher以及nologin(其shell为/sbin/nologin),而后找出/etc/passwd文件中用户名同shell名的行    ~]# grep &#x27;^\([[:alnum:]]\+\&gt;\).*\1$&#x27; /etc/passwd------------------------------------练习1：显示当前系统root,centos或user1用户的默认shell和UID    ~]# grep -E &#x27;^(root|centos|user1)\&gt;&#x27; /etc/passwd | cut -d: -f1,3,7练习2：找出/etc/rc.d/init.d/functions文件(centos6)中某单词后面跟一个小括号的行    ~]# grep -E -o &#x27;^[_[:alpha:]]+\(\)&#x27; /etc/rc.d/init.d/functions练习3-1：使用echo输出一绝对路径,使用egrep取出其基名    ~]# echo &quot;/mnt/sdc/&quot; | grep -E -o &#x27;[^/]+/?$&#x27; | cut -d&quot;/&quot; -f1练习3-2：使用echo输出一绝对路径,使用egrep取出路径的目录名,类似于dirname命令的结果    ~]# echo &quot;/mnt/sdc/&quot; | grep -E -o &#x27;.*/\&lt;&#x27;    ~]# echo &quot;/mnt/sdc&quot; | grep -E -o &#x27;.*/\&lt;&#x27;练习4：找出ifconfig命令结果中1-255之间的数值    ~]# ifconfig | grep -E -o &#x27;\&lt;([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;&#x27;练习5：找出ifconfig命令结果中的IP地址    ~]# ifconfig | grep -E -o &#x27;[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;&#x27;    ~]# ifconfig | grep -E -o &#x27;([0-9]+\.)&#123;3&#125;[0-9]+&#x27;</code></pre></li></ul></li><li><code>sed</code><ul><li>命令功能  <pre><code class="hljs plaintext">stream editor,文本编辑工具</code></pre></li></ul></li><li><code>awk</code><ul><li>命令功能  <pre><code class="hljs plaintext">gnu awk,文本报告生成器</code></pre></li></ul></li></ul><h3 id="压缩、解压缩及归档工具"><a href="#压缩、解压缩及归档工具" class="headerlink" title="压缩、解压缩及归档工具"></a><em><strong>压缩、解压缩及归档工具</strong></em></h3><pre><code class="hljs plaintext">压缩：根据一定算法归档：能实现将多个文件打包成单个文件，即为归档文件------------------------压缩、解压缩工具：    compress/uncompress, .Z        早期时候使用的工具,很多程序包的源码以.Z的格式出现,现在很少见到.    gzip/gunzip, .gz        早期时候非常常用的工具,现在的发行版上依然会使用,采用&#x27;LZ77&#x27;的压缩算法,压缩比不是特别高,但在早期时候非常快速高效        只能压缩文件,不能压缩目录,并且为了节约空间默认会删除原文件,只保留压缩后的文件    bzip2/bunzip2, .bz2        采用比gzip更为高效的压缩算法(基于LZ77/LZ78),来实现更高压缩比        只能压缩文件,不能压缩目录,并且为了节约空间默认会删除原文件,只保留压缩后的文件    xz/unxz, xz        目前比较推崇使用的工具,xz的压缩比比bzip2更大,CentOS5不支持,需要额外安装        只能压缩文件,不能压缩目录,并且为了节约空间默认会删除原文件,只保留压缩后的文件归档工具：    zip/unzip, zip        非常通用的比较古老的工具,各种操作系统基本都支持,不但是一个归档工具还是一个压缩/解压缩工具        能对目录进行,将目录下的所有文件(需指明/dir/*)打包成单个文件,再进行压缩    tar</code></pre><ul><li><code>gzip/gunzip</code>  <pre><code class="hljs plaintext">gzip [OPTION]... FILE ...    -d: 解压缩，相当于gunzip    -c: 将压缩后的结果输出至标准输出,这样会保留原文件        gzip -c /path/to/somefile &gt; /path/to/somecfile.gz    -#：指定压缩比，默认为6，范围为1-9,压缩比越大,压缩后生成的文件越小,所消耗的时间越长        zcat somefile.gz: 不解压查看gzip压缩后的文件的内容</code></pre></li><li><code>bzip2/bunzip2</code>  <pre><code class="hljs plaintext">bzip2 [OPTION]... FILE ...    -k: keep, 保留原文件    -d：解压缩，相当于bunzip2    -#：指定压缩比，默认为6，范围为1-9,压缩比越大,压缩后生成的文件越小,所消耗的时间越长        bzcat somefile.gz: 不解压查看bzip2压缩后的文件的内容</code></pre></li><li><code>xz/unxz</code>  <pre><code class="hljs plaintext">xz [OPTION]... FILE ...    -k: keep, 保留原文件    -d：解压缩，相当于unxz    -#：指定压缩比，默认为6，范围为1-9,压缩比越大,压缩后生成的文件越小,所消耗的时间越长        xzcat somefile.gz: 不解压查看xz压缩后的文件的内容</code></pre></li><li><code>zip/unzip</code>  <pre><code class="hljs plaintext">zip ZIPFILE.zip src_file...    zip pam.d.zip pam.d/*unzip ZIPFILE.zip    -d：解压到指定位置</code></pre></li><li><code>tar</code>  <pre><code class="hljs plaintext">tar [OPTION]...     (1) 创建归档        tar -c -f /PATH/TO/SOMEFILE.tar FILE...        tar -cf /PATH/TO/SOMEFILE.tar FILE...    (2) 查看归档文件中的文件列表        tar -t -f /PATH/TO/SOMEFILE.tar    (3) 展开归档        tar -x -f /PATH/TO/SOMEFILE.tar        tar -x -f /PATH/TO/SOMEFILE.tar -C /PATH/TO/DIR            tar可直接通过选项调用压缩工具针对归档文件执行压缩或解压：解压并展开归档时可以不用带以下参数就能自动判断压缩格式        -z: gzip        -j: bzip2        -J: xz    -C DIR：解压到指定目录,目录必须事先存在    -v：创建/展开归档文件的时候显示文件</code></pre></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统入门：基础</title>
      <link href="/2018/12/23/os-linux-basic.html"/>
      <url>/2018/12/23/os-linux-basic.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-系统入门：基础"><a href="#Linux-系统入门：基础" class="headerlink" title="Linux 系统入门：基础"></a>Linux 系统入门：基础</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E6%AD%A3%E7%AF%87">正篇</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>记录一些基础知识…</p><h2 id="正篇"><a href="#正篇" class="headerlink" title="正篇"></a>正篇</h2><h3 id="前言1"><a href="#前言1" class="headerlink" title="前言1"></a>前言1</h3><pre><code class="hljs plaintext">-RedHat：    认证考试：        RHCSA：红帽认证助理工程师（管理员）        RHCE：红帽认证工程师        RHCA：红帽认证架构师-IT技术领域：研发：硬件：接口机器语言：二进制指令，二进制数据软件：低级语言：汇编语言,汇编器,移植性差系统中某些与硬件相关的特有代码,驱动程序开发高级语言：C,C++,编译器,移植性好系统级：C,C++,操作系统，对性能要求较高的服务类程序(如mysql等),驱动程序应用级：Java,Python,Ruby,php,应用程序：ansible,puppet,......程序越高级,程序员写程序越容易,写出来的程序性能就越差,运行在解释器或虚拟机上的程序必然有性能损耗,这是不可避免的应用：Linux运维：Linux生态圈中的各应用程序的应用Shell脚本编程：让某些应用工作能自动完成Python：专业编程语言ansible,openstackDevOps（Development Operations）:-推荐的书籍出版社：    O&#x27;ReileyWrox机械工业、电子工业、人邮、清华大学、水利水电-推荐的书籍：    《穿越计算机的迷雾》《量子物理史话》《三体》《奇点临近》-5w1h:博客作业what\why\when\where\whohow</code></pre><h3 id="前言2"><a href="#前言2" class="headerlink" title="前言2"></a>前言2</h3><pre><code class="hljs plaintext">-现代计算机设备的组成部分：5大基本部件，遵循冯诺依曼体系(ENIAC埃尼阿克是世界上第一台现代电子计算机)CPU：运算器、控制器、(寄存器、缓存)内存：存储器，RAM（Ramdom Access Memory）Input：下指令，提供数据等Output：输出数据加工的结果-32位CPU只能使用４G内存：2^10 = 10242^32 = 1024*1024*1024*4 Bytes = 1024*1024*4 KB = 1024*4 MB = 4 GB-OS:Operating System(在linux上称为内核kernel)软件程序通用目的:将底层各种不同的硬件抽象为统一接口,要实现底层很多功能,如硬件驱动(让各种硬件工作起来)进程管理(把cpu提供的计算能力分配给多个程序来运行,即cpu的时间片切割和分配)内存管理(将有限的内存资源分配给多个同时运行的程序)网络管理(能够跟其他主机进行网络通信)安全管理...编程层次:现在绝大多数程序都是基于库调用和一部分系统调用研发的硬件规格:hardware specifiacation系统调用:system call库调用(c或c++):library call解释器或虚拟机:java,python,php等    android系统是跑在java虚拟机上的java程序,有gc,非常耗资源,ios系统是用底层语言object-c写的,内存分配完全由程序员手动完成运行程序格式:window:exe,dll(dynamic link library)Linux:elf,so(shared object)-程序：指令+数据（冯诺依曼体系中定义）||算法+数据结构（shell脚本编程中用到）CPU指令:指令集特权指令:拥有管理功能普通指令:完成基本操作程序员在OS上写的应用程序只能操作普通指令,只有操作系统可以运行特权指令,当然也可以运行普通指令程序的编程风格：过程式：以指令为中心,数据服务于指令顺序执行循环执行选择执行对象式：以数据为中心,指令服务于数据程序的执行方式：计算机：运行二进制指令编程语言：低级：汇编高级：编译：高级语言--&gt;编译器--&gt;目标代码C,C++,java解释：高级语言--&gt;解释器--&gt;机器代码SHELL,PERL,PYTHON-CPU架构类型：提供的指令集不一样intel和amd    x86    x64(amd64)m68000,简称m68k(摩托罗拉公司的,早期因特尔的处理器较丑陋)arm(android底层是linux,ios底层是unix,相应的如高通等都是基于arm)ultrasparc solaris(sun公司的)power aix(IBM公司的)powerpc,ppc(苹果,摩托罗拉,IBM公司3者联合研发的简装版的power,性能非常强大,但被后来的intel i5,i7赶上了)MIPSalpha hp-ux(惠普公司的).......</code></pre><h3 id="UNIX发展简史"><a href="#UNIX发展简史" class="headerlink" title="UNIX发展简史"></a>UNIX发展简史</h3><ul><li>完整的OS：kernel(内核) + Application</li><li>狭义上的OS：kernel</li><li><code>Linux = GNU/Linux = linux内核 + GNU组织提供的各种开源软件 = 通常以源码(文本格式)方式提供，自由、灵活</code></li></ul><pre><code class="hljs plaintext">-1946年，世界上第一台电脑ENIAC在美国宾夕法尼亚大学诞生，目的是用来计算炮弹弹道，重达30吨。-1947年，BELL实验室发明晶体管。-1958年，TI发明集成电路。-1965年，Bell(AT&amp;T),MIT(麻省理工),GE（通用电器）3大实验室联合研发Multics项目(PDP-7计算机计划) = 试图建立一个具备众多功能的一个信息功能应用工具。    Ken Thompson（Bell实验室人员）：Space Travel（一款游戏）DEC（一个公司）：PDP-11（小型机）,VAX（VMS）PDP-7：Ken在该设备上用汇编语言写了一个程序Unics（与Multics相比功能更单一,这个是戏称的非正式的名称，因为思想源自Multics），用来跑Space Travel-1969年，-1970年，可称为&quot;UNIX元年&quot;。-1971年，Ken等人承包了nroff（文字处理程序）项目,运行在Unics上;Intel发布第一微处理器4004。-1972年，unix装机量在Bell实验室达到10台，跑在它上面的应用程序是用B语言写的。B（解释型编程语言）：Dennis Ritch（Bell实验室另一个人员）升级成C语言（B+）-1973/1974年，Ken和Dennis联合用c重写Unics,正式取名UNIX,unix诞生。-1974年后，2人联合在《美国计算机通信》杂志上发布论文将unix公之于众。-1976年，ken趁年休去美国加州大学Berkeley分校去支教,让该分校在unix研究上走在了前列。Bill Joy(该分校研究生)成立了BSRG组织-1977年，BSRG组织发行了BSD（Berkeley System Distribution）系统,UNIX分支--BSD诞生。Bill Joy取得了UNIX的源代码，加以修改和完善，得到合适自己机器的版本并增加了很多工具软件和编译程序，命名为BSD。Bill Joy也是Sun的创办者。Sun是以BSD开发的内核进行自己的商业UNIX版本开发的。（可用于x86硬件架构的FreeBSD即由BSD改版而来）-1978年，全球第一家以包装发行商业发行版unix的公司诞生了（SCO公司）。-1979年，AT&amp;T(bell实验室东家)宣布收回UNIX版权，特别声明“不可对学生提供源码”。同时发布第七版System V的UNIX,支持x86架构。期间众多公司的UNIX系统纷纷出现。    同年Intel推出8086/8088 CPU。-1980年，西雅图一家不起眼的公司诞生了（Microsoft）,出售XENIX(unix的变种)。BSD成为Berkeley分校整个校园网的核心系统DARPA(美国国防部高级研究计划局)要实现TCP/IP协议，将这项研究交给了BSD，给了BSRG组织-1981年，IBM发布IBM PC，x86架构的PC机开始流行。Microsoft公司的CEO（Bill Gates）另一位合伙人的朋友在SCP公司该公司的一位程序员花了6周时间研发了一个系统QDOS，当时unix系统主要跑在摩托罗拉的cpu上，intel cpu芯片上跑不动，QDOS可以运行Intel的cpu，Bill Gates看到商机，买断了该系统的版权，并在此基础上修改，该系统打上了microsoft的版权，并与IBM公司签订了合同,IBM每卖出一台PC兼容机就装上该系统，只需支付20美元左右，PC机卖火了，Microsoft也赚火了。至此，DOS 2.0盖过了CP/M（一位教授改写的QDOS）-1983年，TCP/IP协议诞生在BSD系列的unix系统上。-1984年，谭邦宁（Andrew Tanenbaum）教授编写出基于X86架构的与UNIX兼容的MINIX系统。-1985年，MIT的RIchard Stallman为了“创建一个自由、开放的UNIX操作系统”,启动了GNU(GNU is Not Unix)项目。由于工程浩大，Stallman决定先编写应用程序如EMACS、GNU C（GCC）、GNU C LIBRARY （GLIBC）、Bash Shell。    并于1985年草拟了GPL（general public license）。但当时开发的软件只能运行在授权的UNIX平台上，一直到Linux出现。-1988年，XFree86诞生，即x86版UNIX上的GUI系统。-1990年，Microsoft公司的写程序用的开发环境还是unix，连开发dos系统也是用的unix。SUN公司的Bill Joy出售workstation PC机-1991年8月，Linus Torvalds (李纳斯.托瓦兹)宣布成立Linux。Linus Torvalds宣布他以bash/gcc等工具写出了可运行在Intel386上的内核程序。因为Linux用了很多的GNU相关软件，Stallman认为Linux的全名应该是GNU/Linux。-2008年，Google发布基于Linux的手机操作系统Android。</code></pre><h3 id="stallman运动：GNU"><a href="#stallman运动：GNU" class="headerlink" title="stallman运动：GNU"></a>stallman运动：GNU</h3><pre><code class="hljs plaintext">闭源：开源：提供源代码    开源协定：        GPL：General Public License            LGPL：Lesser GPL            GPLv2,GPLv3            FSF：Free        BSD：            1.如果二次发布的产品中包含源代码，则在源代码中必须带有原来的代码中的BSD协定            2.如果二次发布的产品是二进制格式的库或程序，则需要在发布的文档或版权声明中说明包含原来的代码中的BSD协定            3.不可以用开源代码的作者或组织以及原来的产品的名字做市场推广        Apache：            ASF：Apache Software Foundation    双线授权：        Community:遵循开源协定        Enterprise:开源程序的作者收入方式：服务、捐赠    linux内核背后的捐赠者：IBM、Google、FaceBook、RedHat</code></pre><h3 id="linux发行版"><a href="#linux发行版" class="headerlink" title="linux发行版"></a>linux发行版</h3><ul><li>提供的各种程序如gcc、glibc、vi、linux内核等等都是源码，必须编译成为二进制格式才能运行，而要编译必须有编译器，而编译器又必须运行在OS上，而编译过程又非常复杂，非常人所能为之。</li><li>因此一些商业公司或社区组织按照他们自己理解负责将源代码程序编译成二进制格式并打包提供给用户使用，这就是linux的发行版，这些组织就成了linux的发行商。</li><li>linux发行版有数百种之多。可在 <a href="http://futurist.se/gldt/">Linux Distirbution Timeline</a> 上查看</li></ul><pre><code class="hljs plaintext">三大主流发行版及重要分支：    Debian：唯一一个以社区方式运作的，没有商业公司支持。下面分支都是基于Debian的二次发行版Ubuntu：以桌面应用而发行，现在server方面也做的不错MintKnopix：以安全著称的，短小精悍Slackware：S.u.S.E：由商业公司支持，界面华丽，欧美流行OpenSUSERedHat：由商业公司支持，1994年成立时主要就以个人桌面版发行，发行版稳定后，开始发行企业版，直到RedHat 7.0前后，出现下面2个分支RedHat Enterprise Linux（RHEL）：企业版，18个月或更久,所以现在才到RHEL 7左右CentOS（Community Enterprise OS）：RHEL的山寨版，完全兼容RHEL，2015年3月被RedHat收购Fedora Core：个人桌面版 ，6个月,到9.0以后,个人版不在维护,2003年左右捐给了fedora组织,主要测试新程序,发行周期很快    Gentoo    ArchLinux    LFS    Android:kernel+busybox+java虚拟机</code></pre><pre><code class="hljs plaintext">-软件程序：有版本号标示着major(主版本号).minor(次版本号).release(发行号修正号)Linux:0.99,2.2,2.4,2.6,3.0,4.0,4.18.8www.kernel.orgGNU:vigcc...-发行版本也有自己的版本号：RHEL：5.x,6.x,7.xFedora：23Debian：8.xOpenSUSE：13.x-如何获取CentOS的发行版：CentOS的镜像站点http://mirrors.aliyun.comhttp://mirrors.sohu.comhttp://mirrors.163.com</code></pre><h3 id="linux的哲学思想"><a href="#linux的哲学思想" class="headerlink" title="linux的哲学思想"></a>linux的哲学思想</h3><ul><li>一切皆文件。把几乎所有资源统统抽象为文件形式，包括硬件设备，甚至通信接口等。<ul><li>表现之一：硬件设备也通过文件表示</li></ul><p></p></li><li>由众多功能单一的程序组成。<ul><li>目的：一个程序只做一件事，并且做好，组合小程序完成复杂任务（管道中体现）</li></ul></li><li>尽量避免跟用户交互。<ul><li>目标：易于以编程的方式实现自动化任务,实现脚本编程</li></ul></li><li>使用纯文本文件保存配置信息。<ul><li>目标：一款使用的文本编辑器即能完成系统配置工作</li></ul></li></ul><h3 id="终端-terminal-设备"><a href="#终端-terminal-设备" class="headerlink" title="终端(terminal)设备"></a>终端(terminal)设备</h3><ul><li><code>多任务(Multi-tasks)、多用户(Multi-users)</code></li></ul><hr><ul><li><code>物理终端</code>：&#x2F;dev&#x2F;console<ul><li>直接接入本机的显示器和键盘设备,也叫控制台(console),只在Linux系统启动过程当中被使用</li></ul></li><li><code>虚拟终端</code>：&#x2F;dev&#x2F;tty# [1,6]<ul><li>附加在物理终端之上的以软件方式虚拟实现的终端(linux为了兼容unix某些早期的特性并保持一致)</li><li>CentOS6默认启动6个虚拟终端(tty)  <pre><code class="hljs plaintext">Ctrl + Alt + F[1-6]启动GUI：在某一虚拟终端接口运行命令 startx图形终端：附加在物理终端之上的以软件方式虚拟实现的终端,但额外会提供桌面环境,从本质上也是虚拟终端的一种    CentOS 6: Ctrl + Alt + F7    CentOS 7: 在哪个虚拟终端启动，即位于哪个虚拟终端</code></pre></li></ul></li><li><code>模拟终端</code>: &#x2F;dev&#x2F;pts&#x2F;# [0,无穷大]<ul><li>图形界面下打开命令行接口||基于ssh协议或telnet协议等远程打开的界面</li></ul></li><li><code>串行终端</code>：&#x2F;dev&#x2F;ttyS#</li></ul><hr><ul><li>在启动终端设备之后，默认会在其上关联一个交互式应用程序，即可实现与用户交互。<ul><li>查看当前的终端设备：<code>~]# tty</code></li><li>查看当前使用的shell接口程序：<code>~]# echo $SHELL</code></li><li>查看当前系统使用的所有shell：<code>~]# cat /etc/shells</code></li></ul></li></ul><hr><ul><li>OS的交互式接口(应用程序)有2类<ul><li>GUI：Graphical User Interface 图形用户接口  <pre><code class="hljs plaintext">GNome：用c研发的,研发环境为gtkKDE：用c++研发的，研发环境为qtXFCE:轻量级桌面</code></pre></li><li>CLI：Command Line Interface  命令行接口  <pre><code class="hljs plaintext">shell程序:bash(Bourne-Again SHell)、zsh、sh(Bourne shell)、csh、tcsh、ksh[root@nodel ~]#  COMMAND    root：当前登录的用户    nodel：当前主机的主机名，非完整格式，此处的完整格式为：nodel.magedu.com    ~：用户当前所在的目录（current directory）,也称为工作目录（working directory）    #：命令提示符        #：管理员帐号，为root，拥有最高权限，能执行所有操作，如删除某个设备等。        $：普通帐号，非root用户，不具有管理权限，不能执行系统管理类操作。    注意：建议使用非管理员帐号登录，执行管理操作时可临时切换至管理员，操作完成即退回。</code></pre></li></ul></li><li>远程连接  <pre><code class="hljs plaintext">ssh协议：secure shell    Xshell就是ssh协议的一个客户端程序~]# ss -tnl    查看系统是否监听于tcp协议的22号端口~]# ip addr list 或 ~]# ifconfig    查看活动接口的IP地址~]# ping    探测网络的目标主机与当前主机之间的连通性---确保防火墙处于关闭状态：    ~]# iptables -L -n    CentOS 7:        ~]# systemctl disable firewalld.service        ~]# systemctl stop firewalld.service    CentOS 6:        ~]# service iptables stop        ~]# chkconfig iptables off---连接：ssh root@172.16.249.74 -p端口号</code></pre></li></ul><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ul><li><code>是由/（原始起点）（根目录）开始的一个倒置树状结构</code>  <pre><code class="hljs plaintext">目录：路径映射文件：存储空间存储的一段流式数据，对数据可以做到按名存取文件的路径表示：绝对路径：从根开始表示出的路径相对路径：从当前位置开始表示出的路径当前位置的表示方式:(1)./:./sysconfig/network-scripts(2)省略上述符号:sysconfig/network-scripts.：当前目录..：当前目录的上一级目录</code></pre></li><li>文件名使用法则  <pre><code class="hljs plaintext">1.严格区分字符大小写：file1,File1,FILE12.目录也是文件，在同一路径下，两个文件不能同名3.支持使用除/以外的任意字符,不建议使用特殊字符/:根目录,路径分隔符4.最长不能超过255个字符5.以.开头的文件为隐藏文件</code></pre></li><li>根文件系统(rootfs)：root filesystem  <pre><code class="hljs plaintext">Linux组成部分由内而外：硬件内核（只有它能直接操作硬件），内核把整个硬件封装了起来，把所有硬件提供的功能转换成了系统调用系统调用库函数，由程序员开发的一堆程序片断，不能独立运行，只有被调用时运行。由glibc提供应用程序，需编译成对应FS系统的二进制可执行格式进程的类型：与终端相关：通过终端启动与终端无关：操作系统引导启动过程当中自动启动</code></pre>  <pre><code class="hljs plaintext">根文件系统层级结构标准FHS：Filesystem Hierarchy Standard,可参考fhs-2.3.pdf/boot：引导文件存放目录;一般来讲是个独立的分区,在/上创建boot目录然后挂载或关联到该分区上;如内核文件(vmlinuz),引导加载器(bootloader,grub)等/bin：存放供所有用户使用的基本命令程序文件,不能关联至独立分区,OS启动即会用到的程序/sbin：存放供系统管理员使用的基本命令程序文件,不能关联至独立分区,OS启动即会用到的程序/lib：存放系统启动或根文件系统上的应用程序（/bin,/sbin等）依赖的基本共享库文件，以及为内核提供的内核模块文件libc.so.*：动态链接的C库ld*：运行时链接器/加载器modules：用于存储内核模块的目录（对于CentOS 64位系统的内核模块也在此）/lib64：专用于x86_64系统上的辅助共享库文件存放位置,是64位系统下存放库文件最多的一个目录/etc：存放配置文件的目录(纯文本文件)，只能为静态，有自己独立的层级结构/home：普通用户的家目录的集中位置一般每个普通用户的家目录默认为此目录下与用户名同名的子目录，/home/USERNAME/root：管理员的家目录，可选/media：便携式移动设备挂载点，如cdrom（软盘）、floppy（光盘）、cdrecorder（刻录机）、zip等/mnt：临时文件系统的挂载点，如一块新的硬盘等/dev：存储特殊文件或设备文件设备有2种类型:字符设备（线性设备）（如键盘、显示器等），块设备（随机设备）（如硬盘等）/opt：第三方应用程序的安装位置，可选路径，早些时候第三方程序安装在此目录/srv：系统上运行的服务所用到的中间数据/tmp：为那些会产生临时文件的程序提供用于存储临时文件的目录，可供所有用户执行写入操作，有特殊权限/usr：universal shared read-only data,全局共享的只读数据路径,除/以外最重要的,可关联至一个独立的分区上bin,sbin：保证系统拥有完整功能而提供的应用程序lib,lib64：include：C程序头文件(header files)share：命令手册页和自带文档等结构化独立的文件的存储位置,例如doc,man等local：第三方应用程序的安装位置,取代了/opt,可关联至一个独立的分区上bin,sbin,lib,lib64,etc,shareX11R6：X-Window程序的安装位置src：程序源码文件的存储位置/var：variable data files,存储经常发生变化的数据的目录,可关联至一个独立的分区上cache：Application cache data(应用程序缓存数据目录)lib：Variable state information(应用程序状态信息数据)local：Variable data for /usr/local(专用于/usr/local下的应用程序存储可变数据)lock：Lock files(锁文件)log：Log file and directories(日志目录及文件)opt：Variable data for /opt(专用于/opt下的应用程序存储可变数据)run：Data relevant to running processes(运行中的进程相关的数据,通常用于存储进程的pid文件)spool：Application spool data(应用程序数据池)tmp：Temporary files preserved between system reboots(保存系统两次重启之间产生的临时数据)/proc：用于输出内核与进程信息相关的虚拟文件系统，它们多为内核参数，例如net.ipv4.ip_forward,虚拟为net/ipv4/ip_forward，存储于/proc/sys,因此其完整路径为/proc/sys/net/ipv4/ip_forward/sys：用于输出当前系统上硬件设备相关信息的虚拟文件系统,sysfs虚拟文件系统提供了一种比proc更为理想的访问内核数据的途径参考：https://www.ibm.com/developerworks/cn/linux/l-cn-sysfs/----------------------/misc：存放备用的杂项文件/lost+found：linux上ext系列文件系统任何一个分区格式化以后默认产生的目录,跟当前系统无关/selinux：security enhanced linux,selinux相关的安全策略等信息的存储位置</code></pre></li></ul><h3 id="命令的语法通用格式"><a href="#命令的语法通用格式" class="headerlink" title="命令的语法通用格式"></a>命令的语法通用格式</h3><ul><li><code>~]# COMMAND [OPTIONS...] [ARGUMENTS...]</code>  <pre><code class="hljs plaintext">输入命令并回车:用户发起一个执行命令的请求会提请shell程序先在内部命令中查找，然后根据path环境变量提供的路径中查找有没有相同的可执行程序或代码，找到了就请求内核将某个二进制程序运行为一个或多个进程,命令运行当中的特性由OPTIONS进行修正，并且作用在所给的参数之上。程序 --&gt; 进程静态 --&gt; 动态（有生命周期）</code></pre></li><li><code>COMMAND</code>  <pre><code class="hljs plaintext">命令本身是一个二进制格式的可执行的程序文件，有可能会调用共享库文件多数系统程序文件都存放在：/bin,/sbin,/usr/bin,/usr/sbin,/usr/local/bin,/usr/local/sbin普通命令：/bin,/usr/bin,/usr/local/bin管理命令：/sbin,/usr/sbin,/usr/local/sbin共享库：/lib,/lib64,/usr/lib,/usr/lib64,/usr/local/lib,/usr/local/lib6432bits的库：/lib,/usr/lib,/usr/local/lib64bits的库：/lib64,/usr/lib64,/usr/local/lib64注意：并非所有的命令都有一个在某目录与之对应的可执行程序文件在shell中可执行的命令分为2类：Shell内嵌命令（builtin）：由shell程序（如bash）的自带的命令外部命令：在当前系统的某文件系统路径下有对应的独立的可执行程序文件,可用which,whereis查看路径查看命令类型：type COMMAND命令必须遵循特定格式规范：exe,msi,ELF(Linux)~]# file /bin/ls   查看文件内容格式的类型SHELL程序是独特的程序，负责解析用户提供的命令环境变量：PATH：shell程序从哪些路径中查找用户键入的命令字符串所对应的命令文件。查找次序自左而右。~]# echo $PATH/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</code></pre></li><li><code>OPTIONS</code>  <pre><code class="hljs plaintext">用于启用或关闭命令的某个或某些功能(运行特性)选项有2种表现形式：短选项：-C，例如-l, -d注意：有些命令的选项没有-如果同一命令同时使用多个短选项，多数可合并： -l -d = -ld长选项：--word，例如--help, --human-readable注意：长选项不能合并注意：有些选项可以带参数，此称为选项参数，而不是命令参数。长选项参数一般用=来等于，短选项参数一般用空格来分隔</code></pre></li><li><code>ARGUMENTS</code>  <pre><code class="hljs plaintext">命令的作用对象，指定命令对什么生效注意：不同的命令的参数，有些命令可同时带多个参数，多个之间以空白字符分隔</code></pre></li></ul><h3 id="获取命令的使用帮助"><a href="#获取命令的使用帮助" class="headerlink" title="获取命令的使用帮助"></a>获取命令的使用帮助</h3><ul><li>内部命令  <pre><code class="hljs bash">~]<span class="hljs-comment"># help COMMAND</span></code></pre></li><li>外部命令  <pre><code class="hljs plaintext">通常一个命令运行时,只有第一次才会去目录中找,一旦找到后,会被记录下来放到缓存(内存中的一段空间)中,即shell搜寻到的外部命令的路径结果会缓存至kv(key-value)存储中命令每运行一次,hits都会加一,表示在缓存中找到了一次(也叫缓存命中);缓存也有副作用,如缓存的命令文件路径发生了改变,缓存中的内容是错误的,需要清空缓存:hash -ra.命令自带简要格式的使用帮助~]# COMMAND --helpb.使用手册manual，位置在/usr/share/man~]# man COMMANDSECTION:NAME:功能性说明SYNOPSIS:语法格式[]:可选内容&lt;&gt;:必须提供的内容a|b|c:多选一...:同类内容可出现多个DESCRIPTION:描述OPTIONS:选项EXAMPLES:使用示例AUTHOR:作者BUGS:报告程序bug的方式REPORTING BUGS:报告bug的位置COPYRIGTH:版权SEE ALSO:参考使用手册是压缩格式的文件(为了避免大量的命令造成大量的文档,才会压缩存放)，有章节之分：/usr/share/man   man1,man2,...1：用户命令(User Commands)如man ls执行后会在/usr/share/man/man1章节下找到ls.1.gz压缩文件然后自动解压缩打开并展示2：系统调用3：C库调用4：设备文件及特殊文件5：文件格式（配置文件格式）6：游戏使用帮助7：杂项8：管理类的命令~]# man CHAPTER COMMAND    查看该命令指定章节下的手册注意：有些COMMAND不止在一个章节中存在帮助手册;并非每个COMMAND在所有章节下都有手册查看COMMAND在哪些章节下有手册：~]# whatis COMMAND注意：其执行过程是查询数据库进行的,有时需要手动更新数据库(makewhatis)man命令的配置文件:/etc/man.configMANPATH /PATH/TO/SOMEWHERE:指定新的手册文件搜索位置~]# man -M /PATH/TO/SOMEWHERE COMMOND   到指定位置下搜索COMMAND命令的手册页并显示之man命令打开手册以后的操作方法：翻屏：空格键：向文件尾翻一屏b：向文件首部翻一屏回车键：向文件尾部翻一行k：向文件首部翻一行G：跳转至最后一行1G：跳转至文件首部文本搜索：/keyword:从文件首部向文件尾部依次查找,不区分字符大小写?keyword:从文件尾部向文件首部依次查找,不区分字符大小写n:与查找命令方向相同N:与查找命令方向相反退出：q:quitc.info COMMAND获取命令的在线文档d.很多应用程序会自带帮助文档：/usr/share/doc/COMMAND-VERSIONRENAME:程序的相关的信息INSTALL:安装帮助CHANGELOG:版本迭代时的改动信息e.程序官方的文档官方站点上的“Documentation”f.主流发行版官方文档http://www.redhat.com/docsg.搜索引擎googlekeyword filetype:pdfkeyword site:domain.tld...h.slidesharehttps://www.slideshare.net/</code></pre></li></ul><h3 id="bash的基础特性"><a href="#bash的基础特性" class="headerlink" title="bash的基础特性"></a>bash的基础特性</h3><p><code>能帮我们更好的完成系统管理</code></p><ul><li><em><strong>命令历史</strong></em>  <pre><code class="hljs plaintext">shell程序会在其会话中保存此前用户提交执行过的命令到缓存中,并在登出时保存到命令历史文件中------------~]# history ，第一次会加载命令历史文件中的命令历史记录到内存中，再加载当前shell中执行过的命令历史记录定制history的功能，可通过环境变量实现HISTSIZE：shell进程可保留的命令历史的条数    eg1：export HISTSIZE=10000HISTFILE：持久保存命令历史的文件（~/.bash_history），是在用户shell登出时自动进行保存的    eg1：export HISTFILE=/var/log/histlog/$&#123;LOGNAME&#125;/hist_$&#123;ip&#125;HISTFILESIZE：命令历史文件的大小    eg1：export HISTFILESIZE=10000HISTTIMEFORMAT：显示历史命令的时间戳(当HISTTIMEFORMAT这个环境变量被设置之后，之后的那些新执行的bash命令才会被打上正确的时间戳。在此之前的所有命令，都将会显示成设置HISTTIMEFORMAT变量的时间)    eg1：export HISTTIMEFORMAT=&#x27;%F %T&#x27;    eg2：export HISTTIMEFORMAT=&quot;[%Y.%m.%d %H:%M:%S `whoami`] :&quot;用法：history [-c] [-d 偏移量] [n] 或 history -anrw [文件名] 或 history -ps 参数 [参数...]-a：追加本次会话新执行的命令历史列表至历史文件中-c：清空内存中的命令历史记录-d offset：删除内存中的指定位置命令~]# history -d 676 5 删除内存中从第676条开始之后的5条-r：将历史文件的记录读取到内存并追加到历史列表中-w：将内存中的历史列表写入并追加到历史文件中history #：显示最近的#条命令调用命令历史列表中的命令：!#：再一次执行历史列表中的第#条命令!!：再一次执行上一条命令!STRING：再一次执行命令历史列表中最近一个以STRING开头的命令调用上一条命令的最后一个参数：快捷键：按下ESC松开再按.字符串：!$控制命令历史的记录方式：环境变量：HISTCONTROLignoredups：忽略重复（连续且相同）的命令ignorespace：忽略以空白字符开头的命令,可以不记录命令到内存和命令历史文件中去ignoreboth：以上两者同时生效修改环境变量的方式：exprot 变量名=&quot;值&quot;如：export HISTCONTROL=&#x27;ignorespace&#x27;</code></pre></li><li><em><strong>命令补全</strong></em>  <pre><code class="hljs plaintext">给定的打头字符串如果能根据path环境变量来惟一标识某命令程序文件，按下tab键，则直接补全，如果不能惟一标识某命令程序文件，再击tab键一次，会给出列表</code></pre></li><li><em><strong>路径补全</strong></em>  <pre><code class="hljs plaintext">以用户给出的字符串当做路径开头,并在其指定上级目录下搜索以指定的字符串开头的文件名，如果能惟一标识，按下tab键，则直接补全，否则再击tab键一次，会给出列表</code></pre></li><li><em><strong>命令行展开</strong></em>  <pre><code class="hljs plaintext">~：自动展开为用户的家目录，或指定的用户的家目录&#123;&#125;：可承载一个以逗号分隔的路径列表，并能够将其展开为多个路径练习1：如何创建/tmp/x/y1,/tmp/x/y2,/tmp/x/y1/a,/tmp/x/y1/b ?~]# mkdir -pv /tmp/x/&#123;y1/&#123;a,b&#125;,y2&#125;练习2：如何创建/tmp/x/y1,/tmp/x/y2,/tmp/x/y1/a,/tmp/x/y1/b,/tmp/x/y2/a,/tmp/x/y2/b ?~]# mkdir -pv /tmp/x/&#123;y1,y2&#125;/&#123;a,b&#125;练习3：如何创建a_c,a_d,b_c,b_d ?~]# mkdir -v &#123;a,b&#125;_&#123;c,d&#125;练习4：如何创建/tmp/bin,/tmp/sbin,/tmp/usr/bin,/tmp/usr/bin,/tmp/usr/sbin~]# mkdir -pv /tmp/&#123;bin,sbin,usr/&#123;bin,sbin&#125;&#125;</code></pre></li><li><em><strong>命令执行的两类结果</strong></em>  <pre><code class="hljs plaintext">命令执行的状态结果：命令执行完成之后，bash会在其内部将其状态返回值保存于bash的特殊变量$?中，echo $?只能获取最近一条命令的执行状态结果成功：0失败：1-255命令执行的返回值：命令正常执行时，有的还会有命令返回值，根据命令及其功能不同，结果各不相同</code></pre></li><li><em><strong>命令别名</strong></em>  <pre><code class="hljs plaintext">命令可以有别名，别名可以与原名相同，此时原名被隐藏，如果要运行原命令，则使用\COMMAND显示当前shell进程所有可用的命令别名：~]# alias定义别名NAME,相当于执行命令VALUE,仅对当前shell进程有效~]# alias NAME=&#x27;VALUE&#x27;撤销别名：~]# unalias NAME----------------------注意：如果想永久有效，要定义在配置文件中编辑配置文件给出的新配置不会立即生效,需要bash进程重新读取配置文件：~]# source /path/to/config_file</code></pre>  <img src="/2018/12/23/os-linux-basic/os-linux-basic-001.png" alt="抱歉,图片休息了"></li><li><em><strong>引用</strong></em>  <pre><code class="hljs plaintext">强引用：&#x27;&#x27;    其中的变量引用不会被替换为变量值,而保持原字符串弱引用：&quot;&quot;    其中的变量引用会被替换为变量值命令引用：``</code></pre></li><li><em><strong>快捷键</strong></em>  <pre><code class="hljs plaintext">Ctrl + l：清屏，相当于clear命令Ctrl + c  取消/终止命令执行------------------Ctrl + a：跳转至命令行行首Ctrl + e：跳转至命令行行尾Ctrl + u：删除行首至光标所在处之间的所有字符Ctrl + k：删除光标所在处至行尾的所有字符</code></pre></li><li><em><strong>文件名通配（globbing）</strong></em>  <pre><code class="hljs plaintext">整体文件名匹配，而非部分-------------匹配模式：元字符*：匹配任意长度的任意字符pa*,*pa*,*pa,*p*a*?：匹配任意单个字符pa?,??pa,p?a,p?a?[]：匹配指定范围内的任意单个字符有几种特殊格式：[a-z],[A-Z],[0-9],[a-z0-9]    这里不区分大小写，要区分大小写用下面的格式[[:upper:]]   所有大写字母[[:lower:]]   所有小写字母[[:alpha:]]   所有字母[[:digit:]]   所有数字,相当于[0-9][[:alnum:]]   所有字母和数字[[:space:]]   所有空白字符[[:punct:]]   所有标点符号[^]：匹配指定范围外的任意单个字符-------------练习1：显示/var目录下所有以l开头，以一个小写字母结尾，且中间出现一位任意字符的文件或目录    ls -d /var/l?[[:lower:]]练习2：显示/etc目录下，以任意一位数字开头，且以非数字结尾的文件或目录    ls -d /etc/[0-9]*[^0-9]练习3：显示/etc目录下，以非字母开头，后面跟一个字母及其它任意长度任意字符的文件或目录    ls -d /etc/[^a-z][a-z]*练习4：复制/etc目录下，所有以m开头，以非数字结尾的文件或目录至/tmp/magedu.com目录    mkdir /tmp/magedu.com    cp -r /etc/m*[^0-9] /tmp/magedu.com/练习5：复制/usr/share/man目录下，所有以man开头，后跟一个数字结尾的文件或目录至/tmp/man目录下    mkdir /tmp/man    cp -r /usr/share/man/man[0-9] /tmp/man/练习6：复制/etc目录下，所有以.conf结尾，且以m,n,r,p开头的文件或目录至/tmp/conf.d目录下    mkdir /tmp/conf.d    cp -r /etc/[mnrp]*.conf /tmp/conf.d</code></pre></li><li><em><strong>IO重定向及管道</strong></em>  <pre><code class="hljs plaintext">程序=指令+数据可用于输入的设备：文件（键盘设备、文件系统上的常规文件、网卡等）可用于输出的设备：文件（显示器、文件系统上的常规文件、网卡、终端设备等）程序的数据流有3种：输入的数据流：&lt;-- 标准输入（stdin），键盘(keyborad)输出的数据流：--&gt; 标准输出（stdout），显示器(monitor)错误输出流：--&gt; 标准错误输出（stderr），显示器(monitor)每个通过内核打开的文件都有一个fd：file descriptor，文件描述符标准输入：0标准输出：1标准错误输出：2</code></pre>  <pre><code class="hljs plaintext">   IO重定向：改变标准位置(不从标准输入读入数据,不往标准输出输出数据)   ---------------------   输出重定向：       &gt;：覆盖重定向(目标文件中的原有内容会被清除)           eg：~]# ls /etc &gt; /tmp/etc.out       &gt;&gt;：追加重定向(新内容会追加至目标文件尾部)           eg：~]# ls /var/log &gt;&gt; /tmp/etc.out   错误输出重定向：2&gt;，2&gt;&gt;   ~]# set -C     禁止将内容覆盖输出至已有文件中       仅对当前shell进程有效       此时可使用强制覆盖输出：&gt;|   ~]# set +C     关闭上述特性   合并标准输出和错误输出为同一个数据流进行重定向：       (1) &amp;&gt;，&amp;&gt;&gt;       (2) COMMAND &gt; /path/to/file.out 2&gt; &amp;1   前面是覆盖，后面的&gt;代表覆盖;&amp;1代表1号数据流,即标准输出           COMMAND &gt;&gt; /path/file.out 2&gt;&gt; &amp;1       特殊设备(数据黑洞，常用作输出重定向到此)：/dev/null           例如：判断一个文件有没有内容时可以用下面的命令               ~]# head -1 /etc/passwd &amp;&gt; /dev/null               ~]# echo $?           后面的shell脚本编程中会有大量的判断，就是基于命令的执行状态结果是成功还是失败来判断要不要继续下去---------------------   输入重定向：&lt;       tr：转换或删除字符           tr [OPTION] ... SET1 [SET2]   当只有使用OPTION时，SET2才可省略               把输入的数据当中的字符，凡是在SET1定义范围内出现的，通通对位转换为SET2出现的字符，并输出到屏幕上来，不会修改源文件           用法1：tr SET1 SET2 &lt; /PATH/FROM/SOMEFILE               例如：~]# tr [a-z] [A-Z] &lt; /etc/issue           用法2：tr -d SET1 &gt; /PATH/FROM/SOMEFILE   删除SET1定义范围内出现的字符       对于默认只能从标准输入(键盘等)读数据的命令(如tr等),可以强行使用输入重定向来改变它   Here Documentation（此处创建文档）：&lt;&lt;       cat &lt;&lt; EOF       cat &gt;&gt; /PATH/TO/SOMEFILE &lt;&lt; EOF           例如：~]# cat &gt;&gt; /tmp/cat.out &lt;&lt; EOF       常用于在脚本中需要输出一大堆信息到文本文件中,可使用此方式</code></pre>  <pre><code class="hljs plaintext">管道：连接程序，实现将前一个命令的输出作为后一个命令的输入，并能多级连接    有了管道以后,就能组合众多目的单一的小程序来完成复杂任务,linux的哲学思想之一---------------------COMMAND1 | COMMAND2 | COMMAND3 ...最后一个命令会在当前shell进程的子shell进程中执行    例如1：~]# echo &quot;$PATH&quot; | tr &#x27;a-z&#x27; &#x27;A-Z&#x27; | tr -d &#x27;U&#x27;    例如2: ~]# cat /etc/rc.d/rc.sysinit | tr &#x27;a-z&#x27; &#x27;A-Z&#x27; | moretee：一路输入产生两路输出(从标准输入读数据,输出至标准输出及指定的文件中)    tee [OPTION...] FILE...    例如1：将echo命令的结果输出到屏幕上，并且又保存至指定文件中        ~]# echo &quot;$PATH&quot; | tr &#x27;a-z&#x27; &#x27;A-Z&#x27; | tee /tmp/path.out        ~]# echo &quot;$PATH&quot; | tee /tmp/path.out | tr &#x27;a-z&#x27; &#x27;A-Z&#x27;---------------------练习1：把/etc/passwd文件的前6行的信息转换为大写字符后保存至/tmp/passwd.out文件中    ~]# head -6 /etc/passwd | tr [a-z] [A-Z] &gt; /tmp/passwd.out练习2：将登录到当前系统上用户信息中的后3位的信自己转换为大写后保存至tmp/who.out文件中    ~]# who | tail -3 | tr &#x27;a-z&#x27; &#x27;A-Z&#x27; &gt; /tmp/who.out</code></pre></li><li><em><strong>提供了编程环境</strong></em>  <pre><code class="hljs plaintext">SHELL程序：提供了编程能力,主要通过调用当前系统上已有的二进制程序组织罗列(过程式),然后解释执行</code></pre></li></ul><h3 id="用户、组和权限管理"><a href="#用户、组和权限管理" class="headerlink" title="用户、组和权限管理"></a>用户、组和权限管理</h3><pre><code class="hljs plaintext">资源分派：3AAuthentication（认证）Authorization（授权）Audition（审计）Linux安全上下文：    前提：文件有属主和属组,进程也有属主和属组。进程的执行是以进程发起者的身份运行，进程对文件的访问权限，取决于发起此进程的用户的权限。        (1)任何一个可执行程序文件能不能启动为进程,取决于发起者对程序文件是否拥有执行权限;        (2)启动为进程之后,其进程的属主为发起者,进程的属组为发起者所属的组;        (3)进程访问文件时的权限,取决于进程的发起者。            (a)进程的发起者,同文件的属主,则应用文件属主权限;            (b)进程的发起者,属于文件的属组,则应用文件属组权限;            (c)否则应用文件&quot;其他&quot;权限。</code></pre><ul><li><p><em><strong>用户类别：Username&#x2F;UID</strong></em></p>  <pre><code class="hljs plaintext">管理员普通用户系统用户登录用户------------------用户标识：UserID，UID16bits二进制数字：0-65535管理员：0普通用户：1-65535系统用户：1-499(CentOS6),1-999(CentOS7)为了能够让那些后台进程或服务类进程以非管理员的身份运行，通常需要为此创建多个普通用户，这类用户从不用登录系统，仅仅是用来让其他进程以他的身份来运行，从而仅能获取普通权限，这类用户就是系统用户。登录用户：500-60000(CentOS6),1000-60000(CentOS7)交互式登录名称解析(名称转换)：登录后，计算机内部会根据名称解析库(/etc/passwd)将每个用户自动转换为数字标识进行使用Username &lt;--&gt; UID/etc/passwd：用户及其属性信息(名称,UID,基本组ID等等)name:password:UID:GID:GECOS:directory:shellname：用户名password：可以是加密的密码，也可是密码占位符UID：GID：用户所属的主组的ID号GECOS：注释信息directory：用户的家目录shell：用户的默认shell，登录时默认shell程序</code></pre></li><li><p><em><strong>组：Groupname&#x2F;GID,将多个用户和某一类权限建立关联关系</strong></em></p>  <pre><code class="hljs plaintext">组类别1：管理员组普通用户组系统组登录组    ------------------组标识：GroupID，GID16bits二进制数字：0-65535管理员组：0普通用户组：1-65535系统用户组：1-499(CentOS6),1-999(CentOS7)登录用户组：500-60000(CentOS6),1000-60000(CentOS7)名称解析：Groupname &lt;--&gt; GID/etc/group：组及其属性信息group_name:password:GID:user_listgroup_name：组名password：组密码占位符GID：user_list：以当前组为附加组的用户列表(分隔符为逗号)组类别2：用户的基本组(主组)用户的附加组(额外组)组类别3：私有组：组名同用户名，且只包含一个用户公共组：组内包含了多个用户</code></pre></li><li><p><em><strong>认证信息：通过比对事先存储的与登录时提供的信息是否一致</strong></em></p>  <pre><code class="hljs plaintext">password: /etc/shadow：用户密码及其相关属性用户名：加密了的密码：最近一次修改密码的时间：最短使用期限：最长使用期限：警告期段：密码禁用期(非活动时间)：账户过期日期：保留字段按时间轴：最近一次修改密码的时间，最短使用期限，警告期段，最长使用期限，密码禁用期(非活动时间)，账户过期日期/etc/gshadow：组密码及其相关属性密码的复杂性策略：防穷举破解、暴力破解1.使用随机密码2.最短长度不要低于8位3.应该使用大写字母、小写字母、数字和标点符号四类字符中至少3种4.定期更换加密：注意：密钥长度越长，加密时所需要的计算量越大，所以也就越慢，所以非对称加密比对称加密据说慢3个数量级（10^3）公钥加密：        对称加密：加密和解密使用同一个密钥            plain text(明文) --&gt;加密算法+密钥 --&gt;cipher text(密文)            cipher text(密文) --&gt;解密算法+密钥 --&gt;plain text(明文)        非对称加密：加密和解密使用一对儿密钥(使用公钥加密的只能使用与之配对的私钥解密，反之亦然)            密钥对儿：                公钥：public key                私钥：private key单向加密：只能加密，不能解密；用于提取数据特征码。例如人来了可以提取指纹，却不能通过指纹把人还原出来特性：定长输出：跟原来的数据量的多少没关系雪崩效应：初始条件的微小改变将会引起结果的巨大变化常见单向加密算法：md5：message digest(消息摘要)，5是版本号，定长输出128bits (1个字节包含8个2进制位,1个16进制可表示4个2进制位,1个字节由2个16进制表示,32位16进制数)sha或sha1：secure hash algorithm(安全的哈希算法)，定长输出160bits,常被用来验证文件sha224：224bitssha256：256bitssha384：384bitssha512：512bits           sha512sum     2^512 =(2^4)^128 =16^128 &gt; 10^80密码加密时为了避免多个用户密码相同时密码一样，真正在计算之时加salt，添加随机数。而且不是以16进制数字保存的，而是以文本编码以后存放的（任何文本字符）</code></pre><p>  <img src="/2018/12/23/os-linux-basic/os-linux-basic-002.png" alt="抱歉,图片休息了"></p></li><li><p><em><strong>权限管理</strong></em></p>  <pre><code class="hljs plaintext">文件的权限主要针对3类对象进行定义：owner：属主,ugroup：属组,gother：其他,o每个文件针对每类访问者都定义了3种权限：r：Readable,可读文件：可使用文件查看工具获取其内容目录：可以使用ls查看此目录中的文件列表w：Writable,可写文件：可修改其内容目录：可以在此目录中创建文件,也可删除此目录中的文件x：eXcutable,可执行文件：可以把此文件提请内核启动为一个进程目录：可以使用ls -l查看此目录中的文件列表,可以cd进入此目录文件或目录创建时的遮罩码：umaskFILE：666-umask如果某类的用户的权限减得的结果中存在x权限,则将其权限+1DIR：777-umask</code></pre><p>  <img src="/2018/12/23/os-linux-basic/os-linux-basic-003.png" alt="抱歉,图片休息了"></p></li><li><p><em><strong>Linux文件系统上的特殊权限</strong></em></p>  <pre><code class="hljs plaintext">SUID：    (1)任何一个可执行程序文件能不能启动为进程,取决于发起者对程序文件是否拥有执行权限;    (2)一旦某可执行文件被设定了SUID,启动为进程之后,其进程的属主为原程序文件的属主,而不是发起者。        打破了安全上下文的规则。例如passwd命令的&quot;提权&quot;机制。    权限设定：        chmod u+s FILE...        chmod u-s FILE...SGID：    (1)默认情况下,用户创建文件时,其属组为此用户所属的基本组;    (2)一旦某目录被设定了SGID,则对此目录有写权限的用户在此目录中创建的文件所属的组为此目录的属组。    权限设定：        chmod g+s DIR...        chmod g-s DIR...STICKY：    (1)对于一个多人可写的目录,即便对别人的文件没有写权限也可以删除它,    (2)如果设置了STICKY,则每个用户仅能删除自己的文件。    权限设定：        chmod o+t DIR...        chmod o-t DIR...----------------------------------------3个特殊权限[SUID SGID STICKY]组合在一起当作一个特殊权限,也映射为一个8进制数字    chmod 1777 /tmp/a.txt   拥有rwx的同时,拥有STICKY权限    chmod 3777 /tmp/a.txt   拥有rwx的同时,拥有SGID,STICKY权限    chmod 4777 /tmp/a.txt   拥有rwx的同时,拥有SUID权限----------------------------------------几个权限位映射：    SUID：owner,占据属主的执行权限位        s：属主拥有x权限        S：属主没有x权限    SGID：group,占据属组的执行权限位        s：属组拥有x权限        S：属组没有x权限    STICKY：other,占据其他的执行权限位        t：其他拥有x权限        T：其他没有x权限</code></pre><p>  <img src="/2018/12/23/os-linux-basic/os-linux-basic-004.png" alt="抱歉,图片休息了"><br>  <img src="/2018/12/23/os-linux-basic/os-linux-basic-005.png" alt="抱歉,图片休息了"><br>  <img src="/2018/12/23/os-linux-basic/os-linux-basic-006.png" alt="抱歉,图片休息了"></p></li></ul><h3 id="bash的配置文件"><a href="#bash的配置文件" class="headerlink" title="bash的配置文件"></a>bash的配置文件</h3><ul><li>按生效范围划分  <pre><code class="hljs plaintext">全局配置：/etc/profile/etc/profile.d/*.sh/etc/bashrc个人配置：~/.bash_profile~/.bashrc</code></pre></li><li>按功能划分  <pre><code class="hljs plaintext">profile类：为交互式登录的shell提供配置功用：1.用于定义环境变量2.运行命令或脚本bashrc类：为非交互式登录的shell提供配置功用：1.用于定义命令别名2.用于定义本地变量</code></pre></li></ul><hr><ul><li>shell登录  <pre><code class="hljs plaintext">交互式登录：直接通过终端输入账号密码登录使用&quot;su - UserName&quot;或&quot;su -l UserName&quot;切换的用户/etc/profile --&gt; /etc/profile.d/*.sh --&gt; ~/.bash_profile --&gt; ~/.bashrc --&gt; /etc/bashrc-----------------------非交互式登录：su UserName图形界面下打开的终端执行脚本~/.bashrc --&gt; /etc/bashrc --&gt; /etc/profile.d/*.sh</code></pre></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSR科学上网：进阶</title>
      <link href="/2018/12/09/st-ssr-advanced.html"/>
      <url>/2018/12/09/st-ssr-advanced.html</url>
      
        <content type="html"><![CDATA[<h1 id="SSR科学上网：进阶"><a href="#SSR科学上网：进阶" class="headerlink" title="SSR科学上网：进阶"></a>SSR科学上网：进阶</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#SSR%E7%9A%84%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%BD%BF%E7%94%A8">SSR 的部署及使用</a></li><li><a href="#SSR%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8">SSR 进阶使用</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>在了解了番茄的相关知识后正式搭建科学上网环境。</li></ul><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>整套SSR 分为 SSR 服务端（部署在 VPS，也就是海外主机），SSR 客户端（部署在本机或者本地路由器或本地手机上）。<br><img src="/2018/12/09/st-ssr-advanced/si-ssr-advanced-001.png" alt="抱歉,图片休息了" title="ssr 部署"></p><h3 id="服务端1"><a href="#服务端1" class="headerlink" title="服务端1"></a><code>服务端1</code></h3><ol><li>下载并执行ssr脚本<ul><li>支持限制用户速度、<code>限制端口设备数</code>、<code>切换管理单/多端口</code>、显示当前连接 IP 等 <pre><code class="hljs bash">[root@host ssr]<span class="hljs-comment"># wget -N --no-check-certificate https://raw.githubusercontent.com/tujidelv/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh </span></code></pre></li><li>支持限制用户速度、<code>限制用户设备数</code>、<code>限制用户总流量</code>、<code>定时流量清零</code>、显示当前连接 IP 等 <pre><code class="hljs plaintext">[root@host ssr]# wget -N --no-check-certificate https://raw.githubusercontent.com/tujidelv/doubi/master/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh</code></pre></li></ul></li></ol><p><img src="/2018/12/09/st-ssr-advanced/si-ssr-advanced-006.png" alt="抱歉,图片休息了" title="ssr脚本主界面"></p><ol start="2"><li>选择 <code>4</code> ，安装 libsodium(chacha20)，如果选择 <code>chacha20</code> 加密方式需要用到 <pre><code class="hljs bash">请输入数字 [1-15]：4[信息] libsodium 未安装，开始安装...[信息] 开始获取 libsodium 最新版本...[信息] libsodium 最新版本为 1.0.16 !</code></pre></li><li>继续执行 <code>./ssr.sh</code>，选择 <code>1</code> ，安装 SSR</li><li>设置端口 &amp; 密码 &amp; 协议，速度方面 <code>chacha20 &gt; RC4-MD5 &gt; AES</code>，但 <code>chacha20</code> 对 VPS 内存要求比较高，至少 1G <pre><code class="hljs bash">[信息] 开始设置 ShadowsocksR账号配置...请输入要设置的ShadowsocksR账号 端口(默认: 2333):1024——————————————————————————————        端口 : 1024——————————————————————————————请输入要设置的ShadowsocksR账号 密码(默认: doub.io):@1024.com——————————————————————————————        密码 : @1024.com——————————————————————————————请选择要设置的ShadowsocksR账号 加密方式          1. none [注意] 如果使用 auth_chain_a 协议，请加密方式选择 none，混淆随意(建议 plain)   2. rc4  3. rc4-md5  4. rc4-md5-6   5. aes-128-ctr  6. aes-192-ctr  7. aes-256-ctr   8. aes-128-cfb  9. aes-192-cfb 10. aes-256-cfb  11. aes-128-cfb8 12. aes-192-cfb8 13. aes-256-cfb8  14. salsa20 15. chacha20 16. chacha20-ietf [注意] salsa20/chacha20-*系列加密方式，需要额外安装依赖 libsodium ，否则会无法启动ShadowsocksR !(默认: 5. aes-128-ctr):15——————————————————————————————        加密 : chacha20——————————————————————————————</code></pre></li><li>选择协议插件，默认是 <code>auth_sha1_v4或者origin</code>，推荐<code>auth_sha1_v4和auth_aes128_md5和auth_aes128_sha1</code> <pre><code class="hljs bash">请选择要设置的ShadowsocksR账号 协议插件         1. origin                           原版协议，为了兼容 2. auth_sha1_v4                     较高安全性，有宽松的时间校对要求，混淆强度大 3. auth_aes128_md5                  最高安全性，有宽松的时间校对要求，计算量相对高一些，混淆强度较大 4. auth_aes128_sha1                 最高安全性，有宽松的时间校对要求，计算量相对高一些，混淆强度较大 5. auth_chain_a 6. auth_chain_b [注意] 如果使用 auth_chain_a 协议，请加密方式选择 none，混淆随意(建议 plain)(默认: 2. auth_sha1_v4):——————————————————————————————        协议 : auth_sha1_v4——————————————————————————————</code></pre></li><li>选择混淆插件，默认是 <code>plain</code>，支持SS客户端，推荐 <code>plain,http_simple,http_post,tls1.2_ticket_auth</code> <pre><code class="hljs bash">是否设置 协议插件兼容原版(_compatible)？[Y/n]y请选择要设置的ShadowsocksR账号 混淆插件         1. plain 2. http_simple 3. http_post 4. random_head 5. tls1.2_ticket_auth [注意] 如果使用 ShadowsocksR 加速游戏，请选择 混淆兼容原版或 plain 混淆，然后客户端选择 plain，否则会增加延迟 ! 另外, 如果你选择了 tls1.2_ticket_auth，那么客户端可以选择 tls1.2_ticket_fastauth，这样即能伪装又不会增加延迟 ! 如果你是在日本、美国等热门地区搭建，那么选择 plain 混淆可能被墙几率更低 ! [注意]不要奇怪为什么推荐plain，因为混淆不总是有效果，要看各地区的策略的，有时候不混淆让其看起来像随机数据更好。(默认: 1. plain):5——————————————————————————————        混淆 : tls1.2_ticket_auth——————————————————————————————</code></pre></li><li>接下来默认回车即可 <pre><code class="hljs bash">是否设置 混淆插件兼容原版(_compatible)？[Y/n]y请输入要设置的ShadowsocksR账号 欲限制的设备数 ( auth_* 系列协议 不兼容原版才有效 )[注意] 设备数限制：每个端口同一时间能链接的客户端数量(多端口模式，每个端口都是独立计算)，建议最少 2个。(默认: 无限):请输入要设置的每个端口 单线程 限速上限(单位：KB/S)[注意] 单线程限速：每个端口 单线程的限速上限，多线程即无效。(默认: 无限):请输入要设置的每个端口 总速度 限速上限(单位：KB/S)[注意] 端口总限速：每个端口 总速度 限速上限，单个端口整体限速。(默认: 无限):[信息] 开始安装/配置 ShadowsocksR依赖...</code></pre></li><li>最后会输出账号信息，从上往下依次为 SSR 帐号的IP、端口、密码、加密方式、协议插件和混淆插件等。<br> <img src="/2018/12/09/st-ssr-advanced/si-ssr-advanced-002.png" alt="抱歉,图片休息了" title="ssr 帐号信息"><br> <img src="/2018/12/09/st-ssr-advanced/si-ssr-advanced-004.png" alt="抱歉,图片休息了"></li></ol><h3 id="服务端2"><a href="#服务端2" class="headerlink" title="服务端2"></a><code>服务端2</code></h3><ol><li>脚本说明 <pre><code class="hljs plaintext">本脚本适用环境：    系统支持：CentOS，Debian，Ubuntu    内存要求：≥128M    作者：秋水逸冰关于本脚本：    一键安装 ShadowsocksR 服务端    请下载与之配套的客户端程序来连接配置说明：    服务器端口：自己设定（如不设定，默认为 8989）    密码：自己设定（如不设定，默认为 teddysun.com）    加密方式：自己设定（如不设定，默认为 aes-256-cfb）    协议（Protocol）：自己设定（如不设定，默认为 origin）    混淆（obfs）：自己设定（如不设定，默认为 plain）配置方法：    使用root用户登录，执行以下命令：</code></pre></li><li>下载并执行脚本 <pre><code class="hljs plaintext">[root@host ssr]# wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh[root@host ssr]# chmod +x shadowsocksR.sh[root@host ssr]# ./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log</code></pre></li><li>安装完成 <pre><code class="hljs plaintext">Congratulations, ShadowsocksR server install completed!Your Server IP        :your_server_ipYour Server Port      :your_server_portYour Password         :your_passwordYour Protocol         :your_protocolYour obfs             :your_obfsYour Encryption Method:your_encryption_methodWelcome to visit:https://shadowsocks.be/9.htmlEnjoy it!</code></pre></li><li>常用命令 <pre><code class="hljs plaintext">卸载：./shadowsocksR.sh uninstall启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart状态：/etc/init.d/shadowsocks status配置文件路径：/etc/shadowsocks.json日志文件路径：/var/log/shadowsocks.log代码安装目录：/usr/local/shadowsocks</code></pre></li><li>多用户配置示例 <pre><code class="hljs plaintext">&#123;&quot;server&quot;:&quot;0.0.0.0&quot;,&quot;server_ipv6&quot;: &quot;[::]&quot;,&quot;local_address&quot;:&quot;127.0.0.1&quot;,&quot;local_port&quot;:1080,&quot;port_password&quot;:&#123;    &quot;8989&quot;:&quot;password1&quot;,    &quot;8990&quot;:&quot;password2&quot;，    &quot;8991&quot;:&quot;password3&quot;&#125;,&quot;timeout&quot;:300,&quot;method&quot;:&quot;aes-256-cfb&quot;,&quot;protocol&quot;: &quot;origin&quot;,&quot;protocol_param&quot;: &quot;&quot;,&quot;obfs&quot;: &quot;plain&quot;,&quot;obfs_param&quot;: &quot;&quot;,&quot;redirect&quot;: &quot;&quot;,&quot;dns_ipv6&quot;: false,&quot;fast_open&quot;: false,&quot;workers&quot;: 1&#125;</code></pre></li></ol><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a><code>客户端</code></h3><ul><li>下载  <pre><code class="hljs plaintext">Windows：https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releasesAndroid：https://github.com/shadowsocksr-backup/shadowsocksr-android/releasesLinux：https://github.com/the0demiurge/CharlesScripts/blob/master/charles/bin/ssr（命令行界面， Mac 也能用，使用方法见注释）macOS：https://github.com/shadowsocksr-backup/ShadowsocksX-NG/releases（Mac 也能用 Linux 版的）iOS：https://github.com/Alvin9999/new-pac/wiki/%E8%8B%B9%E6%9E%9C%E6%89%8B%E6%9C%BA%E7%BF%BB%E5%A2%99%E8%BD%AF%E4%BB%B6-------------------------------------pac文件地址：https://pan.lanzou.com/i09dv1e-------------------------------------.NET Framework 4.7：http://download.microsoft.com/download/D/D/3/DD35CC25-6E9C-484B-A746-C5BE0C923290/NDP47-KB3186497-x86-x64-AllOS-ENU.exe?desc=dotnet47.NET Framework 4.6.2：https://download.microsoft.com/download/D/5/C/D5C98AB0-35CC-45D9-9BA5-B18256BA2AE6/NDP462-KB3151802-Web.exe?desc=dotnet462.NET Framework 4.5.2：http://download.microsoft.com/download/E/2/1/E21644B5-2DF2-47C2-91BD-63C560427900/NDP452-KB2901907-x86-x64-AllOS-ENU.exe?desc=dotnet452.NET Framework 2.0+3.5SP1：http://download.microsoft.com/download/2/0/E/20E90413-712F-438C-988E-FDAA79A8AC3D/dotnetfx35.exe?source=getdotnet&amp;desc=dotnet35</code></pre></li><li>安装  <pre><code class="hljs plaintext">将压缩包解压，文件内含7个文件。下载pac.txt文件，放入文件夹内。-------------------------------------文件夹内有两个.exe文件，两个版本的功能是完全一样的，不同之处是根据你系统安装的 .NET Framework 支持库版本，这个支持库有v2.0/3.5/4.0/4.5等版本，且每个版本都是独立的。这里的 .NET Framework v2.0就是对应的 DotNet2.0 Shadowsocks客户端，v4.0则是对应 DotNet4.0的。Shadowsocks是C#语言写的，所以需要安装这个微软的支持库，Shadowsocks原版是更新到2.5.2后就取消支持v2.0了，但是ShadowsocksR依然支持。这支持库是一般来说XP是都没有安装的，Win7则是系统自带v2.0，win8以后是自带v4.0。所以自己看着支持库的安装情况选择版本就行了，功能无差别。-------------------------------------PAC中文名叫做代理自动配置，PAC其实就是 HTTP/SOCKS等代理服务器 + 网址规则，只有在你浏览器访问网址规则中包含的网站时才会走PAC文件中包含指定的HTTP/SOCKS代理服务器。因为Shadowsocks作者喝茶后，原本维护更新的PAC（GFWlist）文件也被删除，不过由ShadowsocksR作者接手维护了，由网友不断的提交新的被墙的网址和IP。目前分为域名白名单、黑名单、黑白名单，同时也有IP的名单。由于SSR也停更删除了项目，目前该文件也已经无法更新了。右键pac-更新会提示failed。-------------------------------------ShadowsocksR目前分两种规则方式，那就是系统代理模式（直接连接[不经过代理直接访问]、PAC[匹配pac.txt内的域名后执行]、全局[不管啥域名全都走代理]） 和 代理规则，这两种判断方式是相互配合使用的。先用系统代理模式来判断是否让数据进入SSR客户端，再用代理规则来判断进入SSR客户端的数据是直连还是走代理。-------------------------------------当你访问XXX网站，然后是全局或者满足PAC条件（不满足条件就直接直连访问了，也不会有接下来的代理规则判断了），从而访问XXX网站的请求数据流量进入了客户端，然后客户端会根据XXX网站的IP来判断，如下：    绕过局域网：当IP属于局域网内的，那么SSR客户端就会让流量直连，反之则会让流量走代理（发送到SSR服务端）。    绕过局域网和大陆：当IP属于大陆内或局域网的，那么SSR客户端就会让流量直连，反之则会让流量走代理（发送到SSR服务端）。    绕过局域网和非大陆：当IP属于大陆外(非大陆IP都算大陆外)或局域网的，那么SSR客户端就会让流量直连，反之则会让流量走代理（发送到SSR服务端）。    全局：无论什么情况都直接走代理。举例说明：    当你选择系统代理模式-pac模式后，假如你访问www.google.com ，浏览器在PAC文件中匹配这个域名，并发现这个域名按PAC规则应走代理，所以浏览器就会发送访问网页数据到PAC中的代理服务器，于是SSR客户端就收到了访问谷歌的数据，而这时候就该用代理规则判断了。    代理规则为：绕过局域网，则判断www.google.com域名的IP是否是局域网IP，然而不是局域网IP，于是走代理。    代理规则为：绕过局域网和大陆，则判断www.google.com域名的IP是否是局域网IP或大陆IP，然而不是局域网IP或大陆IP，于是走代理。    代理规则为：绕过局域网和非大陆，则判断www.google.com 名的IP是否是局域网IP或非大陆IP，然而是非大陆IP，于是不走代理，直连。    代理规则为：全局，不判断www.google.com域名的IP，直接走代理。-------------------------------------</code></pre></li><li>使用  <pre><code class="hljs plaintext">常用连接的方式有以下几种：    二维码扫描：可以扫描屏幕上的SSR配置信息二维码并导入服务器配置中。二维码通常由你的SSR供应商提供。    剪贴板批量导入ssr://链接：如果你的SSR供应商有提供批量SSR服务器配置链接，你就可以复制之后通过这里导入。    手动输入：单击图标出来服务器配置界面，输入IP、端口、密码、加密、协议、混淆，这些资料都由供应商提供。    订阅服务器：可订阅服务器，自动从服务器更新SSR，这是最方便的，但是也是最难找的。添加完成后，右键—服务器选择相应的服务器，选择好代理模式、代理规则即可上网。状态显示：    普通情况下，图标颜色为 深蓝色。    当你选择 系统代理模式 — PAC模式 的时候，图标颜色为 浅绿色。    当你选择 系统代理模式 — 全局模式 的时候，图标颜色为 浅蓝色(浅青色)。    当你启动 服务器负载均衡 功能的时候，图标颜色从 深蓝色 变为 粉红色。    当你启动 服务器负载均衡 功能并选择 系统代理模式 — PAC模式 的时候，图标颜色为 浅橙色。    当你启动 服务器负载均衡 功能并选择 系统代理模式 — 全局模式 的时候，图标颜色为 白色。</code></pre></li><li>常见问题及技巧  <pre><code class="hljs plaintext">1.连上了代理但是无法上谷歌、推特等    按下键盘组合键“Win + R”调出运行窗口,输入“cmd”（不带引号）然后回车，这时会打开“命令提示符”,输入ipconfig /flushdns然后回车2.正确添加了配置，但无法正常使用代理上网    a.你可能根本就连不上你的ss代理服务器。可以ping服务器地址,如ping不通说明你目前的网络情况根本无法连接代理。    b.你的SSR配置可能不正确。如果你是手动填写的配置而不是通过SSR提供商的一键配置来添加，那可能会出现这种情况，请检查一下你的配置是否正确。    c.SSR的系统代理模式和代理规则是否正确。通常来讲推荐萌新的设置是，系统代理模式选择“全局模式”，代理规则选择“绕过局域网和大陆”。3.更改图标    把一个名为icon.png的PNG图片放到ShadowsocksR客户端文件夹内（和ShadowsocksR-dotnetX.0.exe 放在一起），然后重新启动ShadowsocksR客户端。OK</code></pre></li><li>常用免费 SSR 帐号分享  <pre><code class="hljs plaintext">https://doub.bid/sszhfx/ 逗比根据地 免费SShttps://free-ss.site/ 免费帐号 免费SShttps://ssr.plus/ 免费帐号 需回复后才能看，无需注册http://www.hishadowsocks.com/ 4小时换1次https://ssray.club/</code></pre></li></ul><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="魔改BBR加速SSR"><a href="#魔改BBR加速SSR" class="headerlink" title="魔改BBR加速SSR"></a>魔改BBR加速SSR</h3><ul><li>注意点<ol><li>kvm优化的话，只能bbr、魔改bbr、锐速三选一，速度从高到低大概是 <code>魔改BBR &gt; 锐速 &gt; BBR</code>。</li><li>重装系统那里，后缀带<code>bbr</code>的表示重装后自带bbr并且默认开启了，但是没有经过魔改的bbr速度远不及锐速。</li><li>同时bbr只支持4.9以上4.13以下的内核，锐速不支持4.9以上的内核，所以不能共存。但他们都可以和kcptun共存。</li><li>锐速技术成熟，已经停止更新；而BBR是2016年才出现的新技术，未来的发展性很强。所以从短期看，锐速或者BBR视情况都可以，从长期来说，BBR终究是主流。</li></ol></li><li>重装系统<ul><li>在main-controls那里stop机器，然后install new os，安装CentOS7_86x64。复制密码准备登录主机。密码和端口也会发到你的邮箱。</li></ul></li><li>安装最合适的内核<ul><li>可以使用 <code>uanme -a</code> 查看内核信息，BBR算法的部署，需要注意内核版本，如果过低会造成崩溃。</li><li>安装新内核后，输入Y，系统会自动断开shell，重启一次，重新登录后将启用新的内核。  <pre><code class="hljs bash">wget --no-check-certificate -O C71.sh https://raw.githubusercontent.com/tujidelv/CBBR/master/C71.sh &amp;&amp; <span class="hljs-built_in">chmod</span> +x C71.sh &amp;&amp; bash C71.sh</code></pre></li></ul></li><li>使用脚本编译开启魔改的 bbr  <pre><code class="hljs bash">wget --no-check-certificate -O C72.sh https://raw.githubusercontent.com/tujidelv/CBBR/master/C72.sh &amp;&amp; <span class="hljs-built_in">chmod</span> +x C72.sh &amp;&amp; bash C72.sh</code></pre></li><li>结束后，显示 Finish 表示正常，或者执行 <code>lsmod |grep &#39;bbr_powered&#39;</code> 结果不为空，则加载模块成功。<br>  <img src="/2018/12/09/st-ssr-advanced/si-ssr-advanced-003.png" alt="抱歉,图片休息了"></li></ul><h3 id="BBRplus加速SSR"><a href="#BBRplus加速SSR" class="headerlink" title="BBRplus加速SSR"></a>BBRplus加速SSR</h3><ul><li>下载加速脚本,支持<code>CentOS 6+、Debian 8+、Ubuntu 14+</code>  <pre><code class="hljs plaintext">wget -N --no-check-certificate &quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</code></pre></li><li>打开脚本,根据自己需求安装对应的内核和加速<br>  <img src="/2018/12/09/st-ssr-advanced/si-ssr-advanced-005.png" alt="抱歉,图片休息了"></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.moerats.com/archives/387">BBR+BBR魔改+Lotsever(锐速)一键脚本 for Centos&#x2F;Debian&#x2F;Ubuntu</a></li><li><a href="https://www.debugnode.com/ubuntul_ibsodium">安装libsodium库解决libsodium not found问题</a></li><li><a href="http://www.wangchao.info/1549.html">ShadowsocksR(SSR)一键安装脚本 By 秋水逸冰</a></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> 科学上网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSR科学上网：基础</title>
      <link href="/2018/12/09/st-ssr-basic.html"/>
      <url>/2018/12/09/st-ssr-basic.html</url>
      
        <content type="html"><![CDATA[<h1 id="SSR科学上网：基础"><a href="#SSR科学上网：基础" class="headerlink" title="SSR科学上网：基础"></a>SSR科学上网：基础</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#SSR%E7%9A%84%E5%8E%86%E5%8F%B2">SSR 的历史</a></li><li><a href="#SSR%E7%9A%84%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">SSR 的相关实现原理</a></li><li><a href="#VPS%E7%9A%84%E7%A7%91%E6%99%AE">VPS 的科普</a></li><li><a href="#VPS%E7%9A%84%E8%B4%AD%E4%B9%B0%E5%8F%8A%E4%BD%BF%E7%94%A8">VPS 的购买及使用</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>维基百科：<blockquote><p>Shadowsocks可以指：一种基于Socks5代理方式的加密传输协议，也可以指实现这个协议的各种开发包。目前包使用Python、C、C++、C#、Go语言等编程语言开发，大部分主要实现（iOS平台的除外）采用Apache许可证、GPL、MIT许可证等多种自由软件许可协议开放源代码。Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。</p></blockquote><blockquote><p>在中国大陆，本工具也被广泛用于突破防火长城（GFW），以浏览被封锁、遮蔽或干扰的内容。</p></blockquote></li></ul><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><ol><li>2012 年 4 月 20 日，<a href="https://twitter.com/clowwindy">clowwindy</a> 因为兴趣而制作了 <code>Shadowsocks</code> 项目，并于 Github 上开源 SS。</li><li>2015 年 8 月 22 日，<code>Shadowsocks</code> 原作者 <code>Clowwindy</code> 被“相关部门”约谈喝茶，被迫宣布停止维护此计划（项目）并删除 Github 的源码及相关文档。<ul><li>应网友要求，另一个开发者把 v2.5.8 的一些严重 BUG 修复了更新为 v3.0，然后宣布不再管了。</li><li>8月25日，另一个用于突破网络审查的 <a href="https://zh.wikipedia.org/wiki/GoAgent">GoAgent</a> 项目也被作者自行删除。</li></ul></li><li>尽管如此，Git 仓库的日志显示该项目被移除以前就有大量的复刻副本，所以事实上并未停止维护，而是转由其他贡献者们持续维护中。<ul><li>因此，后续版本多种多样，而 SSR 只是较为普遍的一种。SS 以及后续的 SSR 均统一采用纸飞机的图样。</li></ul></li><li>其中由 <code>@breakwa11</code>(<a href="https://twitter.com/breakwa11">破娃酱</a>) 发起的 <code>ShadowsocksR</code> 项目就是 SS 的一个后续版本分支。<ul><li>在 SS 的基础上增加了一些数据混淆方式，称修复了部分安全问题并可以提高 QoS 优先级。后来贡献者 Librehat 也为 SS 补上了一些此类特性，甚至增加了类似 Tor 的可插拔传输层功能。</li></ul></li><li>SSR 开始时曾有过违反 GPL、发放二进制时不发放源码的争议，不过后来 SSR 项目由 <code>breakwa11</code>转为了与 SS 相同的 GPL、Apache 许可证、MIT 许可证等多重自由软件许可协议。</li><li>2017 年 7 月 19 日，SSR 作者 <code>breakwa11</code>在 Telegram 频道 <code>ShadowsocksR news</code> 里转发了深圳市启用 SS 协议检测并被大量用户转发，引发恐慌。</li><li>2017 年 7 月 24 日，<code>breakwa11</code> 发布了闭源的 SS 被动检测程序，引发争议。</li><li>2017 年 7 月 27 日，<code>breakwa11</code> 删除 GitHub 上的所有代码、解散相关交流群组，停止 SSR 项目。<ul><li><code>breakwa11</code> 遭到自称 “ESU.TV” 的不明身份人士人身攻击，对方宣称如果不停止开发并阻止用户讨论此事件将发布更多包含个人隐私的资料。</li><li>随后 <code>breakwa11</code> 表示遭到对方人肉搜索并公开个人资料的是无关人士，为了防止对方继续伤害无关人士，才停止该项目。</li></ul></li><li>但项目已被多人 fork。并有人在其基础上继续发布新的版本，例如 <a href="https://github.com/shadowsocksrr/shadowsocksr-csharp">SSRR</a>。</li></ol><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="大概原理"><a href="#大概原理" class="headerlink" title="大概原理"></a><code>大概原理</code></h3><ul><li>天朝局域网通过 <a href="https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E9%95%BF%E5%9F%8E">GFW</a> 隔离了我们与外界的交流，当然，这个隔离并非完全隔离，而是选择性的，天朝不希望你上的网站就直接阻断。</li><li>每一个网络请求都是有数据特征的，不同的协议具备不同的特征，比如 HTTP&#x2F;HTTPS 这类请求，会很明确地告诉 GFW 它们要请求哪个域名；再比如 TCP 请求，它只会告诉 GFW 它们要请求哪个 IP。</li><li><code>GFW</code> 封锁包含多种方式，最容易操作也是最基础的方式便是域名黑白名单，在黑名单内的域名不让通过，IP 黑白名单也是这个道理。</li><li>如果你有一台国外服务器不在 <code>GFW</code> 的黑名单内，天朝局域网的机器就可以跟这一台机器通讯。</li><li>那么一个番茄的方案就出来了：境内设备与境外机器通讯，境内想看什么网页，就告诉境外的机器，让境外机器代理抓取，然后送回来，我们要做的就是保证境内设备与境外设备通讯时不被 GFW 怀疑和窃听。</li></ul><p><img src="/2018/12/09/st-ssr-basic/si-ssr-basic-001.png" alt="抱歉,图片休息了" title="ssr 原理图"></p><h3 id="必备简易命令，查错方法"><a href="#必备简易命令，查错方法" class="headerlink" title="必备简易命令，查错方法"></a><code>必备简易命令，查错方法</code></h3><ol><li>以下命令用于查找本地 1080 端口所有 TCP 通信，可以看到相关端口转发与应用程序 PID 号 <pre><code class="hljs plaintext">netstat -aon|findstr &quot;1080&quot;</code></pre></li><li>利用 PID 号，可以定位到相关应用程序，可以在任务管理器中查找</li><li>下面通过 PID 号查找相关 TCP 信息 <pre><code class="hljs plaintext">netstat -aon|findstr &quot;16656&quot;netstat -aon|findstr &quot;25556&quot;</code></pre></li></ol><h3 id="时下流行的几款番茄软件端口介绍"><a href="#时下流行的几款番茄软件端口介绍" class="headerlink" title="时下流行的几款番茄软件端口介绍"></a><code>时下流行的几款番茄软件端口介绍</code></h3><ul><li>使用软件过程中，我们所关心的就是本地端的配置，服务端要不是自己搭建，要么别人已经建好。</li><li>本地端最重要的就是协议，地址，端口。除去网页代理器等，不需要软件直接 FQ 的，地址往往是 127.0.0.1，代理协议目前常用的就是 HTTP&#x2F;HTTPs 以及 Socks5，本地端口介绍如下 <pre><code class="hljs plaintext">SS,SSR：1080GAE 类(例如 XX-NET)：8087神风：88872 系列灯：87873、4系列灯：灯设置页面查看Tor：9050 是 TorBrowser的，9150 是外部浏览器调用的端口</code></pre></li><li>任何软件，如果你不知道端口，都可以通过 PID 号定位到本地端口，供 <code>switchyomega</code> 调用！</li></ul><h2 id="VPS科普"><a href="#VPS科普" class="headerlink" title="VPS科普"></a>VPS科普</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a><code>作用</code></h3><ul><li>维基百科：<blockquote><p>虚拟专用服务器（英语：Virtual private server，缩写为 VPS），是将一台服务器分割成多个虚拟专享服务器的服务。实现VPS的技术分为容器技术和虚拟机技术 。<br>  在容器或虚拟机中，每个VPS都可分配独立公网IP地址、独立操作系统、实现不同VPS间磁盘空间、内存、CPU资源、进程和系统配置的隔离，为用户和应用程序模拟出“独占”使用计算资源的体验。<br>  VPS可以像独立服务器一样，重装操作系统，安装程序，单独重启服务器。<br>  VPS为用户提供了管理配置的自由，可用于企业虚拟化，也可以用于IDC资源租用。IDC资源租用，由VPS提供商提供。<br>  不同VPS提供商所使用的硬件VPS软件的差异，及销售策略的不同，VPS的使用体验也有较大差异。尤其是VPS提供商超卖，导致实体服务器超负荷时，VPS性能将受到极大影响。<br>  相对来说，容器技术比虚拟机技术硬件使用效率更高，更易于超卖，所以一般来说容器VPS的价格都高于虚拟机VPS的价格。这些VPS主机以最大化的效率共享硬件、软件许可证以及管理资源。<br>  每个VPS主机都可分配独立公网IP地址、独立操作系统、独立超大空间、独立内存、独立CPU资源、独立执行程序和独立系统配置等。<br>  VPS主机用户可在服务器上自行安装程序，单独重启主机。</p></blockquote></li><li>简单的说，VPS 相当于一台微型电脑。 购买之后，相当于你在远程（国内，海外，甚至远在美国）可以使用一台电脑作为服务器。</li><li>而通过这台服务器，你可以做很多很多事情。SSR 只是【搭梯子】的一种方式；而【搭梯子】也只是 VPS 的用途之一。  <pre><code class="hljs plaintext">1.搭建一个Seafile服务器，你将拥有一个属于自己的Dropbox（多平台同步、版本管理……）+ 在线协作平台，（在线编辑、评论、Wiki、消息……） 也就是搭建同步网盘。2.贡献出VPS的计算资源帮助世界抗击儿童癌症、搜寻外星文明（SETI）、寻找梅森素数（GIMPS）等等，或许还能赢取十万美元。3.可以搭建一个邮局。4.可以挂上国外的挂机软件赚钱。5.可以用来建网站。VPS是用来存放数据的，简单的说，网站是由“域名+主机”组成。买了VPS，可以存放数据，如果注册了域名，这个网站就可以访问了。6.搭建私服。7.存放电影资源，想看电影的时候打开即可。VPS都有硬盘资源的，购买的时候会有明确的标示。8.免流。所谓【免流】，就是“流量免费”。我们用手机上网的时候，服务商（比如移动）会收取流量费，但有些场景不会收取，比如访问移动10086的网页，这个和给10086发短信免费是一样的，有可能不收取，但不一定。这时候，通过VPS，通过酸酸乳特有的【混淆插件】，将自己访问的数据，伪装成访问服务商的网站，那么服务商会认为你只是访问服务商，而不收取流量费。说白了，就是上网不要钱。 然而，这是不妥的行为，不赞成这样的操作。9.搭建私人聊天室。搭建在线聊天室，实现多人聊天等等。 总之，VPS可以做的事情很多。而酸酸乳，只是其中一种应用方式。</code></pre></li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a><code>架构</code></h3><ul><li>现在的 VPS 多数的架构是 openVZ 和 KVM；当然，还有不分 xen 的，但逐渐减少慢慢消失。<ul><li>同等情况下，同等价格之下最好选择是KVM。因为KVM 架构可以更方便的使用加速服务和减少超售(带水分)现象。</li></ul></li><li>识别 KVM 和 openVZ  <pre><code class="hljs plaintext">除了服务商标注的KVM或openVZ之外，亦可通过登陆主机执行命令识别----------------------------------1.执行：ls /proc/    通过系统上的相关目录或文件判断,一般Xen的VPS，/proc目录下面会有xen的目录，openvz的会有vz目录。2.执行：free -m     看内存，openvz的没有swap，当然也有xen的没有swap，但是xen的是的，openvz不行。3.执行：uname -a    有些xen的VPS里面会显示有xen。4.执行：ifconfig    查看网卡，openvz的一般都是venet0，xen的一般都是eth。</code></pre></li></ul><h3 id="线路选择"><a href="#线路选择" class="headerlink" title="线路选择"></a><code>线路选择</code></h3><ul><li>使用 ping 命令查看延迟时间  <pre><code class="hljs plaintext">例如ping hnd-jp-ping.vultr.com这是vultr日本数据节点的测试结果，稳定100ms；这是大致的结果，其可靠性并不强。</code></pre></li><li>多地 ping  <pre><code class="hljs plaintext">所谓多地ping，也就是位于各地范围之内，对该主机进行ping，这样获得更为普遍的数值。注：如果多地ping都超时，无疑，IP就GG了。全国都连不上了，还不GG？ 近些日子，jp的服务器就有不少挂掉的，连接全部超时，墙高了。参考网址：http://ping.chinaz.com</code></pre></li><li>文件下载测试  <pre><code class="hljs plaintext">我们也可通过下载文件来测试连接速度。各种VPS评测网站非常多，而VPS的主机节点，都会公开展示，很容易就可以找到。</code></pre></li><li>路由追踪  <pre><code class="hljs plaintext">路由追踪是一款实用工具，可以通过地图的形式，展现数据到VPS之间传输的节点。 地址：http://www.webkaka.com/Tracert.aspx（在线路由追踪）、http://www.ipip.net/download.html#ip_trace（本地追踪软件）、https://www.ipip.net/traceroute.php同等情况下，直达定然优于绕道。 节点越多越麻烦，节点越少，当然也就越有利。</code></pre>  <pre><code class="hljs plaintext">此外还有专门的路由测试软件，请前往下载Best trace软件，下载完成后安装。    https://www.ipip.net/product/client.html然后打开软件，点击右侧的路由跟踪按钮，打开路由跟踪界面，输入vps的ip，点击开始，就可以得到vps与你本地的路线走向图了。</code></pre>  <img src="/2018/12/09/st-ssr-basic/si-ssr-basic-008.png" alt="抱歉,图片休息了" title="路由追踪"></li></ul><h3 id="地域总结"><a href="#地域总结" class="headerlink" title="地域总结"></a><code>地域总结</code></h3><pre><code class="hljs plaintext">中国大陆首选的境外VPS，速度上，    1.港澳台是首选（毕竟最近）但是，港澳台的VPS比较贵！香港的VPS很多带宽非常小，1M带宽... ping数值100以内。     2.日本、新加坡是主流。ping数值100-150以内。但是近期，日本、新加坡VPS封锁特别严重。    3.中规中矩的还有美国的服务器。ping数值在150--200之间。有直达的中美海底光缆，速度上稍弱于日本（距离上就看得出来），但还算可以，尤其是CN2等专线的建设。    4.不考虑非洲或者其他地区，再看一下欧洲VPS。</code></pre><pre><code class="hljs plaintext">事实上，如果是简单的搭个梯子，即便ping的数值是300ms，实际上看Youtube视频，其连接速度也可以达到6K附近。如果是200ms，10k以上是毫无问题的。 因此，购买VPS之后搭建SSR的话，YouTube视频的1080p高清，根本不是问题。除非你的主机响应远远超过350ms服务器远在地球之外了。除了以上由本地或多地ping主机之外，也可以进行【回测】：也就是购买了主机之后，从主机端ping回到我们的本地。 通常我们搭个梯子啥的，更重要的是回程，所以这更具有参考性。</code></pre><h2 id="VPS购买及使用"><a href="#VPS购买及使用" class="headerlink" title="VPS购买及使用"></a>VPS购买及使用</h2><h3 id="BandwagonHost-VPS"><a href="#BandwagonHost-VPS" class="headerlink" title="BandwagonHost VPS"></a>BandwagonHost VPS</h3><ol><li>选择对应且需要的VPS方案<ul><li><a href="https://bwh88.net/">官网</a></li><li><a href="http://banwagong.cn/">搬瓦工VPS中文网</a></li><li>即便我们购买低配置方案之后，以后也可以升级到其他方案的。</li></ul></li><li>核对方案配置以及选择时间期限和机房<ul><li>核对我们选择方案的价格，没有问题后点击CHECKOUT结账。<br> <img src="/2018/12/09/st-ssr-basic/si-ssr-basic-002.png" alt="抱歉,图片休息了"><br> <img src="/2018/12/09/st-ssr-basic/si-ssr-basic-003.png" alt="抱歉,图片休息了"></li></ul></li><li>登录或者新注册搬瓦工账户<ul><li>如果我们有过账户，可以直接点击”Click here to login”登录以及付款就可以，如果还没有账户则需要注册账户。</li><li>个人信息不要真实的，但也不能太离谱和乱写字符出来，好歹也要稍微用点拼音。</li><li>我们不能用代理IP登录注册账户，国家需要真实，不要乱选择。<br> <img src="/2018/12/09/st-ssr-basic/si-ssr-basic-004.png" alt="抱歉,图片休息了"></li></ul></li><li>付款成功以及使用<br> <img src="/2018/12/09/st-ssr-basic/si-ssr-basic-005.png" alt="抱歉,图片休息了"><br> <img src="/2018/12/09/st-ssr-basic/si-ssr-basic-006.png" alt="抱歉,图片休息了"><br> <img src="/2018/12/09/st-ssr-basic/si-ssr-basic-007.png" alt="抱歉,图片休息了"></li><li>申请退款政策和方法<ul><li>申请退款需要账户注册 30 天之内，不是 VPS 主机 30 天内，如果我们是老账户是不支持退款的。</li><li>申请地址：<a href="https://bwh8.net/refund.php">https://bwh8.net/refund.php</a></li></ul></li></ol><h3 id="检查搬瓦工-IP-端口是否被封"><a href="#检查搬瓦工-IP-端口是否被封" class="headerlink" title="检查搬瓦工 IP&#x2F;端口是否被封"></a>检查搬瓦工 IP&#x2F;端口是否被封</h3><ul><li>方法1<ol><li>打开端口扫描工具 <a href="http://tool.chinaz.com/port/">http://tool.chinaz.com/port/</a></li><li>输入 VPS 的 IP 和 SSH 端口号并点击 <code>开始扫描</code> 进行扫描<br> <img src="/2018/12/09/st-ssr-basic/si-ssr-basic-009.png" alt="抱歉,图片休息了"></li><li>一般来说，如果被封了，会显示端口是关闭状态。如果没被封，那么这里显示的都是打开状态，恭喜，你的 IP 一切正常。</li><li>然后找一个国外的提供类似测试的网站例如 <a href="https://www.yougetsignal.com/tools/open-ports/">https://www.yougetsignal.com/tools/open-ports/</a></li><li>输入 VPS 的 IP 和 SSH 端口号并点击 <code>Check</code> 进行检查<br> <img src="/2018/12/09/st-ssr-basic/si-ssr-basic-010.png" alt="抱歉,图片休息了"></li><li>如果此时显示端口是 <code>open</code> 的，那么你的 IP 地址就是被封了。如果这时候也显示 <code>closed</code>，那么你可能还有救，尝试一下重启或者重装 VPS 吧。</li></ol></li><li>方法2<ol><li>首先登陆我们被封了 IP 的 VPS 的 KiwiVM 面板</li><li>登陆之后，打开 <a href="https://kiwivm.64clouds.com/main-exec.php?mode=blacklistcheck">https://kiwivm.64clouds.com/main-exec.php?mode=blacklistcheck</a></li><li>打开之后，点击 <code>Test Main IP</code> 进行测试，会检查你的 IP 地址是否已经被封<br> <img src="/2018/12/09/st-ssr-basic/si-ssr-basic-011.png" alt="抱歉,图片休息了"></li><li>如果没有被封，会显示 <code>IP NOT BLOCKED</code>，如果被封了，会红色加粗显示<code>IP BLOCKED</code>。这时候我们只需点击下面的 <code>Replace Main IP</code>，进行更换 IP 的操作。<br> <img src="/2018/12/09/st-ssr-basic/si-ssr-basic-012.png" alt="抱歉,图片休息了"></li></ol></li></ul><h3 id="搬瓦工-IP-端口被封的原因及解决办法"><a href="#搬瓦工-IP-端口被封的原因及解决办法" class="headerlink" title="搬瓦工 IP&#x2F;端口被封的原因及解决办法"></a>搬瓦工 IP&#x2F;端口被封的原因及解决办法</h3><p>大部分原因都是因为我们用户在使用过程中不应该有的项目和用途导致的。再次提醒，我们使用任何 VPS、服务器都要正规使用。</p><ul><li>方法1：购买新服务器<ul><li>我们在选择搬瓦工 VPS 主机的时候，如果自己知道可能导致 IP 被封，建议还是选择月付。</li></ul></li><li>方法2：购买新的 IP<ul><li>可以重新购买一个新的 IP 地址替换已有老服务器中的自带 IP 地址(包括被封的 IP 地址)，目前是 <code>8.7$</code> 一个 IP 地址。</li><li>购买新 IP 地址：<a href="https://bwh8.net/ipchange.php">https://bwh8.net/ipchange.php</a></li></ul></li><li>方法3：免费更换 IP<ul><li>可以参考 <code>检查搬瓦工 IP/端口是否被封</code> 方法 2，现在是每 10 周免费更换一次。</li><li>如果符合要求(例如被封了)的就可以更换，不符合要求(例如正常的 IP)的会告知是什么问题。如果没有到时间更换，也会提示出来。</li></ul></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> 科学上网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可输入可选择可模糊查询的 select 下拉</title>
      <link href="/2018/12/02/te-select.html"/>
      <url>/2018/12/02/te-select.html</url>
      
        <content type="html"><![CDATA[<h1 id="可输入可选择可模糊查询的-select-下拉"><a href="#可输入可选择可模糊查询的-select-下拉" class="headerlink" title="可输入可选择可模糊查询的 select 下拉"></a>可输入可选择可模糊查询的 select 下拉</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#CSS%E4%BB%A3%E7%A0%81">CSS 代码</a></li><li><a href="#JS%E4%BB%A3%E7%A0%81">JS 代码</a></li><li><a href="#HTML%E4%BB%A3%E7%A0%81">HTML 代码</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>相比网上各种下拉插件，要么出现各种传值问题，要么样式跟现有的项目冲突，此方法没有选用 select 标签，返璞归真</li><li>啥也不说了，直接上代码。</li></ul><h2 id="CSS代码"><a href="#CSS代码" class="headerlink" title="CSS代码"></a>CSS代码</h2><pre><code class="hljs css">&lt;style&gt;<span class="hljs-selector-class">.selectDiv</span> &#123;<span class="hljs-attribute">display</span>:none;<span class="hljs-attribute">z-index</span>:<span class="hljs-number">9999</span>;<span class="hljs-attribute">position</span>:absolute;<span class="hljs-comment">/*不加的话可能会影响页面其他元素*/</span><span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#999</span>;<span class="hljs-attribute">width</span>:<span class="hljs-number">215px</span>;<span class="hljs-comment">/*调整下拉框的宽度*/</span><span class="hljs-attribute">height</span>:<span class="hljs-number">106px</span>;<span class="hljs-attribute">margin-left</span>:<span class="hljs-number">74px</span>;<span class="hljs-attribute">background</span>:white;<span class="hljs-attribute">border-radius</span>:<span class="hljs-number">4px</span>;<span class="hljs-comment">/*调整边框圆角*/</span><span class="hljs-attribute">overflow-y</span>:scroll;<span class="hljs-comment">/*添加下拉框滚动条*/</span><span class="hljs-attribute">overflow-x</span>:hidden;<span class="hljs-comment">/*防止ie上下拉框出现横向滚动条*/</span>&#125; <span class="hljs-selector-class">.selectSpan</span> &#123; <span class="hljs-attribute">width</span>:<span class="hljs-number">190px</span>;<span class="hljs-comment">/*调整下拉框每个元素的宽度*/</span> <span class="hljs-attribute">height</span>:<span class="hljs-number">18px</span>; <span class="hljs-attribute">padding-top</span>:<span class="hljs-number">3px</span>; <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#ffffff</span>; <span class="hljs-attribute">margin-left</span>:<span class="hljs-number">4px</span>; <span class="hljs-attribute">display</span>:block;<span class="hljs-comment">/*很重要，调整宽高度需要*/</span> <span class="hljs-attribute">word-wrap</span>:break-word;<span class="hljs-comment">/*自动换行*/</span> <span class="hljs-attribute">vertical-align</span>:middle;<span class="hljs-comment">/*垂直居中*/</span> &#125; <span class="hljs-selector-class">.selectSpan</span><span class="hljs-selector-pseudo">:hover</span> &#123; <span class="hljs-attribute">background</span>:<span class="hljs-number">#1f7ed0</span>; &#125;&lt;/style&gt;</code></pre><h2 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h2><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">TempArr</span> = [];<span class="hljs-keyword">var</span> selectDivHtml = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">// 当鼠标点击输入框时执行此方法</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">queryUnCreateAddress</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-title class_">TempArr</span> = [];<span class="hljs-keyword">var</span> showFlag = <span class="hljs-literal">true</span>;$(<span class="hljs-string">&quot;#selectDivShow&quot;</span>).<span class="hljs-title function_">html</span>(selectDivHtml);$.<span class="hljs-title function_">ajax</span>(&#123; <span class="hljs-comment">//此为向数据库查询json数据填充到下拉框里</span><span class="hljs-attr">type</span>:<span class="hljs-string">&quot;post&quot;</span>,<span class="hljs-attr">url</span>:path + <span class="hljs-string">&quot;/workplace/workplaceInformationMessage!queryUnCreateAddress.action&quot;</span>,<span class="hljs-attr">dataType</span>:<span class="hljs-string">&quot;json&quot;</span>,<span class="hljs-attr">async</span>:<span class="hljs-literal">false</span>,<span class="hljs-attr">success</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;<span class="hljs-title class_">TempArr</span> = data;    <span class="hljs-keyword">if</span>(<span class="hljs-literal">null</span> != data &amp;&amp; data.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>)&#123;    $(data).<span class="hljs-title function_">each</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">index,value</span>)&#123;    <span class="hljs-keyword">var</span> leng = <span class="hljs-title function_">checkLength</span>(value.<span class="hljs-property">workplaceAddress</span>); <span class="hljs-comment">//计算数据的长度，区分中英文</span><span class="hljs-keyword">var</span> height = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(leng/<span class="hljs-number">21</span>) * <span class="hljs-number">15</span>; <span class="hljs-comment">//设置下拉框每个选项的高度，</span><span class="hljs-keyword">if</span>(height == <span class="hljs-number">15</span>)&#123;height = <span class="hljs-number">18</span>;&#125;    selectDivHtml +=<span class="hljs-string">&quot;&lt;span class=&#x27;selectSpan&#x27; style=&#x27;height:&quot;</span>+height+<span class="hljs-string">&quot;px&#x27; data-code=&#x27;&quot;</span>+value.<span class="hljs-property">addressCode</span>+<span class="hljs-string">&quot;&#x27; data-address=&#x27;&quot;</span>+value.<span class="hljs-property">workplaceAddress</span>+<span class="hljs-string">&quot;&#x27; onclick=&#x27;selectedValueInput(this)&#x27;&gt;&quot;</span>+value.<span class="hljs-property">workplaceAddress</span>+<span class="hljs-string">&quot;&lt;/span&gt;&quot;</span>;    &#125;);    &#125;<span class="hljs-keyword">else</span>&#123;    showFlag = <span class="hljs-literal">false</span>;    &#125;&#125;,<span class="hljs-attr">error</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;系统错误&quot;</span>);&#125;&#125;);$(<span class="hljs-string">&quot;#selectDivShow&quot;</span>).<span class="hljs-title function_">append</span>(selectDivHtml);selectDivHtml = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">if</span>(showFlag)&#123;$(<span class="hljs-string">&quot;#selectDivShow&quot;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;style&quot;</span>,<span class="hljs-string">&quot;display:block&quot;</span>);&#125;&#125;<span class="hljs-comment">// 点击下拉框每个选项时触发此方法</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">selectedValueInput</span>(<span class="hljs-params">obj</span>)&#123;<span class="hljs-keyword">var</span> code = $(obj).<span class="hljs-title function_">data</span>(<span class="hljs-string">&quot;code&quot;</span>);<span class="hljs-keyword">var</span> address = $(obj).<span class="hljs-title function_">data</span>(<span class="hljs-string">&quot;address&quot;</span>);$(<span class="hljs-string">&quot;#workplaceAddressNum&quot;</span>).<span class="hljs-title function_">val</span>(code); <span class="hljs-comment">//隐藏域，按需添加，方便传值到后台</span>$(<span class="hljs-string">&quot;#contractAddress&quot;</span>).<span class="hljs-title function_">val</span>(address);$(<span class="hljs-string">&quot;#selectDivShow&quot;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;style&quot;</span>,<span class="hljs-string">&quot;display:none&quot;</span>);&#125;<span class="hljs-comment">// 在输入框输入内容时触发此方法，方便实时监听匹配</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">setinput</span>(<span class="hljs-params">this_</span>)&#123;<span class="hljs-keyword">var</span> select = $(<span class="hljs-string">&quot;#selectDivShow&quot;</span>);select.<span class="hljs-title function_">html</span>(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-title class_">TempArr</span>.<span class="hljs-property">length</span>;i++)&#123;<span class="hljs-keyword">if</span>(<span class="hljs-title class_">TempArr</span>[i].<span class="hljs-property">workplaceAddress</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>,$(this_).<span class="hljs-title function_">val</span>().<span class="hljs-property">length</span>).<span class="hljs-title function_">indexOf</span>($(this_).<span class="hljs-title function_">val</span>()) == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">var</span> leng = <span class="hljs-title function_">checkLength</span>(<span class="hljs-title class_">TempArr</span>[i].<span class="hljs-property">workplaceAddress</span>);<span class="hljs-keyword">var</span> height = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(leng/<span class="hljs-number">21</span>) * <span class="hljs-number">15</span>;<span class="hljs-keyword">if</span>(height == <span class="hljs-number">15</span>)&#123;height = <span class="hljs-number">18</span>;&#125;selectDivHtml +=<span class="hljs-string">&quot;&lt;span class=&#x27;selectSpan&#x27; style=&#x27;height:&quot;</span>+height+<span class="hljs-string">&quot;px&#x27; data-code=&#x27;&quot;</span>+<span class="hljs-title class_">TempArr</span>[i].<span class="hljs-property">addressCode</span>+<span class="hljs-string">&quot;&#x27; data-address=&#x27;&quot;</span>+<span class="hljs-title class_">TempArr</span>[i].<span class="hljs-property">workplaceAddress</span>+<span class="hljs-string">&quot;&#x27; onclick=&#x27;selectedValueInput(this)&#x27;&gt;&quot;</span>+<span class="hljs-title class_">TempArr</span>[i].<span class="hljs-property">workplaceAddress</span>+<span class="hljs-string">&quot;&lt;/span&gt;&quot;</span>;&#125;&#125;select.<span class="hljs-title function_">append</span>(selectDivHtml);selectDivHtml = <span class="hljs-string">&quot;&quot;</span>;&#125;<span class="hljs-comment">// 离开输入框时触发此方法</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">addressBlur</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">var</span> selectObj = $(<span class="hljs-string">&quot;#selectDivShow&quot;</span>).<span class="hljs-title function_">find</span>(<span class="hljs-string">&quot;span:hover&quot;</span>);<span class="hljs-keyword">if</span>(<span class="hljs-literal">null</span> != selectObj &amp;&amp; selectObj.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//针对鼠标点击下拉框选项触发此方法时的特殊处理</span><span class="hljs-title function_">selectedValueInput</span>(selectObj);<span class="hljs-keyword">return</span>;&#125;$(<span class="hljs-string">&quot;#selectDivShow&quot;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;style&quot;</span>,<span class="hljs-string">&quot;display:none&quot;</span>);&#125;<span class="hljs-comment">// 计算输入值的长度</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkLength</span>(<span class="hljs-params">str</span>)&#123;<span class="hljs-keyword">var</span> sLen = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i&lt;str.<span class="hljs-property">length</span>;i++) &#123;<span class="hljs-keyword">if</span>(str.<span class="hljs-title function_">charAt</span>(i) &lt;= <span class="hljs-string">&#x27;\255&#x27;</span>) &#123; <span class="hljs-comment">// 单字节字符</span>sLen++;&#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 汉字或其他2字节字符</span>sLen = sLen + <span class="hljs-number">3</span>;&#125;&#125;<span class="hljs-keyword">return</span> sLen;&#125;</code></pre><h2 id="HTML代码"><a href="#HTML代码" class="headerlink" title="HTML代码"></a>HTML代码</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;contractAddress&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;workplaceInformation.contractAddress&quot;</span> </span><span class="hljs-tag"><span class="hljs-attr">onblur</span>=<span class="hljs-string">&quot;addressBlur()&quot;</span> <span class="hljs-attr">oninput</span>=<span class="hljs-string">&quot;setinput(this)&quot;</span> <span class="hljs-attr">onfocus</span>=<span class="hljs-string">&quot;queryUnCreateAddress()&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;workplaceInformation.contractAddress &#125;&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectDivShow&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;selectDiv&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li><p>20190723更新 仿携程等网站鼠标放入<code>目的地</code>输入框时的样式</p><pre><code class="hljs css">&lt;style&gt;<span class="hljs-selector-class">.labels</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">70px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">25px</span>;    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">25px</span>;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span> <span class="hljs-number">5px</span> <span class="hljs-number">0</span> <span class="hljs-number">5px</span>;    <span class="hljs-attribute">float</span>: left;    <span class="hljs-attribute">text-align</span>: center;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">15px</span>;    <span class="hljs-attribute">cursor</span>: pointer;&#125;&lt;/style&gt;</code></pre></li><li><p>未完待续…</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 经典示例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 札记</title>
      <link href="/2018/12/01/af-hexo.html"/>
      <url>/2018/12/01/af-hexo.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-札记"><a href="#Hexo-札记" class="headerlink" title="Hexo 札记"></a>Hexo 札记</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">准备工作</a></li><li><a href="#%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA">快速入门</a></li><li><a href="#%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8">进阶使用</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>中文官网<ul><li><a href="http://hexo.io/zh-cn/">http://hexo.io/zh-cn/</a></li></ul></li><li>作者 Tommy Chen<ul><li><a href="https://zespia.tw/">https://zespia.tw/</a></li></ul></li><li>个人理解<ul><li>Hexo 是一个基于 Node.js 快速、简洁且高效的博客框架，可以将 Markdown 文件快速的生成静态网页，托管在 GitHub Pages 上。</li></ul></li><li>官网释义<blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote></li><li>特点  <pre><code class="hljs plaintext">1.超快速度    Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。2.支持 Markdown    Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。3.一键部署    只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。4.丰富的插件    Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。</code></pre></li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>Git 安装  <pre><code class="hljs plaintext">Tujide.lv@tujide MINGW64 ~$ git --versiongit version 2.15.1.windows.2</code></pre></li><li>Node.js 安装  <pre><code class="hljs plaintext">Tujide.lv@tujide MINGW64 ~$ npm -v6.4.1</code></pre></li><li>设置 Node.js 源为淘宝 NPM 镜像<ul><li>Node.js 官方源默认是：<a href="https://r.cnpmjs.org/">https://r.cnpmjs.org/</a>，但是由于在国外，说不定你使用的时候就抽风无法下载任何软件，所以我们决定暂时使用淘宝提供的源，淘宝源官网：<a href="http://npm.taobao.org/">http://npm.taobao.org/</a>。</li><li>安装时间不一定很快，耐心等待一会。  <pre><code class="hljs plaintext">Tujide.lv@tujide MINGW64 ~$ npm install -g cnpm --registry=https://registry.npm.taobao.orgnpm WARN deprecated socks@1.1.10: If using 2.x branch, please upgrade to at least 2.1.6 to avoid a serious bug with socket data flow and an import issue introduced in 2.1.0E:\Ebook\JavaSE\develop\nodejs\node_global\cnpm -&gt; E:\Ebook\JavaSE\develop\nodejs\node_global\node_modules\cnpm\bin\cnpm+cnpm@6.0.0added 633 packages from 844 contributors in 120.981sTujide.lv@tujide MINGW64 ~$ npm list -g --depth 0E:\Ebook\JavaSE\develop\nodejs\node_global`-- cnpm@6.0.0</code></pre></li></ul></li></ul><h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h2><ul><li><p>安装 Hexo 框架</p><ul><li>因为国内的网络问题，有时候安装异常慢花了大半个小时都没效果，那就 <code>Ctrl + C</code> 停掉这次命令，执行 <code>npm uninstall -g hexo-cli</code>，然后重新再执行一次。</li><li>安装时间不一定很快，耐心等待一会。  <pre><code class="hljs plaintext">Tujide.lv@tujide MINGW64 ~$ cnpm install -g hexo-cliDownloading hexo-cli to E:\Ebook\JavaSE\develop\nodejs\node_global\node_modules\hexo-cli_tmpCopying E:\Ebook\JavaSE\develop\nodejs\node_global\node_modules\hexo-cli_tmp\_hexo-cli@1.1.0@hexo-cli to E:\Ebook\JavaSE\develop\nodejs\node_global\node_modules\hexo-cliInstalling hexo-cli&#x27;s dependencies to E:\Ebook\JavaSE\develop\nodejs\node_global\node_modules\hexo-cli/node_modules[1/11] abbrev@^1.0.7 installed at node_modules\_abbrev@1.1.1@abbrev[2/11] object-assign@^4.1.0 installed at node_modules\_object-assign@4.1.1@object-assign[3/11] command-exists@^1.2.0 installed at node_modules\_command-exists@1.2.8@command-exists[4/11] minimist@^1.2.0 installed at node_modules\_minimist@1.2.0@minimist[5/11] tildify@^1.2.0 installed at node_modules\_tildify@1.2.0@tildify[6/11] chalk@^1.1.3 installed at node_modules\_chalk@1.1.3@chalk[7/11] bluebird@^3.4.0 installed at node_modules\_bluebird@3.5.3@bluebird[8/11] resolve@^1.5.0 installed at node_modules\_resolve@1.8.1@resolve[9/11] hexo-util@^0.6.0 installed at node_modules\_hexo-util@0.6.3@hexo-util[10/11] hexo-log@^0.2.0 installed at node_modules\_hexo-log@0.2.0@hexo-logfsevents@1.2.4 download from binary mirror: &#123;&quot;module_name&quot;:&quot;fse&quot;,&quot;module_path&quot;:&quot;./lib/binding/&#123;configuration&#125;/&#123;node_abi&#125;-&#123;platform&#125;-&#123;arch&#125;/&quot;,&quot;remote_path&quot;:&quot;./v&#123;version&#125;/&quot;,&quot;package_name&quot;:&quot;&#123;module_name&#125;-v&#123;version&#125;-&#123;node_abi&#125;-&#123;platform&#125;-&#123;arch&#125;.tar.gz&quot;,&quot;host&quot;:&quot;https://cdn.npm.taobao.org/dist/fsevents&quot;&#125;platform unsupported hexo-fs@0.2.3 › chokidar@1.7.0 › fsevents@^1.0.0 Package require os(darwin) not compatible with your platform(win32)[fsevents@^1.0.0] optional install error: Package require os(darwin) not compatible with your platform(win32)[11/11] hexo-fs@^0.2.0 installed at node_modules\_hexo-fs@0.2.3@hexo-fsRecently updated (since 2018-11-18): 2 packages (detail see file E:\Ebook\JavaSE\develop\nodejs\node_global\node_modules\hexo-cli\node_modules\.recently_updates.txt)  2018-11-22    → hexo-util@0.6.3 › cross-spawn@4.0.2 › lru-cache@4.1.4 › yallist@^3.0.2(3.0.3) (07:22:36)  2018-11-21    → hexo-util@0.6.3 › cross-spawn@4.0.2 › lru-cache@^4.0.1(4.1.4) (08:14:09)All packages installed (175 packages installed from npm registry, used 7s(network 6s), speed 498.55kB/s, json 151(218.72kB), tarball 2.93MB)[hexo-cli@1.1.0] link E:\Ebook\JavaSE\develop\nodejs\node_global\hexo@ -&gt; E:\Ebook\JavaSE\develop\nodejs\node_global\node_modules\hexo-cli\bin\hexo</code></pre></li></ul></li><li><p>创建 Hexo 项目<br>  <img src="/2018/12/01/af-hexo/af-hexo-001.png" alt="抱歉,图片休息了" title="hexo 项目目录结构"></p><ul><li>现在初始化后不需要 <code>npm install</code> 了，它会默认执行该命令把相关依赖包下载到 node_modules 目录中，同时会自动生成 package-lock.json 文件用以纪录当前实际安装的各个插件包的具体来源和版本号。</li><li>安装时间不一定很快，耐心等待一会。  <pre><code class="hljs plaintext">Tujide.lv@tujide MINGW64 /e/Ebook/JavaSE/workspace_idea$ hexo init hexo-blogINFO  Cloning hexo-starter to E:\Ebook\JavaSE\workspace_idea\hexo-blogCloning into &#x27;E:\Ebook\JavaSE\workspace_idea\hexo-blog&#x27;...remote: Enumerating objects: 68, done.remote: Total 68 (delta 0), reused 0 (delta 0), pack-reused 68Unpacking objects: 100% (68/68), done.Submodule &#x27;themes/landscape&#x27; (https://github.com/hexojs/hexo-theme-landscape.git) registered for path &#x27;themes/landscape&#x27;Cloning into &#x27;E:/Ebook/JavaSE/workspace_idea/hexo-blog/themes/landscape&#x27;...remote: Enumerating objects: 21, done.remote: Counting objects: 100% (21/21), done.remote: Compressing objects: 100% (21/21), done.remote: Total 867 (delta 8), reused 0 (delta 0), pack-reused 846Receiving objects: 100% (867/867), 2.55 MiB | 1.31 MiB/s, done.Resolving deltas: 100% (457/457), done.Submodule path &#x27;themes/landscape&#x27;: checked out &#x27;73a23c51f8487cfcd7c6deec96ccc7543960d350&#x27;INFO  Install dependenciesnpm WARN deprecated titlecase@1.1.2: no longer maintainednpm WARN deprecated postinstall-build@5.0.3: postinstall-build&#x27;s behavior is now built into npm! You should migrate off of postinstall-build and use the new `prepare` lifecycle script with npm 5.0.0 or greater.&gt; nunjucks@3.1.4 postinstall E:\Ebook\JavaSE\workspace_idea\hexo-blog\node_modules\nunjucks&gt; node postinstall-build.js srcnpm notice created a lockfile as package-lock.json. You should commit this file.npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)added 423 packages from 501 contributors and audited 4700 packages in 109.987sfound 0 vulnerabilitiesINFO  Start blogging with Hexo!</code></pre></li></ul></li><li><p>启动 hexo 本地服务</p><ul><li>本地用浏览器访问：<a href="http://localhost:4000/">http://localhost:4000/</a>，查看默认效果。</li><li>如果要停止 hexo 服务：在 Git Bash 下按 <code>Ctrl + C</code> 即可。  <pre><code class="hljs plaintext">Tujide.lv@tujide MINGW64 /e/Ebook/JavaSE/workspace_idea/hexo-blog$ hexo serverINFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre></li></ul></li><li><p>更换其他主题</p><ul><li><p>由于默认主题太大众了，可以去这里找主题</p><ul><li>hexo-theme：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></li><li>hexo-github-theme-list：<a href="https://github.com/hexojs/hexo/wiki/Themes">https://github.com/hexojs/hexo/wiki/Themes</a></li><li>有那些好看的 hexo 主题？：<a href="http://www.zhihu.com/question/24422335">http://www.zhihu.com/question/24422335</a></li></ul></li><li><p>这里列出比较中意的 3 款(以 3-hexo 为例)</p><ul><li><a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a></li><li><a href="https://github.com/MOxFIVE/hexo-theme-yelee">https://github.com/MOxFIVE/hexo-theme-yelee</a></li><li><a href="https://github.com/wizardforcel/hexo-theme-cyanstyle">https://github.com/wizardforcel/hexo-theme-cyanstyle</a></li><li><a href="https://github.com/yelog/hexo-theme-3-hexo">https://github.com/yelog/hexo-theme-3-hexo</a></li></ul></li><li><p>下载主题到 themes 文件夹</p><ul><li>如果以后你不自己修改这个主题的话，可以考虑 <code>git pull</code> 经常更新下作者的更新内容。</li><li>下载时间不一定很快，耐心等待一会。  <pre><code class="hljs plaintext">Tujide.lv@tujide MINGW64 /e/Ebook/JavaSE/workspace_idea/hexo-blog$ git clone https://github.com/tujidelv/hexo-theme-3-hexo.git themes/3-hexoCloning into &#x27;themes/3-hexo&#x27;...remote: Enumerating objects: 12, done.remote: Counting objects: 100% (12/12), done.remote: Compressing objects: 100% (9/9), done.remote: Total 1854 (delta 3), reused 9 (delta 3), pack-reused 1842Receiving objects: 100% (1854/1854), 1.10 MiB | 937.00 KiB/s, done.Resolving deltas: 100% (1045/1045), done.Tujide.lv@tujide MINGW64 /e/Ebook/JavaSE/workspace_idea/hexo-blog/themes/3-hexo (master)$ git pull origin masterFrom https://github.com/tujidelv/hexo-theme-3-hexo * branch            master     -&gt; FETCH_HEADAlready up to date.</code></pre></li></ul></li><li><p>修改 hexo 站点配置文件 _config.yml 使主题生效</p><p>  <img src="/2018/12/01/af-hexo/af-hexo-002.png" alt="抱歉,图片休息了" title="hexo 主题修改"></p></li><li><p>重新渲染主题静态内容并本地预览</p>  <pre><code class="hljs plaintext">Tujide.lv@tujide MINGW64 /e/Ebook/JavaSE/workspace_idea/hexo-blog$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo sINFO  Deleted database.INFO  Deleted public folder.INFO  Start processingINFO  Files loaded in 311 msINFO  Generated: img/brown-papersq.pngINFO  Generated: img/avatar.jpgINFO  Generated: img/weixin.jpgINFO  Generated: img/school-book.pngINFO  Generated: index.htmlINFO  Generated: archives/index.htmlINFO  Generated: css/fonts/icomoon.eotINFO  Generated: img/alipay.jpgINFO  Generated: js/search.jsINFO  Generated: css/hl_theme/atom-dark.cssINFO  Generated: css/mobile.cssINFO  Generated: css/hl_theme/atom-light.cssINFO  Generated: css/hl_theme/brown-paper.cssINFO  Generated: css/hl_theme/darcula.cssINFO  Generated: css/hl_theme/github-gist.cssINFO  Generated: css/hl_theme/github.cssINFO  Generated: css/hl_theme/gruvbox-light.cssINFO  Generated: css/hl_theme/gruvbox-dark.cssINFO  Generated: css/hl_theme/kimbie-dark.cssINFO  Generated: css/hl_theme/kimbie-light.cssINFO  Generated: css/hl_theme/railscasts.cssINFO  Generated: css/hl_theme/rainbow.cssINFO  Generated: archives/2018/index.htmlINFO  Generated: css/hl_theme/school-book.cssINFO  Generated: css/hl_theme/sublime.cssINFO  Generated: css/hl_theme/sunburst.cssINFO  Generated: css/hl_theme/zenbum.cssINFO  Generated: css/fonts/icomoon.ttfINFO  Generated: archives/2018/11/index.htmlINFO  Generated: js/script.jsINFO  Generated: css/fonts/icomoon.woffINFO  Generated: css/fonts/icomoon.svgINFO  Generated: css/style.cssINFO  Generated: css/fonts/selection.jsonINFO  Generated: css/gitalk.cssINFO  Generated: js/jquery.autocomplete.min.jsINFO  Generated: 2018/11/28/hello-world/index.htmlINFO  Generated: js/gitalk.jsINFO  38 files generated in 775 msINFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre></li></ul></li><li><p>创建 Github pages 并 SSH 授权</p><ul><li>创建好这个特殊仓库之后，在本地生成 SSH 秘钥并添加到 GitHub上，方便电脑上的 git 将内容到 Github 上。</li></ul><p>  <img src="/2018/12/01/af-hexo/af-hexo-003.png" alt="抱歉,图片休息了" title="hexo 仓库"></p></li><li><p>把本地的博客内容同步到 Github 上</p><ul><li>安装与 hexo 相关的 git 部署插件  <pre><code class="hljs plaintext">Tujide.lv@tujide MINGW64 /e/Ebook/JavaSE/workspace_idea/hexo-blog$ cnpm install hexo-deployer-git --saveplatform unsupported hexo-deployer-git@0.3.1 › hexo-fs@0.2.3 › chokidar@1.7.0 › fsevents@^1.0.0 Package require os(darwin) not compatible with your platform(win32)[fsevents@^1.0.0] optional install error: Package require os(darwin) not compatible with your platform(win32)√ Installed 1 packages√ Run 0 scriptsdeprecate hexo-deployer-git@0.3.1 › swig@^1.4.2 This package is no longer maintainedRecently updated (since 2018-11-21): 1 packages (detail see file E:\Ebook\JavaSE\workspace_idea\hexo-blog\node_modules\.recently_updates.txt)√ All packages installed (183 packages installed from npm registry, used 18s(network 18s), speed 17.06kB/s, json 157(305.82kB), tarball 0B)</code></pre></li><li>修改 hexo 全局配置文件 _config.yml  <pre><code class="hljs plaintext"># Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site，网站，这一块区域主要是设置博客的主要说明，需要注意的是：每个冒号后面都是有一个空格，然后再书写自己的内容title: Tujidelv Code # 网站标题subtitle: 好记性不如烂笔头 # 网站副标题description: Tujidelv的技术小窝 # 网站描述，主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词keywords:author: Tujide.lv # 您的名字，用于主题显示文章的作者language: zh-CN # 网站使用的语言，也可以用zh-Hanstimezone:# URL，网址，这一块区域一般可以设置的是 url 这个参数，比如我要设置绑定域名的，这里就需要填写我的域名信息## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;## 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。url: https://www.lvzhiqiang.top # 网址root: / # 网站根目录permalink: :year/:month/:day/:title/ # 文章的永久链接格式permalink_defaults:# Directory，目录，这一块一般不需要修改source_dir: source # 资源文件夹，这个文件夹用来存放内容。public_dir: public # 公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags # 标签文件夹archive_dir: archives # 归档文件夹category_dir: categories # 分类文件夹code_dir: downloads/code # Include code 文件夹i18n_dir: :lang # 国际化（i18n）文件夹skip_render: # 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。- README.md# Writing，文章，这一块一般不需要修改new_post_name: :title.md # Hexo 默认以标题做为文件名称，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章default_layout: post # 预设布局，Hexo 有三种默认布局：post、page 和 draft，分别对应不同的路径：source/_posts、source和source/_draftstitlecase: false # 把标题转换为 title caseexternal_link: true # 在新标签中打开链接filename_case: 0 # 把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false # 显示草稿，草稿默认不会显示在页面中post_asset_folder: false # 启动 Asset 文件夹relative_link: false # 把链接改为与根目录的相对位址 future: true # 显示未来的文章highlight: # 代码块的设置  enable: true  line_number: true  auto_detect: false  tab_replace:  # Home page setting# path: Root path for your blogs index page. (default = &#x27;&#x27;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator:  path: &#x27;&#x27;  per_page: 10  order_by: -date  # Category &amp; Tag，分类 &amp; 标签，这一块一般不需要修改default_category: uncategorized # 默认分类category_map:tag_map:# Date / Time format，日期 / 时间格式，这一块一般不需要修改## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD # 日期格式time_format: HH:mm:ss # 时间格式# Pagination，分页，这一块一般不需要修改## Set per_page to 0 to disable paginationper_page: 10 # 每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page # 分页目录# Extensions，扩展## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: 3-hexo # 当前主题名称。值为false时禁用主题# Deployment，部署## 这里是重点，这里是修改发布地址，因为我们前面已经将本地 SSH 密钥信息添加到 Github 设置里面了，所以只要我们电脑里面持有那两个密钥文件就可以无需密码地跟 Github 做同步。## 需要注意的是这里的 repo 采用的是 ssh 的地址，而不是 https 的。分支我们默认采用 master 分支。## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: git@github.com:tujidelv/tujidelv.github.io.git  branch: master</code></pre></li><li>执行如下命令 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>  <pre><code class="hljs plaintext">hexo clean          // 清除掉已经生成的旧文件hexo generate/g     // 重新生成一次静态文件hexo deploy/d       // 使用部署命令部署到 Github 上</code></pre>  <img src="/2018/12/01/af-hexo/af-hexo-004.png" alt="抱歉,图片休息了" title="hexo 部署到GitHub"></li></ul></li><li><p>绑定域名</p><ul><li>在 source 目录下新建 <code>CNAME</code> 文件（文件名叫 CNAME，没有文件后缀的）<ul><li>以后一些需要放在根目录的资源文件都可以放这里。</li><li><em><strong><code>CNAME</code> 文件上的内容写你要绑定的域名全称。</strong></em></li></ul></li><li>到各自己域名控制台上设置域名解析(以阿里云为例)  <pre><code class="hljs plaintext">记录类型：CNAME主机记录：www解析线路：默认记录值：tujidelv.github.io.TTL：默认</code></pre></li></ul></li><li><p>整合 IntelliJ IDEA 提高效率</p><ul><li>为了提交写作效率，建议使用 IDEA 作为 Markdown 编辑工具。<ul><li>IDEA 有各种各样的快捷键支持你的操作</li><li>IDEA 可以快速地全文检索项目所有的文件</li><li>对 JavaScript、CSS、HTML 等常见语言的良好支持，方便修改主题</li></ul></li><li>打开 hexo 项目，将 public 目录设置成 Excluded，这样每次 hexo 新的静态博客后 IDEA 不需要每次都去重建索引。</li></ul></li></ul><h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><h3 id="编写脚本方便快速部署和本地预览"><a href="#编写脚本方便快速部署和本地预览" class="headerlink" title="编写脚本方便快速部署和本地预览"></a><strong>编写脚本方便快速部署和本地预览</strong></h3><ul><li>在 hexo 根目录下新建 hs.sh 和 hd.sh 文件,分别加入如下内容：  <pre><code class="hljs plaintext">#!/bin/bashhexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></pre>  <pre><code class="hljs plaintext">#!/bin/bashhexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre></li><li>在 Git Bash 中分别执行 <code>./hs.sh</code> 和<code>./hd.sh</code> 来预览和部署。</li></ul><h3 id="创建-关于我-页面"><a href="#创建-关于我-页面" class="headerlink" title="创建[关于我]页面"></a><strong>创建[关于我]页面</strong></h3><ul><li>可以编辑 index.md 文件补充需要显示的内容。<pre><code class="hljs plaintext">Tujide.lv@tujide MINGW64 /e/Ebook/JavaSE/workspace_idea/hexo-blog$ hexo new page aboutINFO  Created: E:\Ebook\JavaSE\workspace_idea\hexo-blog\source\about\index.md</code></pre></li></ul><h3 id="创建-404-页面"><a href="#创建-404-页面" class="headerlink" title="创建[404]页面"></a><strong>创建[404]页面</strong></h3><ul><li>对于 github page 来说，只要在根目录有 404.html，当页面找不到时，就会被转发到&#x2F;404.html 页面，所以我们只要更改这个页面，就可以实现自定义 404 页面了。</li><li>但是我们通常会需要与本主题相符的 404 页面，那我们需要以下操作<ol><li>进入 Hexo 根目录，输入 <code>hexo new page 404</code> ;</li><li>打开刚新建的页面文件，默认在 Hexo 文件夹根目录下 <code>/source/404/index.md</code>;</li><li>在顶部插入一行，写上 <code>permalink: /404</code>，这表示指定该页固定链接为 <code>http://&quot;主页&quot;/404.html</code>。</li></ol></li></ul><h3 id="创建-分类-标签-页面"><a href="#创建-分类-标签-页面" class="headerlink" title="创建[分类&amp;标签]页面"></a><strong>创建[分类&amp;标签]页面</strong></h3><ol><li>在 source 目录下新建一个 tags 文件夹 <pre><code class="hljs plaintext">$ hexo new page tags</code></pre></li><li>编辑 index.md 文件，添加 <code>layout</code> 选项，后面的值对应的是主题文件夹下 <code>layout</code> 目录下第一级的布局文件，例如layout&#x2F;tags.ejs <pre><code class="hljs plaintext">---title: tagsdate: 2018-11-28 20:23:17type: tagslayout: &quot;tags&quot;---</code></pre></li><li>编辑主题配置文件，各个主题的显示名称可能不同 <pre><code class="hljs plaintext">menu:  Home: /  Archives: /archives  tags: /tags</code></pre></li><li>最后去看下 hexo 站点配置文件对应的选项名称是否对应 <pre><code class="hljs plaintext"># Directorytag_dir: tags</code></pre>Tips：最重要的是看一下主题文件里有没有标签页或者分类页的布局文件，一般来说都是有的，只是命名和存放的位置可能不同，所以大家要根据实际情况来修改。categories 同理。</li></ol><h3 id="图片显示"><a href="#图片显示" class="headerlink" title="图片显示"></a><strong>图片显示</strong></h3><ul><li>一般分为外链和本地图片，这里介绍本地图片显示的 2 种方法</li><li>绝对路径，可直接在 source 目录下新建 images 文件夹用于存放图片，在 md 文件中如下引用  <pre><code class="hljs plaintext">![图片不存在时的提示文字](/images/图片.jpg &quot;鼠标箭头放到图片上的提示文字&quot;)</code></pre></li><li>相对路径，需先将站点配置文件中的 post_asset_folder 设为 true，然后安装 hexo-asset-image 插件  <pre><code class="hljs plaintext"># Writingpost_asset_folder: true # 启动 Asset 文件夹</code></pre>  <pre><code class="hljs plaintext">Tujide.lv@tujide MINGW64 /e/Ebook/JavaSE/workspace_idea/hexo-blog$ cnpm i hexo-asset-image --save√ Installed 1 packages√ Run 0 scripts√ All packages installed (19 packages installed from npm registry, used 2s(network 2s), speed 153.72kB/s, json 18(31.65kB), tarball 315.44kB)</code></pre>  <pre><code class="hljs plaintext">![图片不存在时的提示文字](MD文件名称/图片.jpg &quot;鼠标箭头放到图片上的提示文字&quot;)</code></pre>  Tips：此方法在运行 hexo n “xxxx” 来生成 md 文件时，同时会在&#x2F;source&#x2F;_posts 文件夹下生成一个与 md 文件同名的文件夹。</li></ul><h3 id="添加-rss-为-blog-提供订阅功能"><a href="#添加-rss-为-blog-提供订阅功能" class="headerlink" title="添加 rss 为 blog 提供订阅功能"></a><strong>添加 rss 为 blog 提供订阅功能</strong></h3><ol><li>安装相关插件 <pre><code class="hljs plaintext">$ cnpm install hexo-generator-feed --save</code></pre></li><li>配置 Hexo 站点配置文件_config.yml(以 3-hexo 为例) <pre><code class="hljs plaintext"># Extensions## Plugins: https://hexo.io/plugins/plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20</code></pre></li><li>验证配置是否成功<ul><li>执行 hexo g，查看一下 public 目录下，如果有 atom.xml 文件，则表明配置成功。</li></ul></li><li>修改 Hexo 主题配置文件_config.yml(以 3-hexo 为例) <pre><code class="hljs plaintext">link:  items:    rss: /atom.xml</code></pre></li></ol><h3 id="添加-sitemap-让搜索引擎收录"><a href="#添加-sitemap-让搜索引擎收录" class="headerlink" title="添加 sitemap 让搜索引擎收录"></a><strong>添加 sitemap 让搜索引擎收录</strong></h3><ol><li>先确认博客是否被收录<ul><li>在百度或者谷歌上面输入 <code>site:你的域名</code> 来判断，如果能搜索到就说明被收录，否则就没有。</li></ul></li><li>创建站点地图文件<ul><li>您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知 Google 和其他搜索引擎，搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。</li></ul><ol><li>安装百度和 google 插件 <pre><code class="hljs plaintext">cnpm install hexo-generator-sitemap --savecnpm install hexo-generator-baidu-sitemap --save</code></pre></li><li>配置 Hexo 站点配置文件_config.yml(以 3-hexo 为例) <pre><code class="hljs plaintext">plugin:- hexo-generator-sitemap- hexo-generator-baidu-sitemap</code></pre></li><li>验证配置是否成功<ul><li>执行 hexo g，查看一下 public 目录下，如果有 sitemap.xml 文件，则表明配置成功。</li></ul></li></ol></li><li>让百度收录我们的博客<ul><li>可以去 <a href="https://ziyuan.baidu.com/dashboard/index">百度站长平台</a> 进行网站验证和链接提交。</li><li>由于百度不会抓取 GitHub Pages 上的站点，这里不进行操作。</li></ul></li><li>让谷歌收录我们的博客<ul><li>可以去 <a href="https://www.google.com/webmasters/tools">Google 站长工具</a> 进行站点验证和添加站点地图。</li></ul></li><li>添加 rebots.txt 文件<ul><li>…</li></ul></li></ol><h3 id="文章排序及置顶"><a href="#文章排序及置顶" class="headerlink" title="文章排序及置顶"></a><strong>文章排序及置顶</strong></h3><ul><li>文章（site.posts）排序默认按照 .md 文件的创建时间排序，而没有按照文章中的 date 排序。这容易导致问题，比如文件丢失通过 Git 还原后创建时间都是一样的。</li><li>设置排序<ul><li><p>方法1：</p><blockquote><p>**<a href="http://s.amlove.cn/">@牵猪的松鼠</a>根据这篇文章写了一个npm插件 <a href="https://www.npmjs.com/package/hexo-generator-topindex">hexo-generator-topindex</a><br>  安装插件命令： <code>npm install hexo-generator-topindex --save</code></p></blockquote></li><li><p>方法2：直接修改 node_modules&#x2F;hexo-generator-index&#x2F;lib&#x2F;generator.js</p>  <pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<span class="hljs-keyword">var</span> pagination = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;hexo-pagination&#x27;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">locals</span>)&#123;  <span class="hljs-keyword">var</span> config = <span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>;  <span class="hljs-keyword">var</span> posts = locals.<span class="hljs-property">posts</span>;    posts.<span class="hljs-property">data</span> = posts.<span class="hljs-property">data</span>.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123;        <span class="hljs-keyword">if</span>(a.<span class="hljs-property">top</span> &amp;&amp; b.<span class="hljs-property">top</span>) &#123; <span class="hljs-comment">// 两篇文章top都有定义</span>            <span class="hljs-keyword">if</span>(a.<span class="hljs-property">top</span> == b.<span class="hljs-property">top</span>) <span class="hljs-keyword">return</span> b.<span class="hljs-property">date</span> - a.<span class="hljs-property">date</span>; <span class="hljs-comment">// 若top值一样则按照文章日期降序排</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> b.<span class="hljs-property">top</span> - a.<span class="hljs-property">top</span>; <span class="hljs-comment">// 否则按照top值降序排</span>        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.<span class="hljs-property">top</span> &amp;&amp; !b.<span class="hljs-property">top</span>) &#123; <span class="hljs-comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!a.<span class="hljs-property">top</span> &amp;&amp; b.<span class="hljs-property">top</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> b.<span class="hljs-property">date</span> - a.<span class="hljs-property">date</span>; <span class="hljs-comment">// 都没定义按照文章日期降序排</span>    &#125;);  <span class="hljs-keyword">var</span> paginationDir = config.<span class="hljs-property">pagination_dir</span> || <span class="hljs-string">&#x27;page&#x27;</span>;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">pagination</span>(<span class="hljs-string">&#x27;&#x27;</span>, posts, &#123;    <span class="hljs-attr">perPage</span>: config.<span class="hljs-property">index_generator</span>.<span class="hljs-property">per_page</span>,    <span class="hljs-attr">layout</span>: [<span class="hljs-string">&#x27;index&#x27;</span>, <span class="hljs-string">&#x27;archive&#x27;</span>],    <span class="hljs-attr">format</span>: paginationDir + <span class="hljs-string">&#x27;/%d/&#x27;</span>,    <span class="hljs-attr">data</span>: &#123;      <span class="hljs-attr">__index</span>: <span class="hljs-literal">true</span>    &#125;  &#125;);&#125;;</code></pre></li></ul></li><li>设置置顶<ul><li>给需要置顶的文章加入top参数，如下  <pre><code class="hljs plaintext">---title: Hexo 札记date: 2018-12-01 18:25:23top: 1categories:- 应用框架tags:- hexo- nodejs---</code></pre></li><li>如果存在多个置顶文章，top 后的参数越大，越靠前。</li></ul></li></ul><h3 id="使用-gitment-评论系统"><a href="#使用-gitment-评论系统" class="headerlink" title="使用 gitment 评论系统"></a><strong>使用 gitment 评论系统</strong></h3><ul><li><p>简介</p><blockquote><p><a href="https://github.com/imsun/gitment">Gitment 项目地址</a></p></blockquote><blockquote><p>Gitment 是基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown &#x2F; GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。</p></blockquote></li><li><p>注意点</p><ul><li>gitment 有两个配置文件(一个 css 文件和一个 js 文件)，gitment 的开发者用远程连接的方式将两个文件引入 hexo 中，其中的 js 文件中需要访问作者自己搭建的服务器，但是现在作者的服务器不好使了，会导致全都配置好了，但是报错。所以要下载到本地自己的项目中，然后在项目中自己引用这两个文件。</li><li>由于主题不同，有的主题的作者在开始设计主题的时候就为用户写好了gitment 的配置代码，只需用户在主题的_config.yml 中开启并填写好配置参数即可，有的主题没有预制好 gitment 的配置代码，就需要用户自己去在样式模板中添加 gitment 代码。</li></ul></li><li><p>安装 gitment 到主题</p><ul><li>主题已经集成了 gitment 模块  <pre><code class="hljs plaintext">需要博主自己查看一下自己的主题结构，找到 themes 下的 _config.yml 文件，在文件中找到 gitment 模块的相关参数，然后在 enable 选项后面写上 true 即可完成安装过程。</code></pre></li><li>主题没有集成 gitment 模块  <pre><code class="hljs plaintext">将这两个文件下载到本地并引入自己主题的母板中就完成了安装，可根据自己的文件结构放置 css 和 js 文件，然后在模板文件中引用两个文件。本质上安装就是在主题模板文件中引入一个 css 和一个 js 文件，集成 gitment 模块的主题只不过是做到了代码分离，让需要配置的参数在_config.yml 中统一配置。gitment 作者给出的方法是在给没有集成的主题中的根本引入办法，如果你能看懂主题作者的组织结构，那完全可以给自己的主题集成 gitment 模块。下载地址：https://imsun.github.io/gitment/style/default.csshttps://imsun.github.io/gitment/dist/gitment.browser.js</code></pre>  <pre><code class="hljs plaintext">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://tujidelv.github.io/css/gitment.css&quot;&gt;&lt;script src=&quot;https://tujidelv.github.io/js/gitment.js&quot;&gt;&lt;/script&gt;</code></pre></li></ul></li><li><p>注册 OAuth application</p><ul><li><p>因为 gitment 是利用了 github 的 issue，所以要注册 OAuth application，来获取配置参数为接下来的配置做准备。</p></li><li><p><a href="https://github.com/settings/applications/new">点击此处</a>处来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 <a href="https://lvzhiqiang.top/">https://lvzhiqiang.top/</a>）。</p></li><li><p>注册后会给两个字符串 Client ID 和 Client Secret , 这两个下面配置的时候要用。</p></li></ul></li><li><p>配置 gitment 到 hexo 主题中</p><ul><li>主题已经集成了 gitment 模块  <pre><code class="hljs plaintext">只需在 _config.yml 中找到刚才开启 gitment 的那里，依次填入GitHub 用户名、存储评论的仓库地址、Clieent Id、和 Client Secret。</code></pre></li><li>主题没有集成 gitment 模块  <pre><code class="hljs plaintext">在刚才添加的母版中继续添加如下代码，并将以下代码中的四个参数按照提示填好即可。</code></pre>  <pre><code class="hljs plaintext">&lt;div id=&quot;comments&quot;&gt;&lt;/div&gt;&lt;script&gt;var gitment = new Gitment(&#123;  id: &#x27;&lt;%=url %&gt;&#x27;, // 可选。默认为 location.href  owner: &#x27;你的 GitHub ID(可以是你的 GitHub 用户名，也可以是 Github id，建议直接用 GitHub 用户名就可以)&#x27;,  repo: &#x27;存储评论的 Github repo(可以是博客下的仓库，也可以新建一个仓库专门存储评论内容)&#x27;,  oauth: &#123;    client_id: &#x27;你的 client ID&#x27;,    client_secret: &#x27;你的 client secret&#x27;,  &#125;,&#125;)gitment.render(&#x27;comments&#x27;)&lt;/script&gt;</code></pre></li></ul></li><li><p>初始化评论</p><ul><li>理论上按照以上配置完发布即可看到评论区了。只不过每一个帖子下面的评论区都要点击 <code>Initialize Comments</code> 才能开始评论。</li><li>根据 gitment 作者的说法，只要博主登录自己的 github 账号然后点击初始化就可以使用了。</li></ul></li><li><p>常见问题解决</p><ol><li>评论时点击登录，登录 GitHub 之后跳转回来的时候不能正常跳回刚才评论那页，每次跳到主页。 <pre><code class="hljs plaintext">解决办法：在注册 OAuth application 时的回调地址有问题，尝试写绑定的域名，而不是用 “https://用户名.github.io”</code></pre></li><li>报错 <code>[Error: Comments Not Initialized]</code> <pre><code class="hljs plaintext">文章作者需要登陆 GitHub 授权后，会显示初始化按钮(注意，不要多点按钮，否则 issues 出现多条一样的)点击初始化按钮后，如果正常就会出现&quot;No Comment Yet&quot;关于自动初始化所有文章的功能，可以用脚本来执行自动化，有需要的可以详细了解：https://github.com/imsun/gitment/issues/5</code></pre></li><li>报错 <code>[object ProgressEvent]</code> <pre><code class="hljs plaintext">原因：在母版中调用的 js 文件中，有访问 gitment 作者的服务器代码，而作者的服务器不好使了。解决办法： 自己搭建一个服务器（需要有一个 vps 来辅助搭建服务器）参考：https://github.com/imsun/gitment/issues/170--------------------------------1.在服务器中 clone 作者的服务器源码    git clone https://github.com/imsun/gh-oauth-server.git2.进入项目，下载依赖，并启动(如果成功,在项目目录下的 nohup.out 文件中的最后，会提示正在监听 3000 端口)    npm install &amp;&amp; nohup npm start3.替换 js 文件中的作者服务器为自己服务器，在作者的 js 文件中搜索以下字符串并将其替换成刚才搭建服务器的地址，如果没有做好端口映射可直接地址加端口也可以。    https://gh-oauth.imsun.net</code></pre> <pre><code class="hljs plaintext">推荐几位大佬搭建好的：    https://bak.smalbox.club    https://auth.baixiaotu.cc    https://cors.wenjunjiang.win/?remoteUrl=https://github.com/login/oauth/access_token    https://github.com/login/oauth/access_token</code></pre></li><li>报错 <code>[Error：validation failed]</code> <pre><code class="hljs plaintext">原因：    issue 的标签 label 有长度限制！labels 的最大长度限制是 50 个字符。--------------------------------解读：    id: &#x27;页面 ID&#x27;, // 可选。默认为 location.href    这个id的作用，就是针对一个文章有唯一的标识来判断这篇本章。    在issues里面，可以发现是根据网页标题来新建issues的，然后每个issues有两个labels（标签），一个是gitment，另一个就是id。    所以明白了原理后，就是因为id太长，导致初始化失败，现在就是要让id保证在50个字符内。    对应配置的id为：    id: &#x27;&lt;%= page.title %&gt;&#x27;    如果用网页标题也不能保证在50个字符！--------------------------------解决办法：    最后，我用文章的时间，这样长度是保证在50个字符内，完美解决！（避免了文章每次更新标题或路径时，会重新创建一个issue评论的问题。）    id: &#x27;&lt;%= page.date %&gt;&#x27;</code></pre></li><li>gitment 的汉化 <pre><code class="hljs plaintext">只需到模板里将原来定义CSS和JS的那两行改成如下即可    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://billts.site/extra_css/gitment.css&quot;&gt;    &lt;script src=&quot;https://billts.site/js/gitment.js&quot;&gt;&lt;/script&gt;来源：https://github.com/imsun/gitment/issues/104</code></pre></li><li>订阅 issue <pre><code class="hljs plaintext">issue 订阅，有新评论时就可以通过邮件提醒，这个功能是把双刃剑，因为有些垃圾订阅邮件骚扰，大家看着用吧。</code></pre></li></ol></li></ul><h3 id="备份当前项目源码"><a href="#备份当前项目源码" class="headerlink" title="备份当前项目源码"></a><strong>备份当前项目源码</strong></h3><ul><li>为防止当前项目源文件丢失，特补充此备份操作。</li><li>修改 Hexo 项目的 .gitignore 文件，然后通过 IDEA 同步到远程仓库。  <pre><code class="hljs plaintext">### Hexo ###.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/themes/### IntelliJ IDEA ###.idea/*.iml</code></pre><img src="/2018/12/01/af-hexo/af-hexo-005.png" alt="抱歉,图片休息了" title="将 hexo 源文件分享到 github"></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.youmeek.com/hexo-install/">http://www.youmeek.com/hexo-install/</a></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> 其他归档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿香婆屏幕截图工具 Ashampoo Snap</title>
      <link href="/2018/12/01/st-ashampoo-snap.html"/>
      <url>/2018/12/01/st-ashampoo-snap.html</url>
      
        <content type="html"><![CDATA[<h1 id="阿香婆屏幕截图工具-Ashampoo-Snap"><a href="#阿香婆屏幕截图工具-Ashampoo-Snap" class="headerlink" title="阿香婆屏幕截图工具 Ashampoo Snap"></a>阿香婆屏幕截图工具 Ashampoo Snap</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">使用方法</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>说明<ul><li>Ashampoo Snap 是德国 Ashampoo 软件公司的专业截图工具，只要屏幕上见到的使用它都能为您抓取并保存为高质量图片或视频。功能齐全，操作简单，界面优秀！。</li></ul></li><li>下载<ul><li>Windows 版：<img src="/2018/12/01/st-ashampoo-snap/dowload.png" width="16" height="16" align="center"><a href="https://pan.baidu.com/s/1G3bkWzUFXa7-RHnWhTo6cA">网盘下载</a> <code>提取码hm2g</code></li></ul></li><li>安装<ul><li>默认安装即可，最好改下安装路径。</li></ul></li><li>主要特性<ul><li>灵活精确的截图<blockquote><p>像素级精度的截图。无论是整个屏幕，单个网页或是一个区域 - Snap 都能截取出来生成图片或视频。还有定时器，自动滚动以及智能文本识别，为您提供无限可能。只需点击一下或是按下快捷键，Snap 10 就会立即开始进行截图工作！ </p></blockquote></li><li>一图胜千言<blockquote><p>使用 Snap 10 您可以与他人更快捷的分享信息。添加箭头、图形，自动标号，还有许多其它选项，让您的图片表意更加清晰。免去大段大段枯燥的描述，节省时间和精力！有图有真相 - 快捷、轻松，直击要害。</p></blockquote></li><li>创建自己的实时视频 <blockquote><p>实时编辑视频，添加文本、画上图像、语音叙述。现在可以直接进行后期处理了！在视频中可以可视化显示鼠标点击和键盘按下动作 - 这是制作教学视频的利器。如果需要保护知识产权，别忘了试试新的视频水印功能。</p></blockquote></li><li>匹配任意数量显示器<blockquote><p>同时使用个多显示器时，您可能会面临一大堆的屏幕分辨率和 DPI 设置问题。Snap 可以自动适应您的显示设置，完美兼容任何显示模式！</p></blockquote></li><li>完美获取网站内容<blockquote><p>Snap 10 不仅能截取网站图像，还能在图片上或是元数据中附加上源页面的信息。Snap 让一切都井井有条。如果您需要分享图片，Snap 可以自动添加图片链接。如果您希望捕获整个网站，或是光文本，甚至一次捕获是多个窗口。Ashampoo Snap 10 都能搞定！</p></blockquote></li><li>视频编辑，制作最完美的影片<blockquote><p>即使是已经很漂亮的视频也有不少调整空间：裁剪掉无用的场景，删除广告，或是分割视频成一个个片段。有了 Ashampoo Snap 10，您无再需要安装其它软件。设计精巧的编辑器帮您提取出视频中的重点和亮点部分。还可以附加其它视频，导出珍贵场景保存为 GIF 动画！</p></blockquote></li><li>安全的发送或上传到云端<blockquote><p>想要随时随地查看您的图片？Ashampoo Snap 10 可以做到：用邮件发送图片，保存到 Ashampoo 网络空间，或是上传到各个云服务（(DropBox、Microsoft OneDrive、Google Drive）。如有必要，可以在邮寄或上传前进行优化，缩小大小。</p></blockquote></li></ul></li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul><li>准备工作<ul><li>控制此程序<br>  <img src="/2018/12/01/st-ashampoo-snap/st-ashampoo-snap-001.png" alt="抱歉,图片休息了">  </li><li>常用设置<br>  <img src="/2018/12/01/st-ashampoo-snap/st-ashampoo-snap-002.png" alt="抱歉,图片休息了"><br>  <img src="/2018/12/01/st-ashampoo-snap/st-ashampoo-snap-003.png" alt="抱歉,图片休息了"></li></ul></li><li>主界面<ul><li>顶部<br>  <img src="/2018/12/01/st-ashampoo-snap/st-ashampoo-snap-004.png" alt="抱歉,图片休息了">  </li><li>左部<br>  <img src="/2018/12/01/st-ashampoo-snap/st-ashampoo-snap-005.png" alt="抱歉,图片休息了">  </li><li>右部<br>  <img src="/2018/12/01/st-ashampoo-snap/st-ashampoo-snap-006.png" alt="抱歉,图片休息了"></li></ul></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> 其他归档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> screenshot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超强SSH客户端 FinalShell</title>
      <link href="/2018/12/01/st-finalshell.html"/>
      <url>/2018/12/01/st-finalshell.html</url>
      
        <content type="html"><![CDATA[<h1 id="超强SSH客户端-FinalShell"><a href="#超强SSH客户端-FinalShell" class="headerlink" title="超强SSH客户端 FinalShell"></a>超强SSH客户端 FinalShell</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">使用方法</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>说明<ul><li>FinalShell 是一款集成 ssh 连接、ftp 管理、系统监控的软件，甚至提供了免费海外服务器远程桌面加速、ssh 加速、双边 tcp 加速、内网穿透等功能。</li></ul></li><li>下载<ul><li>Windows 版：<img src="/2018/12/01/st-finalshell/dowload.png" width="16" height="16" align="center"><a href="https://pan.baidu.com/s/1eZ3lsrCDZcd02nnJ4F2PBA">网盘下载</a> <code>提取码w17p</code></li><li>Mac 版,Linux 版：<a href="http://www.hostbuf.com/t/1059.html">FinalShell Mac OS版,Linux版安装及教程</a></li></ul></li><li>安装<ul><li>默认安装即可，最好改下安装路径。</li><li>中途会安装 winpcap(windows packet capture)，是 windows 平台下一个免费、公共的网络访问系统。</li></ul></li><li>主要特性<blockquote><p>1.多平台支持 Windows,Mac OS X,Linux.<br>  2.多标签,批量服务器管理.<br>  3.支持登录 Ssh 和 Windows 远程桌面.<br>  4.漂亮的平滑字体显示,内置 100 多个配色方案.<br>  5.终端,sftp 同屏显示,同步切换目录.<br>  6.命令自动提示,智能匹配,输入更快捷,方便.<br>  7.sftp 支持,通过各种优化技术,加载更快,切换,打开目录无需等待.<br>  8.服务器网络,性能实时监控,无需安装服务器插件.<br>  9.内置海外服务器加速,加速远程桌面和 ssh 连接,操作流畅无卡顿.<br>  10.双边加速功能,大幅度提高访问服务器速度.<br>  11.内存,Cpu 性能监控,Ping 延迟丢包,Trace 路由监控.<br>  12.实时硬盘监控.<br>  13.进程管理器.<br>  14.快捷命令面板,可同时显示数十个命令.<br>  15.内置文本编辑器,支持语法高亮,代码折叠,搜索,替换.<br>  16.ssh 和远程桌面均支持代理服务器.<br>  17.打包传输,自动压缩解压.<br>  18.免费内网穿透,无需设置路由器,无需公网 ip.<br>  19.支持 rz,sz(zmodem).</p></blockquote></li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul><li>ssh 添加</li></ul><p><img src="/2018/12/01/st-finalshell/st-finalshell-001.png" alt="抱歉,图片休息了"><br><img src="/2018/12/01/st-finalshell/st-finalshell-002.png" alt="抱歉,图片休息了"></p><ul><li>vps 连接</li></ul><p><img src="/2018/12/01/st-finalshell/st-finalshell-003.png" alt="抱歉,图片休息了"><br><img src="/2018/12/01/st-finalshell/st-finalshell-004.png" alt="抱歉,图片休息了"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> 其他归档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 札记：工作流</title>
      <link href="/2018/12/01/st-git-workflow.html"/>
      <url>/2018/12/01/st-git-workflow.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-札记：工作流"><a href="#Git-札记：工作流" class="headerlink" title="Git 札记：工作流"></a>Git 札记：工作流</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%88%86%E7%B1%BB">分类</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Git 工作流：分支管理策略<ul><li>集中式工作流</li><li>GitFlow 工作流</li><li>Github flow 工作流</li><li>AoneFlow 工作流</li></ul></li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="集中式工作流"></a>集中式工作流</h3><p><img src="/2018/12/01/st-git-workflow/st-git-workflow-001.png" alt="抱歉,图片休息了" title="集中式工作流"></p><ul><li>简介<ul><li>像 SVN 一样，集中式工作流以中央仓库作为项目所有修改的单点实体，所有修改都提交到 Master 这个分支上。</li></ul></li><li>评价<ul><li>这种方式与 SVN 的主要区别就是开发人员有本地库，Git 很多特性并没有用到。</li></ul></li></ul><h3 id="GitFlow-工作流"><a href="#GitFlow-工作流" class="headerlink" title="GitFlow 工作流"></a>GitFlow 工作流</h3><p><img src="/2018/12/01/st-git-workflow/st-git-workflow-002.png" alt="抱歉,图片休息了" title="GitFlow 工作流"></p><ul><li>简介<ul><li>GitFlow 工作流通过为功能开发、发布准备和维护设立了独立的分支，让发布迭代过程更流畅，严格的分支模型也为大型项目提供了一些非常必要的结构。</li></ul></li><li>评价<ul><li>GitFlow 的优点是清晰可控，缺点是相对复杂，需要同时维护两个长期分支，大多数工具都将 master 当作默认分支，可是开发是在 develop 分支进行的，这导致经常要切换分支，非常烦人，<br>  更大问题在于，这个模式是基于”版本发布”的，目标是一段时间以后产出一个新版本，但是，很多网站项目是”持续发布”，代码一有变动，就部署一次，这时，master 分支和 develop 分支的差别不大，没必要维护两个长期分支。</li></ul><p></p></li><li>分支种类<ul><li>长期分支(核心分支)<ul><li><strong>主干分支 master</strong><ul><li>主要负责管理正在运行的生产环境代码，永远保持与正在运行的生产环境完全一致，这条分支不能进行代码修改，只能用来合并其他分支。</li></ul></li><li><strong>开发分支 develop</strong><ul><li>主要负责管理正在开发过程中的代码，一般情况下应该是最新的代码，这条分支也不能进行代码修改，只能用来合并其他辅助分支。</li></ul></li></ul></li><li>临时分支(辅助分支)<ul><li><strong>补丁分支(bug 修理)hotfix</strong><ul><li>主要负责管理生产环境下出现的紧急修复的代码，基于 master 分支上创建，修复测试无误后合并到 Master 和 Develop 分支。视情况可以删除该分支。</li></ul></li><li><strong>预发分支(准生产)release</strong><ul><li>较大的版本上线前，会从 Develop 分支中分出准生产分支，进行最后阶段的集成测试，测试确定新功能没有问题,合并回 Master 和 Develop 分支，生产环境运行一段阶段较稳定后可以视情况删除。</li></ul></li><li><strong>功能分支 feature</strong><ul><li>为了不影响较短周期的开发工作，一般把中长期开发模块，会从 Develop 分支中独立出来，开发完成后合并到 Develop 分支，视情况可以删除该分支。</li></ul></li></ul></li></ul></li></ul><h3 id="Github-flow-工作流"><a href="#Github-flow-工作流" class="headerlink" title="Github flow 工作流"></a>Github flow 工作流</h3><ul><li>简介<ul><li>是 GitFlow 的简化版，它只有一个长期分支，就是 master，因此用起来非常简单,专门配合”持续发布”，它是 Github.com 使用的工作流程。</li></ul></li><li>评价<ul><li>Github flow 的最大优点就是简单，对于”持续发布”的产品，可以说是最合适的流程，但对于一些要指定时间才能发布的项目来说,容易导致最后线上版本落后于 master 分支,需要另外新建一个 production 分支跟踪线上版本。</li></ul></li><li>流程<ol><li>根据需求，从 master 拉出新分支，不区分功能分支或补丁分支。</li><li>新分支开发完成后，或者需要讨论的时候，就向 master 发起一个pull request（简称 PR）。</li><li>Pull Request 既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码，对话过程中，你还可以不断提交代码。</li><li>你的Pull Request 被接受，合并进 master，重新部署后，原来你拉出来的那个分支就被删除。（先部署再合并也可）</li></ol></li></ul><h3 id="AoneFlow-工作流"><a href="#AoneFlow-工作流" class="headerlink" title="AoneFlow 工作流"></a>AoneFlow 工作流</h3><ul><li>待更新…</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://git-scm.com/book/zh/v2">Git 官方文档</a></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 互联网工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 札记：远程库</title>
      <link href="/2018/12/01/st-git-remote.html"/>
      <url>/2018/12/01/st-git-remote.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-札记：远程库"><a href="#Git-札记：远程库" class="headerlink" title="Git 札记：远程库"></a>Git 札记：远程库</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%88%86%E7%B1%BB">分类</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>代码托管中心：用来维护远程仓库</p><pre><code class="hljs plaintext">外网环境：Github,码云等等内网环境：Gitlab,GitBucket 等等</code></pre><h2 id="外网"><a href="#外网" class="headerlink" title="外网"></a>外网</h2><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a><code>GitHub</code></h3><pre><code class="hljs plaintext">- 既是一个免费托管开源代码的远程仓库，可将个人的开源项目放上去；    还是一个开源协作社区，即可让别人参与你的开源项目，也可参与别人的开源项目。- Github 常用按钮说明    - Watch：关注该项目，作者有更新的时候，会在你的 Github 主页有通知消息。    - Star：收藏该项目，在你的头像上有一个 “Your stars” 链接，可以看到你的收藏列表，以方便下次进来。    - Fork：复制一份项目到自己的 Github 空间上，你可以自己开发自己的这个地址项目，然后 Pull Request 给项目原主人。```    ---- 本地创建 SSH Key</code></pre><p>1.在用户主目录下，如果有.ssh目录并且该目录下有id_rsa和id_rsa.pub两个文件，则跳过这步；否则在window 下打开Git Bash。<br>    $ ssh-keygen -t rsa -C “<a href="mailto:&#x74;&#x75;&#106;&#105;&#100;&#x65;&#x2e;&#108;&#x76;&#x40;&#x66;&#111;&#x78;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;">&#x74;&#x75;&#106;&#105;&#100;&#x65;&#x2e;&#108;&#x76;&#x40;&#x66;&#111;&#x78;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;</a>“<br>2.一直默认回车，生成的2个文件就是SSH Key的秘钥对，id_rsa是私钥，不能泄露，id_rsa.pub是公钥，可以告诉别人。</p><pre><code class="hljs plaintext">- GitHub 添加本地 SSH Key</code></pre><p>1.登陆GitHub，打开”Settings”&#x3D;&gt;”SSH Keys”页面，点击”New SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容，点击”Add Key”。<br>    可以添加多个，这样有这些公钥的电脑就可以将本地仓库代码推送到GitHub远程仓库中。</p><pre><code class="hljs plaintext">- 添加远程仓库</code></pre><p>1.登录GitHub，打开”New repository”,在”Repository name”填入learngit，其他保持默认设置，点击”Create repository”，就创建了一个新的Git仓库。<br>    该仓库为默认公开的，可通过交保护费让GitHub把仓库变成私有(被微软收购后免费)，或自己搭建Git服务器。<br>    该仓库默认是空的，可以与本地仓库关联，把本地仓库的内容推送到该仓库。</p><pre><code class="hljs plaintext">- 关联远程仓库并推送</code></pre><ol><li>查看远程库的详细信息<br> $ git remote -v<br>2.关联远程库并创建别名<br> $ git remote add &lt;远程仓库别名&gt; <a href="mailto:&#x67;&#105;&#x74;&#64;&#103;&#105;&#116;&#104;&#x75;&#98;&#x2e;&#x63;&#x6f;&#x6d;">&#x67;&#105;&#x74;&#64;&#103;&#105;&#116;&#104;&#x75;&#98;&#x2e;&#x63;&#x6f;&#x6d;</a>:GitHub账户名&#x2F;learngit.git<br> 注：如果在使用命令git remote add时报错(fatal: remote origin already exists.),说明本地库已经关联了一个名叫origin的远程库，有如下2种处理方案。<br> 1.删除已有的远程仓库origin关联,再重新关联<br>     - $ git remote rm origin<br> 2.因为git是分布布,支持同步到多个远程库,远程仓库的名字不能一样<br>     - $ git remote add gitee <a href="mailto:&#103;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#x65;&#101;&#46;&#99;&#111;&#109;">&#103;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#x65;&#101;&#46;&#99;&#111;&#109;</a>:xxx&#x2F;xxx.git<br>     - $ git remote add github <a href="mailto:&#103;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#x68;&#117;&#x62;&#46;&#x63;&#111;&#109;">&#103;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#x68;&#117;&#x62;&#46;&#x63;&#111;&#109;</a>:xxx&#x2F;xxx.git</li></ol><p>3.将本地库的内容(指定分支)推送到远程库对应的远程分支上(不存在时会自动新建)<br>    $ git push &lt;远程仓库别名&gt; 分支名<br>    注：-u 参数，第一次推送时需要,会把本地分支和远程分支关联起来，在以后的推送或拉取可以简化命令。<br>注：IDEA中可以通过”Share Project on GitHub”将项目直接分享到GitHub上。</p><pre><code class="hljs plaintext">- 从远程仓库克隆</code></pre><p>1.SSH协议Clone,没有添加Key将不能推送;Https协议Clone,需要登陆有权限的GitHub帐号才能推送。<br>    - 没加入团队是无法推送的,项目发起者可在’Settings’-&gt;’Collaborators’中邀请GitHub成员加入团队,并把邀请链接发给成员,成员登陆自己的帐号访问邀请链接以同意加入团队,即可进行远程推送。<br>    - HTTPS协议是无法记住登陆帐号的,第一次推送登陆后,而再次推送无需登陆,是因为win10系统的’凭据管理器’中的’Windows凭据’记住了密码,如果下次想切换别的帐号登陆,可以到此删除掉重新登陆。<br>2.把远程库下载到本地,因为是读操作,不需要验证身份<br>    $ git clone <a href="mailto:&#103;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#98;&#46;&#x63;&#x6f;&#109;">&#103;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#98;&#46;&#x63;&#x6f;&#109;</a>:GitHub账户名&#x2F;gitskills.git<br>    注：会关联远程库并创建别名,同时会把本地仓库master分支与远程仓库的master分支关联起来,在以后的推送或拉取时可以简化命令。<br>        1.–depth&#x3D;1,用于指定克隆深度,为1表示只克隆最近一次commit,历史旧数据不clone,可用于解决项目过大时clone导致timeout的问题,但他只会把默认分支 clone 下来,其他远程分支并不在本地,<br>            如需要的话可如下命令拉取其他分支。<br>            $ git remote set-branches origin ‘remote_branch_name’<br>            $ git fetch –depth&#x3D;1 origin remote_branch_name<br>    注：GitHub还会给出多个地址，如<code>https://github.com/GitHub账户名/gitskills.git</code>，因为Git支持多种协议，默认是通过ssh支持的原生git协议，速度最快；也可用https等其他协议，速度慢，<br>        每次推送必须输入口令。</p><pre><code class="hljs plaintext">- 拉取</code></pre><p>1.首先,可以试图用”git push origin branch-name”推送自己的修改。<br>2.如果推送失败,则因为不是基于GitHub远程库的最新版所做的修改(即远程分支比你的本地更新),需先用”git pull&#x2F;fetch”抓取远程的新提交,因为是读操作,不需要验证身份。<br>    - fetch<br>        - 把远程的更新下载到本地,可”git checkout origin&#x2F;master”切换查看内容,并没有修改工作区,可”git merge origin&#x2F;master”进行合并操作。<br>    - pull &#x3D; fetch + merge<br>        - 如果”git pull”提示”no tracking information”,则说明没有创建本地分支和远程分支的链接关系,用命令”git branch –set-upstream-to&#x3D;origin&#x2F;branch-name branch-name”再进行git pull。<br>        $ git pull      &#x2F;&#x2F;如果当前分支只有一个追踪分支,可以省略远程仓库名即可更新并合并<br>        $ git pull origin      &#x2F;&#x2F;如果当前分支有多个追踪分支,可以指定当前分支与指定的远程追踪分支进行更新并合并<br>        $ git pull origin master      &#x2F;&#x2F;指定当前分支与指定的远程master分支进行更新并合并<br>        $ git pull origin master1:master2      &#x2F;&#x2F;指定本地的master2分支与指定的远程master1分支进行更新并合并<br>3.如果合并有冲突,则手动解决冲突(解决的方法和分支管理中的解决冲突完全一样),并在本地提交。<br>4.没有冲突或者解决掉冲突后,再用”git push origin branch-name”推送就能成功。</p><pre><code class="hljs plaintext">- 跨团队协作/参与一个开源项目</code></pre><p>1.以自己身份进入开源项目主页,点击”fork”克隆到自己的远程仓库下。<br>2.从自己的远程仓库下克隆项目到本地,这样才能推送修改。ll<br>3.如果想修复开源项目的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的远程仓库推送。<br>4.如果希望开源项目的官方能接受你的修改，可以在GitHub上发起一个pull request,对方是否接受你的pull request就不一定了。<br>    1. 在自己远程仓库项目主页中,点击’Pull requests’&#x2F;‘New pull request’,此时’bask fork’选择官方作者,’head fork’选择自己,点击’Create pull request’,填好标题和说明(可选)确认。<br>    2. 此时官方作者可在项目主页中,点击’Pull requests’,能看到自己刚刚发送的请求,进去后可在里面跟请求者对话,点击’Files changed’审核代码,没问题的话可点击’Merge pull request’合并代码。<br>    3. 在自己远程仓库项目主页中,如果官方作者有回复内容,可在刚发送的请送中看到官方的回复内容,也可回复。<br>5.如果官方作者有提交新的代码,可在自己项目主页中,点击’Pull requests’&#x2F;‘New pull request’,此时’bask fork’选择自己,’head fork’选择官方作者,点击’Create pull request’,填好标题和说明(可选)确认。<br>    - 没问题的点击’Merge pull request’合并代码以获取官方作者的最新代码。</p><pre><code class="hljs plaintext">      ### `码云`- 同 GitHub 一样,提供免费的 Git 仓库;此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，码云还提供了项目管理、代码托管、文档管理的服务，5 人以下小团队免费。    - 码云的免费版本也提供私有库功能，只是有 5人 的成员上限。- 使用方法同 GitHub。## 内网### `GitLab`- 官网地址- 首页：&lt;https://about.gitlab.com/&gt; - 安装说明：&lt;https://about.gitlab.com/installation/&gt;- 安装命令摘录    ```shell    sudo yum install -y curl policycoreutils-python openssh-server cronie    sudo lokkit -s http -s ssh    sudo yum install postfix    sudo service postfix start    sudo chkconfig postfix on    curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash    sudo EXTERNAL_URL=&quot;http://gitlab.example.com&quot; yum -y install gitlab-ee</code></pre><pre><code> - 实际问题：yum 安装 gitlab-ee(或ce)时，需要联网下载几百 M 的安装文件，非常耗时，所以应提前把所需 RPM 包下载并安装好。 下载地址为：&lt;https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-10.8.2-ce.0.el7.x86_64.rpm&gt;，调整后的安装过程：<pre><code class="hljs shell">sudo rpm -ivh /opt/gitlab-ce-10.8.2-ce.0.el7.x86_64.rpmsudo yum install -y curl policycoreutils-python openssh-server cronie  sudo lokkit -s http -s sshsudo yum install postfixsudo service postfix startsudo chkconfig postfix oncurl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bashsudo EXTERNAL_URL=&quot;http://gitlab.example.com&quot; yum -y install gitlab-ce</code></pre>- 当前步骤完成后重启</code></pre><ul><li>GitLab 服务操作<ul><li>初始化配置 gitlab  <pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gitlab-ctl reconfigure</span></code></pre></li><li>启动&#x2F;停止 gitlab 服务  <pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gitlab-ctl start/stop</span></code></pre></li></ul></li><li>浏览器访问<ul><li>访问 Linux 服务器 IP 地址即可，如果想访问 EXTERNAL_URL 指定的域名还需要配置域名服务器或本地 hosts 文件。<ul><li>应该会需要停止防火墙服务  <pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">service firewalld stop</span></code></pre></li></ul></li><li>初次登录时需要为 gitlab 的 root 用户设置密码。</li></ul></li></ul><h3 id="原生搭建"><a href="#原生搭建" class="headerlink" title="原生搭建"></a><code>原生搭建</code></h3><ol><li>安装 Git <pre><code class="hljs plaintext">$ apt-get install git  (Debian系列系统)$ yum install -y git   (RetHat系列系统)</code></pre></li><li>创建Git用户，用来管理 Git服务，并为 Git 用户设置密码 <pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">id</span> git</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">useradd git</span><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;git&#x27;</span> | passwd --stdin git &amp;&gt; /dev/null</span></code></pre></li><li>创建 Git 仓库<ol><li>先选定一个目录作为 Git 仓库，假定是&#x2F;www&#x2F;wwwroot&#x2F;hexo.lvzhiqiang.top&#x2F;hexo-blog.git&#x2F;，在&#x2F;www&#x2F;wwwroot&#x2F;hexo.lvzhiqiang.top&#x2F;目录下输入如下命令,Git<br> 就会创建一个裸仓库，裸仓库没有工作区。 <pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init --bare sample.git</span></code></pre></li><li>因为服务器上的 Git 仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的 Git 仓库通常都以 .git 结尾。然后把 owner 改为 git。 <pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chown</span> -R git:git sample.git</span></code></pre> 注：如果执行了第4步,可再执行这个命令。</li></ol></li><li>配置 git hooks 来生成对应的工作区(<strong>非必须</strong>)<ul><li>这里要使用的是 <code>post-receive</code> 的 hook，这个 hook 会在整个 git 操作过程完结以后被运行。</li></ul><ol><li>在&#x2F;home&#x2F;data&#x2F;git&#x2F;sample.git&#x2F;hooks目录下创建hook钩子函数，可新建<code>post-receive</code>文件,填入如下内容 <pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span>git --work-tree=/www/wwwroot/hexo.lvzhiqiang.top/hexo-blog --git-dir=/www/wwwroot/hexo.lvzhiqiang.top/hexo-blog.git checkout -f</code></pre></li><li>为文件添加可执行权限 <pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> +x post-receive</span></code></pre></li></ol></li><li>Git 打开 RSA 认证<ol><li>进入&#x2F;etc&#x2F;ssh目录，编辑 sshd_config，打开以下三个配置的注释，然后重启 sshd 服务 <pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim sshd_config</span>    RSAAuthentication yes    PubkeyAuthentication yes    AuthorizedKeysFile .ssh/authorized_keys<span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl restart sshd</span>    或者$ /etc/rc.d/init.d/sshd restart</code></pre> Tips：由 AuthorizedKeysFile 得知公钥的存放路径是.ssh&#x2F;authorized_keys，实际上是 $Home&#x2F;.ssh&#x2F;authorized_keys，由于管理 Git 服务的用户是git，所以实际存放公钥的路径是&#x2F;home&#x2F;git&#x2F;.ssh&#x2F;authorized_keys</li><li>在&#x2F;home&#x2F;git&#x2F;下创建目录 .ssh,然后把 .ssh 文件夹的 owner 修改为 git <pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> .ssh</span><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chown</span> -R git:git .ssh</span></code></pre></li></ol></li><li>创建证书登录(添加客户端公钥到服务器)<ol><li>收集所有需要登录的用户的公钥，就是他们自己的 id_rsa.pub 文件，把所有公钥导入到&#x2F;home&#x2F;git&#x2F;.ssh&#x2F;authorized_keys 文件里，一行一个 <pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh git@server <span class="hljs-string">&#x27;cat &gt;&gt; .ssh/authorized_keys&#x27;</span> &lt; ~/.ssh/id_rsa.pub</span></code></pre> 或者 <pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh-copy-id -i ~/.ssh/id_rsa.pub git@服务器IP -p 端口号(默认22时可不用此参数)</span></code></pre> Tips：需要输入服务器端 git 用户的密码</li><li>查看服务器端 .ssh 下是否存在 authorized_keys 文件 <pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ll git/.ssh/</span></code></pre></li><li>修改 .ssh 目录的权限为 700(rwx——)，修改 .ssh&#x2F;authorized_keys 文件的权限为600(rw——-) <pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> 700 .ssh</span><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> 600 authorized_keys</span></code></pre></li><li>测试能否登录，此时的 ssh 登录 git 用户不需要密码！否则就有错,可尝试重启<code>sshd</code>服务 <pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh git@server_ip -p 端口号(默认22时可不用此参数)</span></code></pre></li></ol></li><li>禁止 git 用户 ssh 登录服务器<ul><li>出于安全考虑，第二步创建的 git 用户不允许登录 shell，这可以通过编辑&#x2F;etc&#x2F;passwd 文件完成。将 bash 修改为 git-shell,找到类似下面的一行：  <pre><code class="hljs plaintext">git:x:1001:1001:,,,:/home/git:/bin/bash改为：git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</code></pre></li><li>这样，git 用户可以正常通过 ssh 使用 git，但无法登录 shell，因为我们为 git 用户指定的 git-shell 每次一登录就自动退出。</li></ul></li><li>客户端克隆远程仓库 <pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> git@server:/www/wwwroot/hexo.lvzhiqiang.top/hexo-blog.git</span></code></pre> Tips：如果 SSH 用的不是默认的 22 端口，则需要使用以下的命令（假设 SSH 端口号是 7700） <pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> ssh://git@server:7700/www/wwwroot/hexo.lvzhiqiang.top/hexo-blog.git</span></code></pre></li><li>管理公钥<ul><li>如果团队很小，把每个人的公钥收集起来放到服务器的&#x2F;home&#x2F;git&#x2F;.ssh&#x2F;authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用 Gitosis 来管理公钥。</li></ul></li><li>管理权限<ul><li>因为 Git 是为 Linux 源代码托管而开发的，所以 Git 也继承了开源社区的精神，不支持权限控制。</li><li>不过，因为 Git 支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的，Gitolite 就是这个工具。</li></ul></li></ol><h3 id="GitBucket"><a href="#GitBucket" class="headerlink" title="GitBucket"></a><code>GitBucket</code></h3><ul><li>待更新…</li></ul><h3 id="Gogs"><a href="#Gogs" class="headerlink" title="Gogs"></a><code>Gogs</code></h3><ul><li>官⽹：<a href="https://gogs.io/">https://gogs.io</a></li><li>介绍：Gogs是⼀款开源的轻量级Git web服务，其特点是简单易用、文档齐全、国际化做的相当不错。  <pre><code class="hljs plaintext">其主要功能如下: 1. 提供Http与ssh两种协议访问源码服务。2. 提供可WEB界⾯可查看修改源码代码 。3. 提供较完善的权限管理功能，其中包括组织、团队、个⼈等仓库权限 。4. 提供简单的项⽬viki功能。 5. 提供⼯单管理与⾥程碑管理。</code></pre></li><li>安装<ol><li>下载 <a href="https://gogs.io/docs/installation">Gogs</a>，选择Linux amd64 <pre><code class="hljs plaintext">$ wget -P /opt/setups/ https://dl.gogs.io/0.11.91/gogs_0.11.91_linux_amd64.zip</code></pre></li><li>解压到指定目录 <pre><code class="hljs plaintext"># mkdir -pv /usr/program# unzip gogs_0.11.91_linux_amd64.zip -d /usr/program/</code></pre></li><li>启动 <pre><code class="hljs plaintext">$ nohup ./gogs web &gt; log.out &amp;</code></pre></li><li>访问<a href="http://0.0.0.0:3000/">http://0.0.0.0:3000</a></li></ol></li><li>定时备份与恢复<ul><li>备份与恢复  <pre><code class="hljs bash">    <span class="hljs-comment"># 查看备份相关参数</span>    ./gogs backup -h    <span class="hljs-comment"># 默认备份,备份在当前目录</span>    ./gogs backup    <span class="hljs-comment"># 参数化备份  --target 输出目录 --database-only 只备份db</span>    ./gogs backup --target=./backupes --database-only --exclude-repos    <span class="hljs-comment"># 恢复 执行该命令前要先删除custom.bak</span>    ./gogs restore --from=gogs-backup-20180411062712.zip    ```  - ⾃动备份脚本    ```bash    <span class="hljs-comment">#!/bin/sh -e</span>    gogs_home=<span class="hljs-string">&quot;/usr/program/gogs&quot;</span>    backup_dir=<span class="hljs-string">&quot;<span class="hljs-variable">$gogs_home</span>/backups&quot;</span>        <span class="hljs-built_in">cd</span> `<span class="hljs-built_in">dirname</span> <span class="hljs-variable">$0</span>`    <span class="hljs-comment"># 执行备份命令</span>    ./gogs backup --target=<span class="hljs-variable">$backup_dir</span>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;backup sucess&#x27;</span>    day=7    <span class="hljs-comment">#查找并删除 7天前的备份  </span>    find <span class="hljs-variable">$backup_dir</span> -name <span class="hljs-string">&#x27;*.zip&#x27;</span> -mtime +7 -<span class="hljs-built_in">type</span> f |xargs <span class="hljs-built_in">rm</span> -f;    <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;delete expire back data!&#x27;</span></code></pre></li><li>添加定时任务  <pre><code class="hljs plaintext"># 打开任务编辑器crontab -e# 输入如下命令 00 04 * * * 每天凌晨4点执行 do-backup.sh 并输出日志至 #backup.log00 04 * * * /usr/program/gogs/do-backup.sh &gt;&gt; /usr/program/gogs/log/backup.log 2&gt;&amp;1</code></pre></li></ul></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://git-scm.com/book/zh/v2">Git 官方文档</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程 - 廖雪峰的官方网站</a></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li><li>update by 20190801  <pre><code class="hljs plaintext">1.如果在github pushr的过程中提示&quot;Connection reset by 13.250.177.223 port 22 fatal: Could not read from remote repository.&quot;2.可尝试&quot;ping github.com&quot;看是否能Ping通,超时则应该是本地DNS无法解析导致的3.可修改&quot;C:\Windows\System32\drivers\etc\hosts&quot;添加    192.30.255.112  github.com git     185.31.16.184 github.global.ssl.fastly.net4.可继续2步骤测试</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 互联网工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 札记：基础</title>
      <link href="/2018/12/01/st-git-basic.html"/>
      <url>/2018/12/01/st-git-basic.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-札记：基础"><a href="#Git-札记：基础" class="headerlink" title="Git 札记：基础"></a>Git 札记：基础</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2">发展历史</a></li><li><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">准备工作</a></li><li><a href="#%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86">add&#x2F;commit 内部原理</a></li><li><a href="#%E6%9C%AC%E5%9C%B0%E5%BA%93%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">本地库常用操作</a></li><li><a href="#%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86">分支管理</a></li><li><a href="#%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86">标签管理</a></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89Git">自定义 Git</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><h3 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h3><ul><li>集中式<ul><li>免费：CVS(由于自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况),SVN(修正了CVS的一些稳定性问题)</li><li>收费：ClearCase(以前是 Rational 公司的，被 IBM 收购了,特点是安装比 Windows 还大，运行比蜗牛还慢，能用 ClearCase 的一般是世界 500 强，他们有个共同的特点是财大气粗，或者人傻钱多)</li></ul></li><li>分布式<ul><li>免费：Git(目前世界上最先进、最流行的分布式版本控制系统)</li><li>收费：BitKeeper(属于 BitMover 公司,2002 年授权 Linux 社区免费使用,2005 年终止,促使 Git 诞生)</li></ul></li></ul></li><li><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>无需联网,大部分操作在本地完成</li><li>安全性高,通过哈希算法来保证数据的完整性</li><li>强大的分支管理,分支操作非常快捷流畅</li><li>与 Linux 命令全面兼容</li></ul></li></ul><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><p><img src="/2018/12/01/st-git-basic/st-git-basic-001.png" alt="抱歉,图片休息了" title="Linux 系统版本控制历史"></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>安装过程中选择<code>User Git from Git Bash only</code>,表示完全不修改PATH环境变量,仅在Git Bash中使用Git  <pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git --version      //查看git是否安装成功及版本号</span></code></pre></li><li>设置签名用来区分不同开发人员的身份  <pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="hljs-string">&quot;tujidelv&quot;</span>      //为该机器上所有的git仓库指定用户名</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git config --global user.email <span class="hljs-string">&quot;tujide.lv@foxmail.com&quot;</span>      //为该机器上所有的git仓库指定email地址</span></code></pre></li><li>适当地显示不同的颜色  <pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git config --global color.ui <span class="hljs-literal">true</span></span></code></pre></li></ul><h2 id="内部原理"><a href="#内部原理" class="headerlink" title="内部原理"></a>内部原理</h2><p><img src="/2018/12/01/st-git-basic/st-git-basic-002.png" alt="抱歉,图片休息了" title="add/commit图解"></p><ul><li><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>Git存储对象(hashmap)  <pre><code class="hljs plaintext">Git是一个内容寻址文件系统，其核心部分是一个简单的键值对数据库（key-value data store），你可以向数据库中插入任意内容，它会返回一个用于取回该值的hash键。      # git键值库中插入数据# 写入版本1$ echo &#x27;version1&#x27; &gt; README.MF; git hash-object -w README.MF;# 写入版本2$ echo &#x27;version2&#x27; &gt; README.MF; git hash-object -w README.MF;# 写入版本3$ echo &#x27;version3&#x27; &gt; README.MF; git hash-object -w README.MF;79362d07cf264f8078b489a47132afbc73f87b9a      # 查找所有的git对像$ find .git/objects/ -type f# 基于键获取指定内容(git基于该功能把每个文件的版本中内容都保存在数据库中，当要进行版本回滚的时候就通过其中一个键将其取回并替换)$ git cat-file -p 79362d07cf264f8078b489a47132afbc73f87b9a      # 回滚指定版本$ git cat-file -p c11e96db44f7f3bc4c608aa7d7cd9ba4ab25066e &gt; README.MF      所以我们平常用的git add其实就是把修改之后的内容插入到键值库中。当我们执行git add README.MF就包括了执行git hash-object -w README.MF把文件写到数据库中。我们解决了存储的问题，但其只能存储内容并没有存储文件名，如果要进行回滚,怎么知道哪个内容对应哪个文件呢？接下要讲的就是树对象，它解决了文件名存储的问题。</code></pre></li><li>Git树对象  <pre><code class="hljs plaintext">树对象解决了文件名的问题，它的目的将多个文件名组织在一起，其内包含多个文件名称与其对应的Key和其它树对象的引用，可以理解成操作系统当中的文件夹，一个文件夹包含多个文件和多个其它文件夹。每一个分支当中都关联了一个树对象，他存储了当前分支下所有的文件名及对应的 key。      #查看分支树对象或者其他树对象$ git cat-file -p &lt;master^&#123;tree&#125; | tree_id&gt; $ git cat-file -p a1183ea74b0cd7b5cec6b9bf8b758e03f8c5ba94100644 blob 46ad03092238f6c2ee203ef8bb14dc88faa5203b    .gitignore100644 blob 6a96454c48ac077474c118f5ed26c02c0f05e762    README.md100644 blob d8033580327bba5b2480e16fbbb1dc5fea61e2b4    TOC.md100644 blob e1ec5e0c6b69f3371d730926d6d4d2b52faf44f5    _config.yml100644 blob 36eaa9c9d2243211556e6e517e5545bbdb62677d    hd.sh100644 blob 6a8ed3965ab82e1b73bb7dcc94c575bc85f4317e    hs.sh100644 blob 911639e0e486bc709ac7813e2a52082ad9e115e9    package-lock.json100644 blob d457fbae7bcb0ef328e13b7fc12a9aeba55597ea    package.json040000 tree a99672782f26a13f14589febab3fe407e64170ae    scaffolds040000 tree 2ff7dd52dc20edb978226c298967bf33800d26d3    source</code></pre></li><li>Git提交对象  <pre><code class="hljs plaintext">一次提交即为当前版本的一个快照，该快照就是通过提交对象保存，其存储的内容为：一个顶级树对象、上一次提交的对象啥希、提交者用户名及邮箱、提交时间戳、提交评论。$ git cat-file -p a33ef4etree a1183ea74b0cd7b5cec6b9bf8b758e03f8c5ba94parent 96bcdd27b47641809d42b2417985a44aa8d25960author lvzhiqiang &lt;zhiqiang.lv@riskraider.com&gt; 1579428368 +0800committer lvzhiqiang &lt;zhiqiang.lv@riskraider.com&gt; 1579428368 +0800pushcode通过上面的知识，我们可以推测出从修改一个文件到提交的过程总共生成了三个对象：一个内容对象 ==&gt; 存储了文件内容一个树对象 ==&gt; 存储了文件名及内容对象的key一个提交对象 ==&gt; 存储了树对象的key及提交评论。</code></pre></li><li>Git引用  <pre><code class="hljs plaintext">当我们执行git branch &#123;branchName&#125;时创建了一个分支，其本质就是在git基于指定提交创建了一个引用文件，保存在.git\refs\heads\下。# 演示分支的创建$ git branch dev $ cat.git\refs\heads\dev      git总共有三种类型的引用：分支引用、远程分支引用、标签引用</code></pre></li></ul></li><li><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><ul><li>保存二进制对象：<code>$ git hash-object -w test.txt</code>    <pre><code class="hljs plaintext">- 把test.txt的当前内容压缩成二进制文件存入Git，压缩后的二进制文件称为一个Git对象，保存在.git/objects目录,同时会计算当前内容的SHA1哈希值（长度40的字符串）作为该对象的文件名。- .git/objects下面的一个个子目录名是该哈希值的前2个字符，该子目录下面有一个文件，文件名是哈希值的后38个字符。- 用cat命令查看该文件都是一些二进制字符(包括元数据),可用如下命令查看文件原始的文本内容:$ git cat-file -p e69de29bb2d1d6434b8b29ae775ad8c2e48c5391</code></pre></li><li>更新暂存区：<code>$ git update-index --add --cacheinfo 100644 3b18e512dba79e4c8300dd08aeb37f8e728b8dad test.txt</code>  <pre><code class="hljs plaintext">- 用于在暂存区记录一个发生变动的文件- 向暂存区(stage)写入文件名test.txt、二进制对象名（哈希值）和文件权限(100代表regular file[普通文件],644代表rw-r--r--)</code></pre></li></ul><p>  Tips：<strong>Git提供了git add命令简化上面2步操作。</strong></p></li><li><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><ul><li>保存当前目录结构：<code>$ git write-tree</code>  <pre><code class="hljs plaintext">- 将当前的目录结构生成一个Git对象,目录结构也是作为二进制对象保存的，也保存在.git/objects目录里面，对象名就是哈希值</code></pre></li><li>将目录树对象写入版本历史：<code>$ echo &quot;first commit&quot; | git commit-tree c3b8bb102afeca86037d5b5dd89ceeb0090eae9d</code>  <pre><code class="hljs plaintext">- 提交的时候需要有提交说明，echo &quot;first commit&quot;就是给出提交说明。然后git commit-tree命令将元数据和目录树，一起生成一个Git对象- 用git cat-file -p命令能看到本次快照对应的目录树对象（tree），作者和提交人信息，以及提交说明- 用如下命令也可以用来查看某个快照信息:$ git log --stat c9053865e9dff393fd2f7a92a18f9bd7f2caa7fa</code></pre></li><li>更新HEAD的值向我们的commit对象：<code>$ git update-ref refs/heads/master 4ad659c50196f780b19b1ab6c338205815a4d74a</code>  <pre><code class="hljs plaintext">如果当前不在master分支而在其他分支上，则需要指定为其他分支</code></pre></li></ul><p>  Tips：<strong>Git提供了git commit命令简化上面3步操作。</strong></p></li></ul><h2 id="本地库常用操作"><a href="#本地库常用操作" class="headerlink" title="本地库常用操作"></a>本地库常用操作</h2><ul><li>常用命令  <pre><code class="hljs plaintext">- git help &lt;命令&gt;- git init [目录]     //初始化版本库(把当前目录变成git可以管理的仓库[会在当前目录创建一个.git子目录，用来保存版本信息])- git add &lt;FILE...|DIR...&gt;      //告诉git把文件添加到仓库的暂存区，可反复多次使用，并且每次可添加多个文件    - 实际上就是把要提交的所有修改添加到暂存区（stage）    - git add --all/-A/.      //对当前项目所有变动的文件，执行保存二进制对象和更新暂存区操作- git commit [文件] -m &quot;wrote a readme file&quot;      //告诉git把文件提交到仓库的分支（-m后面是本次提交的说明），一次可提交多个文件    - 实际上就是一次性把暂存区的所有修改提交到分支（master）- git status      //查看工作区/暂存区的状态    - git status -s    //返回一个简单版的 git status。我设置这个命令为默认 git status 来减少噪音。- git diff [FILE]      //如果git status提示有文件被修改，可以用此命令查看指定文件修改了哪些内容，显示的格式是Unix通用的diff格式    - 比较的是版本库（暂存区和分支中的任意一个）与工作区同名文件相比是否相同，而git diff --cached比较的是暂存区有无内容    - git diff HEAD [FILE]      //将工作区中的文件和本地库历史记录比较- git log [branch-name]     //显示从最近到最远的提交日志。其中commit(快照) id是用SHA1算出的16进制数字    - 后面加上--pretty=oneline可以精简信息    - 后面加上--graph可以看到分支合并情况    - 后面加上--abbrev-commit可以精简快照id    - 后面加上dev..master可以查看master分支还有多少修改没有同步到dev分支- git show [branch-name]    //显示最近一次提交的内容详细改变- git reflog      //查看命令历史，当找不到新版本的id时可以用此来确定要回到未来的哪个版本    - HEAD@&#123;移动到当前版本需要多少步&#125;</code></pre></li><li>其他命令  <pre><code class="hljs plaintext">- git checkout -- &lt;FILE&gt;...      //撤销此文件在工作区的修改(包括删除)，回到最近一次commit或add时的状态    - git checkout -- .      //撤销工作区所有的修改    - git checkout -- *.java      //撤销工作区所有java文件的修改- git reset HEAD &lt;FILE&gt;...      //撤销此文件在暂存区的修改，回退到工作区    - git reset HEAD *      //撤销暂存区所有的修改- git rm FILE      //当想从版本库中删除文件时，可先在工作区删除，然后调用此命令，再commit    - git rm –cached FILE    //只删除远程文件，但是不影响本地文件。这对删除已经推送过的忽略文件记录而且不影响本地文件是非常的方便的。- git reset --hard HEAD~      //版本回退,HEAD代表当前版本，~代表回退到上个版本，如回到上100个版本可以用HEAD~100来表示     - git reset --hard 43ade3f      //当想回到之前的新版本时(也能后退)，可以找到它的commit id输入前几位即可(基于局部索引值操作,推荐)    - --hard      //会让当前工作区和暂存区的修改也撤销    - --soft      //不会让当前工作区和暂存区的修改也撤销,上次的提交由本地仓库回到暂存区    - --mix      //不会让当前工作区的修改撤销,会让暂存区的修改撤销,上次的提交由本地仓库回到暂存区- git stash      //隐藏工作现场    - 当手头工作没有完成时(工作区/暂存区有变动时),先把工作现场git stash隐藏一下,这样git status查看工作区是干净的,然后去修复bug,修复后,再git stash pop,回到份工作现场    - git stash list      //查看隐藏的工作现场    - git stash pop      //恢复隐藏的工作现场,同时删除stash内容- git shortlog -sn    //显示提交记录的参与者列表。和GitHub的参与者列表相同。</code></pre></li></ul><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p><img src="/2018/12/01/st-git-basic/st-git-basic-003.png" alt="抱歉,图片休息了" title="分支操作流程图"></p><ul><li><h3 id="分支的好处"><a href="#分支的好处" class="headerlink" title="分支的好处"></a>分支的好处</h3><ul><li>同时并行推进多个功能开发，提高开发效率</li><li>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响,删除失败的分支重新开始即可</li></ul></li><li><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><ul><li>查看所有分支：<code>$ git branch [-v]</code><blockquote><p>当前分支前面会标一个*号</p></blockquote></li></ul></li></ul><p>查看所有分支(包括远程分支)：$ git branch -avv<br>    - 创建+切换分支：<code>$ git checkout -b name [branch-name]</code><br>        &gt;基于提交&#x2F;指定分支(默认当前分支)创建新分支：$ git branch new-branch-name [branch-name | commit id]<br>基于远程分支(必须已存在)创建与之对应的新分支：$ git branch new-branch-name &lt;origin&#x2F;branch-name&gt;<br>切换分支：$ git checkout branch-name<br>    - 合并指定分支到当前分支：<code>$ git merge [-m &quot;...&quot;] &lt;name&gt;</code><br>        &gt;Fast-forward，代表此次合并是”快进模式”，即把当前分支(master)指向指定分支(dev)的当前提交，所以合并速度非常快,这种模式下，删除分支后，会丢失掉分支信息<br>后面加上–no-ff 参数，表示禁用”Fast-forward”，用普通模式合并，会创建一个新的 commit,合并后的历史能看到分支信息,能看出来曾经做过合并,而 fast forward 合并就看不出来曾经做过合并<br>    - 删除分支：<code>$ git branch -d &lt;name&gt;</code><br>        &gt;$ git branch -D <name>   强行删除一个没有被合并过的分支(分支中只有空文件时可用普通方式-d删除分支)</name></p><ul><li><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ul><li>当 Git 无法自动合并分支时，须手动编辑文件解决冲突，然后再添加到暂存区再提交，合并完成  <pre><code class="hljs plaintext">CONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result.</code></pre></li></ul></li><li><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><ul><li>首先，master 主分支应该非常稳定，仅用来发布新版本，平时不能在上面干活；</li><li>每个人干活都在 dev 分支上，dev 分支是不稳定的，例如 1.0 版本发布时，再把 dev 分支合并到 master 上，在 master 主分支发布 1.0 版本；</li><li>每个人都有自己的分支，时不时的往 dev 分支上合并就行。</li><li><strong>本地新建的分支如果不推送到远程,对其他人就是不可见的。</strong></li></ul><p></p></li><li>Rebase<ul><li>$ git rebase 操作可以把本地未 push 的分叉提交历史整理成直线</li><li>Rebase 的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</li></ul></li></ul><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><ul><li>Git 标签虽然是版本库的快照,但其实是指向某个 commit 的死指针(与分支类似,但分支可以移动,标签不能移动),所以，创建和删除标签都是瞬间完成的。</li><li>创建标签  <pre><code class="hljs plaintext">$ git tag &lt;tagname&gt; [branch-name]      //新建一个标签,默认是打在当前分支下的最新commit上的    - $ git tag &lt;tagname&gt; [commitid]      //打在某次指定(commit id)提交上    - $ git tag -a &lt;tagname&gt; -m &quot;&quot; [commitid]      //创建带有说明的标签,-a指定标签名,-m指定说明信息        - $ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164    - $ git tag -s &lt;tagname&gt; -m &quot;&quot; [commitid]      //创建PGP签名的标签,不可伪造,-s用私钥签名一个标签        - 必须先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错;如果报错，请参考GnuPG帮助文档配置Key</code></pre></li><li>操作标签  <pre><code class="hljs plaintext">$ git tag      //查看所有标签,按字母排序列出,而不是按时间顺序$ git show &lt;tagname&gt;      //查看指定标签信息$ git tag -d &lt;tagname&gt;      //删除一个本地标签$ git push origin &lt;tagname&gt;      //推送一个本地标签到远程$ git push origin --tags      //推送全部未推送过的本地标签到远程$ git push origin :refs/tags/&lt;tagname&gt;      //删除一个远程标签,需先删除对应的本地标签</code></pre></li></ul><h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><h3 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h3><ul><li>有些时候，你必须把某些文件放到 Git 工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件等等，每次 git status 都会显示 Untracked files …，<br>有强迫症的童鞋心里肯定不爽,可以在 Git 工作区的根目录下创建一个特殊的 .gitignore 文件，然后把要忽略的文件名填进去，Git 就会自动忽略这些文件。</li><li>不需要从头写 .gitignore 文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了(该文件要提交到版本库才能生效)。<br>所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a></li><li>原则<ul><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ul></li><li>有些时候添加一个文件到 Git，但发现添加不了，原因是这个文件被 .gitignore 忽略了,有如下2种处理方法  <pre><code class="hljs plaintext">$ git add -f FILE      //用-f强制添加到Git$ git check-ignore -v FILE      //检查.gitignore文件的哪个配置影响了该文件,好修改规则</code></pre></li><li>Windows 下创建 .gitignore 文件的常用方法<ul><li>方法一（最直接）：在资源管理创建文件时，文件命名“.gitignore.”，注意结尾有个 . 号，回车确认时系统会自动存成 .gitignore。</li><li>方法二：打开文本编辑器，保存时文件名输入“.gitignore”，保存类型选“所有文件”。</li><li>方法三：进入 cmd 命令行，执行 echo &gt; .gitignore 输入空内容并创建文件，或执行 rename somefile .gitignore、copy somefile .gitignore 从已有文件复制、重命名。</li></ul></li></ul><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><ul><li>通过命令配置<ul><li>加上–global 是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用  <pre><code class="hljs plaintext">$ git config --global alias.st status $ git config --global alias.co checkout$ git config --global alias.ci commit$ git config --global alias.br branch$ git config --global alias.unstage &#x27;reset HEAD&#x27;$ git config --global alias.last &#x27;log -1&#x27;      //显示最近一次的提交$ git config --global alias.lg &quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</code></pre></li></ul></li><li>通过文件配置<ul><li>每个仓库的 Git 配置文件都放在 .git&#x2F;config 文件中,而当前用户的 Git 配置文件放在用户主目录下的一个隐藏文件 .gitconfig 中,别名就在[alias]后面，要删除别名，直接把对应的行删掉即可  <pre><code class="hljs plaintext">[alias]co = checkoutci = commitbr = branchst = statusunstage = reset HEADlast = log -1lg = log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit[user]name = tujidelvemail = tujide.lv@foxmail.com</code></pre></li></ul></li><li>windows 版 git bash 设置其他命令别名<ul><li><strong>Git 安装目录,修改 etc&#x2F;profile.d&#x2F;aliases.sh 文件。</strong></li></ul></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://git-scm.com/book/zh/v2">Git 官方文档</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程 - 廖雪峰的官方网站</a></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li><li>update by 20200120<img src="/2018/12/01/st-git-basic/st-git-basic-004.png" alt="抱歉,图片休息了" title="git push流程" width="600" height="160" align="center"><img src="/2018/12/01/st-git-basic/st-git-basic-005.png" alt="抱歉,图片休息了" title="git的帮助文档" width="600" height="160" align="center"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 互联网工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 札记：进阶</title>
      <link href="/2018/12/01/st-idea-advanced.html"/>
      <url>/2018/12/01/st-idea-advanced.html</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA-札记：进阶"><a href="#IDEA-札记：进阶" class="headerlink" title="IDEA 札记：进阶"></a>IDEA 札记：进阶</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%BE%E7%BD%AE%E4%BB%8B%E7%BB%8D">快捷键设置介绍</a></li><li><a href="#%E9%AB%98%E6%95%88%E7%8E%87%E7%BC%96%E7%A0%81%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D">高效率编码功能介绍</a></li><li><a href="#%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%E3%80%81%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8D">插件推荐、开发介绍</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对IDEA进一步的了解及使用。</p><h2 id="快捷键常用设置"><a href="#快捷键常用设置" class="headerlink" title="快捷键常用设置"></a>快捷键常用设置</h2><ul><li><code>设置为 Eclipse 的快捷键</code>  <pre><code class="hljs plaintext">1.Keymap下拉框选中&quot;Eclipse&quot;并应用2.如需在此快捷键模板上修改,则点击旁边齿轮-&gt;Duplicate来拷贝一份模板,并输入自己的命名</code></pre></li><li><code>筛选并修改快捷键</code>  <pre><code class="hljs plaintext">1.在搜索框输入快捷键描述内容2.点击搜索框旁边图标并按下需要修改的快捷键-------------------------Add Keyboard Shortcut：用来添加新的纯键盘快捷键组合Add Mouse Shortcut：用来添加新的键盘+鼠标快捷键组合，比如设置Ctrl+左键单击这类快捷组合。其中在弹出的添加面板中Click Pad是用来监听当前鼠标是左键单击还是右键单击Add Abbreviation：根据IDEA的版本文档解释，添加简称主要是为了方便Search Everywhere中使用我设置的简称搜索Remove：移出当前操作命令(一个操作命令同时支持多个快捷键组合)已设置的快捷键组合，由于IDEA默认就占用了很多快捷键组合，所以如果你要修改某个快捷键，建议还是删除掉旧的</code></pre></li><li><code>导入已有的快捷键模板</code>  <pre><code class="hljs plaintext">File–&gt;import setttings–&gt;选中本地的快捷键jar文件–&gt;一路确认–&gt;重启。IDEA默认快捷键的配置文件所在地：$&#123;IDEA_home&#125;\lib\resources.jar\keymaps\*</code></pre></li></ul><h2 id="常用快捷键-Eclipse-版"><a href="#常用快捷键-Eclipse-版" class="headerlink" title="常用快捷键(Eclipse 版)"></a>常用快捷键(Eclipse 版)</h2><h3 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a><em><strong>Ctrl</strong></em></h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>F</kbd></td><td align="left">在当前文件进行文本替换 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Z/Y</kbd></td><td align="left">撤销/反撤销 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>X/C/V/A/S</kbd></td><td align="left">剪切/复制/粘贴/全选/保存 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>D</kbd></td><td align="left">删除光标所在行或选中行 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>/</kbd></td><td align="left">单行注释 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>O</kbd></td><td align="left">查看当前类的结构 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>H/R</kbd></td><td align="left">查找/替换(全局) <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>E</kbd></td><td align="left">显示最近打开的文件记录列表 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>W</kbd></td><td align="left">关闭当前打开的代码栏 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>L</kbd></td><td align="left">在当前文件跳转到指定行处 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Up/Down</kbd></td><td align="left">等效于鼠标滚轮向前/后效果 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Left/Right</kbd></td><td align="left">光标跳转到当前单词/中文名的左/右侧开头位置 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>T</kbd></td><td align="left">在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>F12</kbd></td><td align="left">调转到所选中的词的下一个引用位置</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>F1</kbd></td><td align="left">在光标所在的错误代码处显示错误信息</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>J</kbd></td><td align="left">插入自定义动态代码模板</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>U</kbd></td><td align="left">前往当前光标所在的方法的父类的方法/接口定义</td></tr></tbody></table><h3 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a><em><strong>Alt</strong></em></h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><kbd>Alt</kbd> + <kbd>Insert</kbd></td><td align="left">新建文件 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>Enter</kbd></td><td align="left">万能解错/生成返回值变量 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>/</kbd></td><td align="left">提示补全 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>Up/Down</kbd></td><td align="left">向上/下移动行/方法 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>Left/Right</kbd></td><td align="left">退回/前进到上一个/下一个操作的页面 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>R/D</kbd></td><td align="left">在执行/调试 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>1,2,...,9</kbd></td><td align="left">显示对应数值的他选项卡,其中1是Project用得最多 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>F12</kbd></td><td align="left">在项目下打开命令行 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>F1</kbd></td><td align="left">显示当前文件选择目标弹出层,弹出层中有很多目标可以进行选择 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>`</kbd></td><td align="left">显示版本控制常用操作菜单弹出层 <code>（必备）</code></td></tr></tbody></table><h3 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a><em><strong>Shift</strong></em></h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><kbd>Shift</kbd> + <kbd>Enter</kbd></td><td align="left">向下开始新的一行 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Shift</kbd> + <kbd>Tab</kbd></td><td align="left">取消缩进 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Shift</kbd> + <kbd>F11</kbd></td><td align="left">弹出书签显示层 <code>（必备）</code></td></tr></tbody></table><h3 id="Ctrl-Alt"><a href="#Ctrl-Alt" class="headerlink" title="Ctrl + Alt"></a><em><strong>Ctrl + Alt</strong></em></h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>S</kbd></td><td align="left">打开idea系统设置 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>Down</kbd></td><td align="left">向下复制一行 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>F</kbd></td><td align="left">添加到收藏 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>Left/Right</kbd></td><td align="left">切换当前已打开的窗口中的子视图,如debug窗口中有output,debugger等子视图</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>H</kbd></td><td align="left">查看方法的多层重写结构</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>/</kbd></td><td align="left">方法参数提示显示</td></tr></tbody></table><h3 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl + Shift"></a><em><strong>Ctrl + Shift</strong></em></h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>/</kbd></td><td align="left">多行注释 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>I</kbd></td><td align="left">在 Debug 的状态下，选中对象，可快速查看该输入内容的调试结果 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Enter</kbd></td><td align="left">向上开始新的一行 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>F</kbd></td><td align="left">格式化代码 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd></td><td align="left">优化导入的类 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Y</kbd></td><td align="left">大写转小写&#x2F;小写转大写 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd></td><td align="left">根据输入的类名查找类文件 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>R</kbd></td><td align="left">根据输入的文件名打开文件&#x2F;目录,打开目录需在末尾多加一个正斜杠 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Up/Down</kbd></td><td align="left">当前光标跳转到当前文件的前&#x2F;后一个方法名位置 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>F12</kbd></td><td align="left">编辑器最大化 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd></td><td align="left">查找方法在哪里被调用 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>V</kbd></td><td align="left">选择要粘贴的内容</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Q</kbd></td><td align="left">快速搜索类中的错误</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>W</kbd></td><td align="left">关闭打开的所有代码栏</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd></td><td align="left">查看类的继承结构图</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>X</kbd></td><td align="left">打开代码所在硬盘文件夹</td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd></td><td align="left">复制当前文件磁盘路径到剪切板</td></tr></tbody></table><h3 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt + Shift"></a><em><strong>Alt + Shift</strong></em></h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>Up/Down</kbd></td><td align="left">递进式(取消)选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展(取消)选中范围<code>（必备）</code></td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>S</kbd></td><td align="left">生成构造器&#x2F;get&#x2F;set&#x2F;toString <code>（必备）</code></td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>Z</kbd></td><td align="left">生成 try-catch 等 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>C/X</kbd></td><td align="left">收起&#x2F;打开所有的方法 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>R</kbd></td><td align="left">重构(修改变量名与方法名) <code>（必备）</code></td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>M</kbd></td><td align="left">抽取方法</td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>F</kbd></td><td align="left">局部变量抽取为成员变量</td></tr><tr><td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>N</kbd></td><td align="left">选择&#x2F;添加 task</td></tr></tbody></table><h3 id="Ctrl-Shift-Alt"><a href="#Ctrl-Shift-Alt" class="headerlink" title="Ctrl + Shift + Alt"></a><em><strong>Ctrl + Shift + Alt</strong></em></h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Alt</kbd> + <kbd>S</kbd></td><td align="left">打开当前项目设置 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Alt</kbd> + <kbd>V</kbd></td><td align="left">无格式黏贴</td></tr></tbody></table><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><em><strong>其他</strong></em></h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><kbd>Dobule Shift</kbd></td><td align="left">查找文件 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Esc</kbd></td><td align="left">从工具窗口进入代码文件窗口 <code>（必备）</code></td></tr><tr><td align="left"><kbd>Tab</kbd></td><td align="left">缩进 <code>（必备）</code></td></tr><tr><td align="left"><kbd>F3</kbd></td><td align="left">进入光标所在的方法&#x2F;变量的接口或是定义处,等效于ctrl+左键单击 <code>（必备）</code></td></tr><tr><td align="left"><kbd>F11</kbd></td><td align="left">添加书签 <code>（必备）</code></td></tr><tr><td align="left"><kbd>F2</kbd></td><td align="left">光标所在的变量&#x2F;类名&#x2F;方法名等上面显示文档内容</td></tr><tr><td align="left"><kbd>F4</kbd></td><td align="left">查看继承关系</td></tr></tbody></table><h2 id="高效率编码功能介绍"><a href="#高效率编码功能介绍" class="headerlink" title="高效率编码功能介绍"></a>高效率编码功能介绍</h2><h3 id="Maven-配置"><a href="#Maven-配置" class="headerlink" title="Maven 配置"></a><code>Maven 配置</code></h3><ul><li>Maven 常用设置(<code>同时在Other Settings中进行默认设置</code>)<br>  <img src="/2018/12/01/st-idea-advanced/st-idea-advanced-001.png" alt="抱歉,图片休息了"><br>  <img src="/2018/12/01/st-idea-advanced/st-idea-advanced-002.png" alt="抱歉,图片休息了"></li><li>Maven 骨架创建 JavaWeb 项目(<code>创建普通maven项目时不用选择quickstart,默认就行</code>)<br>  <img src="/2018/12/01/st-idea-advanced/st-idea-advanced-003.png" alt="抱歉,图片休息了"></li><li>Maven 组件界面介绍<br>  <img src="/2018/12/01/st-idea-advanced/st-idea-advanced-004.png" alt="抱歉,图片休息了"></li></ul><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a><code>版本控制</code></h3><ul><li>IDEA 对版本控制的支持是以插件化的方式实现的，旗舰版默认支持目前主流的版本控制软件：CVS、SVN、Git、Mercurial、Perforce、TFS。<br>又因为目前太多人使用 Github 进行协同或是项目版本管理，同时自带了 Github 插件，方便 Checkout 和管理你的 Github 项目，  <pre><code class="hljs plaintext">Background：后台进程处理Confirmation：弹窗提示,是否提交,mergeIssue Navigation：问题导航GitHub：github配置CVS：cvs配置Subversion：svn配置TFS：工作流引擎管理</code></pre></li><li>常用设置  <pre><code class="hljs plaintext">1. 设置子目录有文件被修改了，则该文件的所有上层目录都显示版本控制被修改的颜色    Version Control,勾选&#x27;Show directories with changed descendants&#x27;,默认是不勾选的2. 设置新建或者删除文件时Git做默认如何处理    Version Control-&gt;Confirmation,修改&#x27;When files are created&#x27;和&#x27;When files are deleted&#x27;3. 设置忽略文件    Version Control-&gt;Ignored Files,添加不想加入到版本控制的文件和目录.对于已经加入到版本控制的文件使用此功能，则表示该文件或目录无法再使用版本控制相关的操作，比如提交、更新等4. 关联本地git.exe    Version Control-&gt;Git,在Path to Git executable中选择5. 关联GitHub账户    Version Control-&gt;GitHub,选择&quot;+&quot;号关联6. 支持从当前登陆的GitHub账号上直接Clone项目到本地    VCS-&gt;Checkout from Version Control-&gt;Git    File-&gt;New-&gt;Project from Version Control-&gt;Git7. 支持将本地项目分享到你的GitHub账号上    VCS-&gt;Import into Version Control-&gt;Share Project On GitHub    此时会在GitHub上创建一个新的仓库，而非更新已经存在的仓库,默认采用https方式传输8. Commit Changes弹窗介绍    Before Commit：        Reformat code：格式化代码，如果是Web开发建议不要勾选，因为格式化JSP类文件，格式化效果不好。如果都是Java类则可以安心格式化        Rearrange code：重新编排代码，IDEA支持各种复杂的编排设置选项        Optimize imports：优化导入包，会自动去掉没有使用的包。这个建议都勾选，因其只对Java类有作用，所以不用担心有副作用        Perform code analysis：进行代码分析，这个建议不用在提交的时候处理，而是在开发完之后，要专门养成对代码进行分析的习惯。IDEA 集成了代码分析功能        Check TODO：检查代码中的TODO。记录待办事项        Cleanup：清除下版本控制系统，去掉一些版本控制系统的错误信息，建议勾选（主要针对 SVN，Git 不适用）    标识着不同颜色的文件：        红色：未被版本控制的文件，即未添加到版本控制的文件，例如我们添加到ignore中的文件        绿色：新加入版本的文件，即我们新创建的文件，还未提交到远程仓库        蓝色：修改过的文件，即远程仓库中已有该文件，我们这次对它进行了修改，但是还未提交9. 点击界面右下角位置可以切换分支和创建分支，以及合并、删除分支等操作</code></pre></li></ul><h3 id="Debug-技巧"><a href="#Debug-技巧" class="headerlink" title="Debug 技巧"></a><code>Debug 技巧</code></h3><ul><li>Debug 设置  <pre><code class="hljs plaintext">Settings-&gt;Build,Execution,Deployment-&gt;Debugger,Transport选中Shared memory表示设置Debug连接方式，默认是Socket。Shared memory是Windows特有的一个属性，一般在Windows系统下建议使用此设置，相对于Socket会快</code></pre></li><li>Debug 常用快捷键  <pre><code class="hljs plaintext">Step Over(F6)：进入下一步，如果当前行断点是一个方法，则不进入当前方法体内Step Into(F5)：进入下一步，如果当前行断点是一个方法，则进入当前方法体内(自定义方法)Force Step Into(Alt+Shift+F7)：进入下一步，如果当前行断点是一个方法，则进入当前方法体内(所有方法,包括JDK库)Step Out(F7)：跳出Drop Frame：该按钮可以用来退回到当前停住的断点的上一层方法上，可以让过掉的断点重新来过Evaluate Expression(Ctrl+U)：选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果Resume Program(F8)：恢复程序运行，但如果该断点下面代码还有断点则停在下一个断点上Stop：停止View Breakpoints：查看所有断点Mute Breakpoints：点中，使得所有的断点失效Restore Layout：窗口还原</code></pre></li><li>Debug 其他用法  <pre><code class="hljs plaintext">条件断点：调试的时候，在循环里增加条件判断，可以极大的提高效率，心情也能愉悦在断点处右击调出条件断点。可以在满足某个条件下，实施断点。</code></pre></li></ul><h3 id="实时代码模板"><a href="#实时代码模板" class="headerlink" title="实时代码模板"></a><code>实时代码模板</code></h3><ul><li>功能介绍<ul><li>它的原理就是配置一些常用代码字母缩写，在输入简写时可以出现你预定义的固定模式的代码，使得开发效率大大提高，同时也可以增加个性化。最简单的例子就是在 Java 中输入 sout 会出现 System.out.println()。</li><li>官方介绍 Live Templates：<a href="https://www.jetbrains.com/help/idea/using-live-templates.html">https://www.jetbrains.com/help/idea/using-live-templates.html</a></li></ul></li><li>已有的常用模板<ul><li>所处位置： Settings-&gt;Editor-&gt;General-&gt;Postfix Completion | Editor-&gt;Live Templates<ul><li>二者的区别：Live Templates 可以自定义，而 Postfix Completion 不可以。同时，有些操作二者都提供了模板，Postfix Templates较Live Templates 能快 0.01 秒</li></ul></li><li>举例  <pre><code class="hljs plaintext">        psvm : 可生成main方法        sout : 快捷输出System.out.println()            soutp =&gt; System.out.println(&quot;方法形参名 = &quot; + 形参名);             soutm =&gt; System.out.println(&quot;当前类名.当前方法&quot;);            soutv =&gt; System.out.println(&quot;变量名 = &quot; + 变量);             &quot;abc&quot;.sout =&gt; System.out.println(&quot;abc&quot;);        fori : 可生成普通for循环            iter =&gt; 可生成增强for循环            itar =&gt; 可生成普通for循环并赋值        list.for : 可生成list集合的增强for循环            list.fori =&gt; 可生成list集合的普通for循环            list.forr =&gt; 可生成list集合的普通for循环(倒序)        ifn：可生成if(xxx = null)            inn =&gt; 可生成if(xxx != null)            xxx.nn或xxx.null  (Postfix Completion)        prsf：可生成private static final            psf =&gt; 可生成public static final            psfi =&gt; 可生成public static final int            psfs =&gt; 可生成public static final String        ```- 修改现有模板    - 如果对于现有的模板，感觉不习惯、不适应的，可以修改。    - 举例</code></pre>  修改Abbreviation：<br>  Settings-&gt;Editor-&gt;Live Templates,定位到other-&gt;psvm,将Abbreviation值改为main<br>  修改Template text：<br>  Settings-&gt;Editor-&gt;Live Templates,定位到plain-&gt;psfi,将Template text值改为public static final int $VAR1$ &#x3D; $VAR2$;$END$  <pre><code class="hljs plaintext">- 自定义模板    - IDEA 提供了很多现成的 Templates,但你也可以根据自己的需要创建新的 Template。</code></pre></li></ul><ol><li>定义一个模板组<br> Settings-&gt;Editor-&gt;Live Templates,点击”+”号,选择Template Group…,</li><li>选中自定义的模板组，点击”+”来定义模板<br> Settings-&gt;Editor-&gt;Live Templates,点击”+”号,选择Live Template,</li><li><h2 id="填写模板的内容-Abbreviation：模板的缩略名-Description：模板的描述-Template-text：模板的代码片段-应用范围：比如点击Define-选择java-Edit-variables：https-www-jetbrains-com-help-idea-template-variables-html-Database-”-”-Data-Source-MySQL-填写相关信息-3：同步当前数据库连接。这个是最重要的操作，有一些情况下，当我们配置好连接之后，没有显示数据表，那就是需要点击该按钮进行同步。还有一种情况就是我们在IDEA之外用其他工具操作数据库，比如新建表。而此时IDEA的-Database如果没有同步到新表，也是需要点击此按钮进行同步的-4：配置当前连接，跟我们首次设置连接的界面是一样的-5：断开当前的连接-6：显示相应数据库对象的数据-7：编辑修改当前数据库对象-All-plugins：显示所有插件-Enabled：显示当前所有已经启用的插件-Disabled：显示当前所有已经禁用的插件-Bundled：显示所有IDEA自带的插件-Custom：显示所有我们自行安装的插件，如果你自己装了很多次插件的话，这个选项会用得比较多-Material-Theme-UI-Power-Mode-II：activate-power-mode-Background-Image-Plus-Nyan-Progress-Bar-Gitee-NodeJS-Lombok-Alibaba-Java-Coding-Guidelines：阿里巴巴出的代码规范检查插件-JRebel-for-IntelliJ：热部署-Translation：翻译插件-Maven-Helper：Maven辅助插件-MybatisX：mybatis框架辅助（免费）-Lombok-Plugin：Lombok-功能辅助插件-Git-Flow-Integration：Git-Flow的图形界面操作-ignore：各类版本控制忽略文件生成工具-GenerateAllSetter：new-POJO类的快速生成set方法-GsonFormat：把JSON字符串直接实例化成类-Rainbow-Brackets：对各个对称括号进行着色，方便查看-String-Manipulation：驼峰式命名和下划线命名交替变化"><a href="#填写模板的内容-Abbreviation：模板的缩略名-Description：模板的描述-Template-text：模板的代码片段-应用范围：比如点击Define-选择java-Edit-variables：https-www-jetbrains-com-help-idea-template-variables-html-Database-”-”-Data-Source-MySQL-填写相关信息-3：同步当前数据库连接。这个是最重要的操作，有一些情况下，当我们配置好连接之后，没有显示数据表，那就是需要点击该按钮进行同步。还有一种情况就是我们在IDEA之外用其他工具操作数据库，比如新建表。而此时IDEA的-Database如果没有同步到新表，也是需要点击此按钮进行同步的-4：配置当前连接，跟我们首次设置连接的界面是一样的-5：断开当前的连接-6：显示相应数据库对象的数据-7：编辑修改当前数据库对象-All-plugins：显示所有插件-Enabled：显示当前所有已经启用的插件-Disabled：显示当前所有已经禁用的插件-Bundled：显示所有IDEA自带的插件-Custom：显示所有我们自行安装的插件，如果你自己装了很多次插件的话，这个选项会用得比较多-Material-Theme-UI-Power-Mode-II：activate-power-mode-Background-Image-Plus-Nyan-Progress-Bar-Gitee-NodeJS-Lombok-Alibaba-Java-Coding-Guidelines：阿里巴巴出的代码规范检查插件-JRebel-for-IntelliJ：热部署-Translation：翻译插件-Maven-Helper：Maven辅助插件-MybatisX：mybatis框架辅助（免费）-Lombok-Plugin：Lombok-功能辅助插件-Git-Flow-Integration：Git-Flow的图形界面操作-ignore：各类版本控制忽略文件生成工具-GenerateAllSetter：new-POJO类的快速生成set方法-GsonFormat：把JSON字符串直接实例化成类-Rainbow-Brackets：对各个对称括号进行着色，方便查看-String-Manipulation：驼峰式命名和下划线命名交替变化" class="headerlink" title="填写模板的内容 Abbreviation：模板的缩略名 Description：模板的描述 Template text：模板的代码片段 应用范围：比如点击Define,选择java Edit variables：https://www.jetbrains.com/help/idea/template-variables.html    Database-&gt;”+”-&gt;Data Source-&gt;MySQL,填写相关信息    3：同步当前数据库连接。这个是最重要的操作，有一些情况下，当我们配置好连接之后，没有显示数据表，那就是需要点击该按钮进行同步。还有一种情况就是我们在IDEA之外用其他工具操作数据库，比如新建表。而此时IDEA的 Database如果没有同步到新表，也是需要点击此按钮进行同步的  4：配置当前连接，跟我们首次设置连接的界面是一样的  5：断开当前的连接  6：显示相应数据库对象的数据  7：编辑修改当前数据库对象   All plugins：显示所有插件 Enabled：显示当前所有已经启用的插件 Disabled：显示当前所有已经禁用的插件 Bundled：显示所有IDEA自带的插件 Custom：显示所有我们自行安装的插件，如果你自己装了很多次插件的话，这个选项会用得比较多  Material Theme UI Power Mode II：activate-power-mode Background Image Plus Nyan Progress Bar Gitee NodeJS Lombok Alibaba Java Coding Guidelines：阿里巴巴出的代码规范检查插件 JRebel for IntelliJ：热部署  Translation：翻译插件 Maven Helper：Maven辅助插件 MybatisX：mybatis框架辅助（免费） Lombok Plugin：Lombok 功能辅助插件 Git Flow Integration：Git Flow的图形界面操作 .ignore：各类版本控制忽略文件生成工具 GenerateAllSetter：new POJO类的快速生成set方法 GsonFormat：把JSON字符串直接实例化成类 Rainbow Brackets：对各个对称括号进行着色，方便查看 String Manipulation：驼峰式命名和下划线命名交替变化"></a>填写模板的内容<br> Abbreviation：模板的缩略名<br> Description：模板的描述<br> Template text：模板的代码片段<br> 应用范围：比如点击Define,选择java<br> Edit variables：<a href="https://www.jetbrains.com/help/idea/template-variables.html">https://www.jetbrains.com/help/idea/template-variables.html</a><br>  <pre><code class="hljs plaintext">### `数据库管理工具`- IDEA 的 Database 最大特性就是对于 JavaWeb 项目来讲,对常用的 ORM 框架有很好的支持,比如配置好了 Database 之后，IDEA 会自动识别 domain 对象与数据表的关系，也可以通过 Database 的数据表直接生成 domain 对象等等。- 关联方式</code></pre><br>  Database-&gt;”+”-&gt;Data Source-&gt;MySQL,填写相关信息<br>  <pre><code class="hljs plaintext">- 常用操作</code></pre><br>  3：同步当前数据库连接。这个是最重要的操作，有一些情况下，当我们配置好连接之后，没有显示数据表，那就是需要点击该按钮进行同步。还有一种情况就是我们在IDEA之外用其他工具操作数据库，比如新建表。而此时IDEA的 Database如果没有同步到新表，也是需要点击此按钮进行同步的<br>  4：配置当前连接，跟我们首次设置连接的界面是一样的<br>  5：断开当前的连接<br>  6：显示相应数据库对象的数据<br>  7：编辑修改当前数据库对象<br>  <pre><code class="hljs plaintext">## 插件推荐、开发介绍- 插件设置    - IDEA 对插件进行了很好的分类：启用的插件是被勾选的，如果要禁用一个插件，去掉勾选即可</code></pre><br> All plugins：显示所有插件<br> Enabled：显示当前所有已经启用的插件<br> Disabled：显示当前所有已经禁用的插件<br> Bundled：显示所有IDEA自带的插件<br> Custom：显示所有我们自行安装的插件，如果你自己装了很多次插件的话，这个选项会用得比较多<br> <pre><code class="hljs plaintext">    - Install JetBrains plugin...：弹出IDEA公司自行开发的插件仓库列表，供下载安装    - Browse repositories...：弹出插件仓库中所有插件列表供下载安装    - Install plugin from disk...：浏览本地的插件文件进行安装，而不是从服务器上下载并安装        Tips：在国内的网络下，很经常出现显示不了插件列表，或是显示了插件列表，无法下载完成安装。这时候请自行开 VPN，一般都可以得到解决- 插件推荐    - 官方插件库：&lt;https://plugins.jetbrains.com&gt;    - 在用插件</code></pre><br> Material Theme UI<br> Power Mode II：activate-power-mode<br> Background Image Plus<br> Nyan Progress Bar<br> Gitee<br> NodeJS<br> Lombok<br> Alibaba Java Coding Guidelines：阿里巴巴出的代码规范检查插件<br> JRebel for IntelliJ：热部署<br> <pre><code class="hljs plaintext">- 备用插件</code></pre><br> Translation：翻译插件<br> Maven Helper：Maven辅助插件<br> MybatisX：mybatis框架辅助（免费）<br> Lombok Plugin：Lombok 功能辅助插件<br> Git Flow Integration：Git Flow的图形界面操作<br> .ignore：各类版本控制忽略文件生成工具<br> GenerateAllSetter：new POJO类的快速生成set方法<br> GsonFormat：把JSON字符串直接实例化成类<br> Rainbow Brackets：对各个对称括号进行着色，方便查看<br> String Manipulation：驼峰式命名和下划线命名交替变化</h2> IDE Features Trainer：IDEA官方出的学习辅助插件<br> Key promoter：快捷键提示<br> Grep Console：自定义设置控制台输出<br> CheckStyle-IDEA：代码规范检查<br> FindBugs-IDEA：潜在Bug检查<br> MetricsReloaded：代码复杂度检查<br> Statistic：代码统计<br> CodeGlance：在编辑代码最右侧，显示一块代码小地图<br> Markdown Navigator：书写Markdown文章<br> Eclipse Code Formatter：使用 Eclipse 的代码格式化风格，在一个团队中如果公司有规定格式化风格，这个可以使用<br> Jindent-Source Code Formatter：自定义类、方法、doc、变量注释模板<br> Properties to YAML Converter：把Properties的配置格式改为YAML格式<br> mongo4idea：mongo客户端<br> iedis：redis客户端<br> VisualVM Launcher：项目启动的时候也启动VisualVM<pre><code></code></pre></li></ol></li><li>Java 热部署插件 JRebel 安装及使用</li><li>插件开发</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial">https://github.com/judasn/IntelliJ-IDEA-Tutorial</a></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jetbrains </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 札记：基础</title>
      <link href="/2018/12/01/st-idea-basic.html"/>
      <url>/2018/12/01/st-idea-basic.html</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA-札记：基础"><a href="#IDEA-札记：基础" class="headerlink" title="IDEA 札记：基础"></a>IDEA 札记：基础</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%AE%89%E8%A3%85%E3%80%81%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E4%BB%8B%E7%BB%8D">安装、基础环境介绍</a></li><li><a href="#%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8">开始使用</a></li><li><a href="#%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE%E4%BB%8B%E7%BB%8D">常用设置介绍</a></li><li><a href="#%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AE%E4%BB%8B%E7%BB%8D">其他设置介绍</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><code>JetBrains 公司介绍</code><ul><li>维基百科：<blockquote><p>JetBrains 是一家<strong>捷克</strong>的软件开发公司，该公司位于捷克的布拉格，并在俄罗斯的圣彼得堡及美国麻州波士顿都设有办公室，该公司最为人所熟知的产品是 Java 编程语言开发撰写时所用的集成开发环境：IntelliJ IDEA。</p></blockquote><blockquote><p>JetBrains 成立于 2000 年，是一家<strong>私人持股</strong>的公司，该公司的合伙创办人有：Sergey Dmitriev、Eugene Belyaev 及 Valentin Kipiatkov。</p></blockquote><blockquote><p>截至 2017 年 6 月，该公司共发布了 24 款开发工具与及相关产品。</p></blockquote></li><li>JetBrains 公司旗下其他产品，包括集成开发环境、插件、编程语言、团队工具、其他等等。  <pre><code class="hljs plaintext">PhpStorm：主要用于开发PHPRubyMine：主要用于开发Ruby/RailsPyCharm：主要用于开发PythonAppCode：主要用于开发Objective-C/Swift,xcode的替代者CLion：主要用于开发C/C++WebStorm：主要用于开发JavaScript、HTML5、CSS3等前端技术DataGrip：主要用于开发数据库和SQLRider：主要用于开发.NETGoLand：主要用于开发Go(区块链等)Android Studio：主要用于开发Android（Google基于IntelliJ IDEA社区版进行迭代所以也姑且算上）</code></pre></li></ul></li><li><code>Intellij IDEA 介绍</code><ul><li><p>官网：<a href="https://www.jetbrains.com/idea/">https://www.jetbrains.com/idea/</a></p></li><li><p>新特性列表：<a href="https://www.jetbrains.com/idea/whatsnew">https://www.jetbrains.com/idea/whatsnew</a></p></li><li><p>详细使用文档：<a href="https://www.jetbrains.com/help/idea/meet-intellij-idea.html">https://www.jetbrains.com/help/idea/meet-intellij-idea.html</a></p></li><li><p>IntelliJ IDEA 在 2015 年 06 月官网主页是这样介绍自己的：</p><blockquote><p>Excel at enterprise, mobile and web development with Java, Scala and Groovy, with all the latest modern technologies and frameworks available out of the box.</p></blockquote><blockquote><p>简明翻译：IntelliJ IDEA主要用于支持Java、Scala、Groovy 等语言的开发工具，同时具备支持目前主流的技术和框架，擅长于企业应用、移动应用和Web应用的开发。  </p></blockquote></li><li><p>如果用一句话来形容 IntelliJ IDEA，我会说：<em><strong>IntelliJ IDEA 是目前所有 IDE 中最具备沉浸式的 JVM IDE，没有之一。</strong></em></p></li></ul></li><li><code>IDEA 主要功能介绍</code></li></ul><table><thead><tr><th align="center">安装插件后支持</th><th align="center">SQL 类</th><th align="center">基本JVM</th></tr></thead><tbody><tr><td align="center">PHP</td><td align="center">PostgreSQL</td><td align="center">Java</td></tr><tr><td align="center">Python</td><td align="center">MySQL</td><td align="center">Groovy</td></tr><tr><td align="center">Ruby</td><td align="center">Oracel</td><td align="center"></td></tr><tr><td align="center">Scala</td><td align="center">SQL Server</td><td align="center"></td></tr><tr><td align="center">Kotlin</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Clojure</td><td align="center"></td><td align="center"></td></tr></tbody></table><table><thead><tr><th align="center">支持的框架</th><th align="center">额外支持的语言代码提示</th><th align="center">支持的容器</th></tr></thead><tbody><tr><td align="center">Spring MVC</td><td align="center">HTML5</td><td align="center">Tomcat</td></tr><tr><td align="center">GWT</td><td align="center">CSS3</td><td align="center">TomEE</td></tr><tr><td align="center">Vaadin</td><td align="center">SASS</td><td align="center">WebLogic</td></tr><tr><td align="center">Play</td><td align="center">LESS</td><td align="center">JBoss</td></tr><tr><td align="center">Grails</td><td align="center">JavaScript</td><td align="center">Jetty</td></tr><tr><td align="center">Web Services</td><td align="center">CoffeeScript</td><td align="center">WebSphere</td></tr><tr><td align="center">JSF</td><td align="center">Node.js</td><td align="center"></td></tr><tr><td align="center">Struts</td><td align="center">ActionScript</td><td align="center"></td></tr><tr><td align="center">Hibernate</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Flex</td><td align="center"></td><td align="center"></td></tr></tbody></table><ul><li><code>IDEA 主要优势(相较于 Eclipse 而言)</code><ul><li>强大的整合能力，例如 Git、Maven、Spring 等工具和框架。</li><li>提示功能的快速、便捷。</li><li>提示功能的范围广。</li><li>好用的快捷键和代码模板。</li><li>精准搜索。</li></ul></li></ul><h2 id="安装、基础环境介绍"><a href="#安装、基础环境介绍" class="headerlink" title="安装、基础环境介绍"></a>安装、基础环境介绍</h2><ul><li><code>Windows 下安装</code><ul><li>首次安装<ul><li>IDEA 的安装是非常简单的，不需要做过多的选择，可以说简单到都是 Next 即可。</li><li>中间会有个创建快捷图标，建议勾上，方便定位 IDEA 的安装目录；确让是否与 java,groovy,kt 文件关联,建议不勾选。</li></ul></li><li>已有旧版本安装新版本<ul><li>在小版本迭代中建议是卸载掉旧版本的，然后再进行新版本安装，因为小版本迭代一般都是 Bug 的修复，保留旧版本没有多大意义。</li><li>在大版本迭代中建议是保留旧版本，也就是不勾选之前版本，IDEA 是支持一台电脑装多个版本的。</li></ul></li><li>卸载<ul><li>有 2 个选项，1 是删除缓存和本地历史记录，2 是删除个性化设置和插件。</li></ul></li><li>安装总结<ul><li>从安装上来看，IDEA 对硬件的要求看上去不是很高，可是实际在开发中其实并不是这样的，因为 IDEA 执行时会有大量的缓存、索引文件。</li><li>如果你正在使用 Eclipse&#x2F;MyEclipse，想通过 IDEA 来解决计算机的卡、慢等问题，这基本上是不可能的，本质上你应该对自己的硬件设备进行升级。</li><li>安迪-比尔定律：IT界三大定律之一(摩尔定律、反摩尔定律、安迪-比尔定律)。</li></ul></li></ul></li><li><code>安装目录介绍</code>  <pre><code class="hljs plaintext">bin：执行文件和启动参数等  idea.exe：32位IDEA的启动文件，IDEA安装完默认发送到桌面的也就是这个执行文件的快捷方式  idea.exe.vmoptions：32位IDEA的VM配置文件  idea64.exe：64位IDEA的启动文件，要求必须电脑上装有JDK64位版本，64位的系统也是建议使用该文件  idea64.exe.vmoptions：64位IDEA的VM配置文件  idea.properties：IDEA的属性配置文件help：快捷键文档jre64：64位java运行环境lib：IDEA依赖的类库license：各个插件的许可信息plugin：插件</code></pre>  <pre><code class="hljs plaintext">可手动复制这2个文件到config根目录下再修改相关参数。idea64.exe.vmoptions：    -Xms128m：设置初始的内存数,增加该值可以提高java程序的启动速度(16G内存的机器可尝试设置为-Xms512m)    -Xmx750m：设置最大内存数,增加该值可以减少垃圾回收的频率,进而提高程序性能(16G内存的机器可尝试设置为-Xmx1500m)    -XX:ReservedCodeCacheSize=240m：设置保留代码占用的内存容量,增加该值可以减少没有用的代码被回收的频率,进而提高程序性能(16G内存的机器可尝试设置为-XX:ReservedCodeCacheSize=500m)idea.properties：    idea.config.path=$&#123;user.home&#125;/.IntelliJIdea/config：该属性主要用于指向IDEA的个性化配置目录，默认是被注释，这里需要特别注意的是斜杠方向，这里用的是正斜杠。    idea.system.path=$&#123;user.home&#125;/.IntelliJIdea/system：该属性主要用于指向IDEA的系统文件目录。如果你的项目很多，则该目录会很大，如果你的C盘空间不够的时候，还是建议把该目录转移到其他盘符下。    idea.max.intellisense.filesize=2500：该属性主要用于提高在编辑大文件时候的代码帮助。IDEA在编辑大文件的时候还是很容易卡顿的。    idea.cycle.buffer.size=1024：该属性主要用于控制控制台输出缓存。有遇到一些项目开启很多输出，控制台很快就被刷满了没办法再自动输出后面内容，这种项目建议增大该值或是直接禁用掉，禁用语句(=disabled)</code></pre>  Tips：<em><strong>强烈推荐使用 IDEA 菜单中的 <code>Help-&gt;Edit Custom VM Options</code>和<code>Help-&gt;Edit Custom Properties</code> 进行参数个性化配置；而不是直接修改安装目录中的该文件,因为 IDEA 升级&#x2F;重装后可能会导致修改完全失效！</strong></em>。</li><li><code>设置目录介绍</code><ul><li>IDEA 各种配置的保存目录。这个设置目录有一个特性，就是你<strong>删除掉整个目录之后，重新启动 IDEA 会再自动帮你生成一个全新的默认配置</strong>，所以很多时候如果你把 IDEA 配置改坏了，没关系，删掉该目录，一切都会还原到默认。</li><li>config<ul><li>IDEA 的个性化化配置目录，或者说是整个 IDE 设置目录，此目录可看成是最重要的目录，没有之一。安装新版本的 IDEA会 自动扫描硬盘上的旧配置目录，指的就是该目录。</li><li>这个目录主要记录了：<strong>IDE 主要配置功能、自定义的代码模板、自定义的文件模板、自定义的快捷键、Project 的 tasks 记录等等个性化的设置</strong>。</li></ul></li><li>system   <ul><li>IDEA 的系统文件目录，是 IDEA 与开发项目之间的一个桥梁目录。</li><li>这个目录主要记录了：<strong>缓存、索引、容器文件输出等等</strong>，虽然不是最重要目录，但是也是最不可或缺目录之一。</li></ul></li></ul></li><li><code>首次运行向导</code><ol><li>是否导入已有设置<ul><li>首次启动后，会弹出对话框，选择不导入已有的设置。</li></ul></li><li>激活</li><li>设置主题<ul><li>这里根据个人喜好进行选择，也可以选择跳过，后面在 settings 里也可以再设置主题等。</li></ul></li><li>设置插件<ul><li>设置 IDEA 中的各种工具&#x2F;插件，可以选择自定义设置、删除，或者安装本身不存在的插件（比如：支持 Scala 的插件），这里不设置，后面也可以通过界面菜单栏的 settings 行设置。</li></ul></li></ol></li></ul><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><ul><li><p><code>首次打开</code></p><ul><li>Create New Project：创建一个新的工程。</li><li>Import Project：导入一个现有的工程。<strong>适合导入本身不是idea工程</strong>(包括Eclipse工程，Maven项目，Gradle项目或者直接从源代码创建工程)。</li><li>Open：打开一个已有工程。<strong>适合打开本身是idea工程</strong>。</li><li>Check out from Version Control：可以通过服务器上的项目地址 Checkout GitHub 上面项目或其他 Git 托管服务器上的项目。</li></ul></li><li><p><code>设置显示常见的视图</code></p><ul><li>View-&gt;Toolbar或<strong>View-Appearance&gt;Toolbar</strong>，勾选工具条。</li><li>View-&gt;Tool Buttons或<strong>View-Appearance&gt;Tool Window Bars</strong>，勾选按钮组。</li></ul></li><li><p><code>创建工程</code></p><ul><li>创建 Java Project&#x2F;Module<ol><li>选择指定目录下的 JDK 作为 Project&#x2F;Module SDK。</li><li>可以勾选 <code>Create project from template</code> 根据模板快速创建项目，也可以不勾选手动创建。 <pre><code class="hljs plaintext">Command Line App：会自动创建一个带有main方法的类Java Hello World：会自动创建一个带有main方法的并且会打印输出Hello World的类</code></pre></li><li>在 <code>More Settings</code> 中,Project format(项目格式文件)主要提供两种方式。 <pre><code class="hljs plaintext">.idea (directory based)：创建项目的时候自动创建一个.idea的项目配置目录来保存项目的配置信息，这是默认选项.ipr (file based)：创建项目的时候自动创建一个.ipr的项目配置文件来保存项目的配置信息</code></pre></li></ol></li><li>创建静态 JavaWeb Project&#x2F;Module<ul><li>省略…</li></ul></li><li>创建动态 JavaWeb Project&#x2F;Module<ol><li>选择指定目录下的 JDK 作为Project&#x2F;Module SDK，同时勾选 <code>JaveEE-&gt;Web Application</code>。</li><li>配置 Tomcat <pre><code class="hljs plaintext">1.Run-&gt;Edit Configurations-&gt;&quot;+&quot;-&gt;Tomcat Server-&gt;Local2.Server    - 可配置应用服务器路径,VM参数,JRE,端口等        - On Update action：当我们按Ctrl + F10进行容器更新的时候，可以根据我们配置的这个事件内容进行容器更新。其中我选择的Update classes and resources事件是最常用的，表示我们在按Ctrl + F10进行容器更新的时候，我们触发更新编译的类和资源文件到容器中。在Debug模式下，这个也就是所谓的HotSwap。只是这种热部署没有JRebel插件那样好用        - On frame deactivation：当我们切换IDEA到浏览器的时候进行指定事件更新，这个一般是因为Web开发的时候，我们需要经常在IDEA和各个浏览器之间来回切换测试，所以才有了这种需求。IDEA是为了帮我们在做这种无聊切换的时候做一些指定事情。当然了，如果切换过于频繁，这个功能还是很耗资源的，所以我设置的是Do nothing表示切换的时候什么都不做3.Deployment- 添加要运行的项目及设置访问名称d.Logse.Code coveragef.Startup/Connection</code></pre></li></ol></li></ul></li><li><p><code>工程界面展示</code></p><ul><li>工程下的 src 类似于 Eclipse 下的 src 目录，用于存放代码。</li><li>工程下的 .idea(Project 的配置文件目录)和 .iml(Module 的配置文件)都是 IDEA 工程特有的，类似于 Eclipse 工程下的 .settings、.classpath、.project 等。</li></ul></li><li><p><code>创建 package 和 class</code></p><ul><li>在 src 目录下创建一个 package，接着在包下 new-class，可以直接创建 <code>Class、Interface、Enum、Annotation</code> 等常见类型文件。</li><li>然后在下拉框中选择创建的结构的类型，接着在类 HelloWorld 里声明主方法，输出 helloworld，完成测试。</li></ul><p>  Tips1：<strong>在没有文件的情况下包目录默认是连在一起的，不方便看目录层级关系,可点击 Project 窗口的齿轮处，在弹出的菜单中去掉 <code>Compact Empty Middle Packages</code><strong>。<br>  Tips2：</strong>IDEA 是一个没有 Ctrl + S 的 IDE，所以每次修改完代码只要管着运行或者调试即可，无需担心保存或者丢失代码。</strong></p></li><li><p><code>创建模块</code></p><ul><li>在 Eclipse 中有 Workspace(工作空间)和 Project(工程)的概念,在 IDEA 中只有 Project(工程)和 Module(模块)的概念。<ul><li><a href="https://www.jetbrains.com/help/idea/migrating-from-eclipse-to-intellij-idea.html">https://www.jetbrains.com/help/idea/migrating-from-eclipse-to-intellij-idea.html</a>  <pre><code class="hljs plaintext">IDEA 官网说明：An Eclipse workspace is similar to a project in IntelliJ IDEAAn Eclipse project maps to a module in IntelliJ IDEA翻译：Eclipse中workspace相当于IDEA中的ProjectEclipse中Project相当于IDEA中的Module</code></pre></li></ul></li><li>从 Eclipse 转过来的人总是下意识地要在同一个窗口管理 n 个项目，这在 IDEA 是无法做到的。IDEA 提供的解决方案是打开多个项目实例，即打开多个项目窗口(一个 Project 打开一个 Window 窗口)。</li><li>在 IDEA 中 Project 是最顶级的级别，次级别是 Module。即一个 Project 是由一个或多个 Module 组成。<ul><li>目前主流的大型项目都是分布式部署的，结构都是类似这种多 Module 结构。这类项目一般是这样划分的，比如：core Module、web Module、plugin Module、solr Module 等等，模块之间彼此可以相互依赖。</li><li>通过这些 Module 的命名也可以看出，他们之间都是处于同一个项目业务下的模块，彼此之间是有不可分割的业务关系的。</li></ul></li><li>相比较于多 Module 项目，小项目就无需搞得这么复杂。只有一个 Module 的结构 IDEA 也是支持的，并且 IDEA 创建项目的时候，默认就是单 Module 的结构的,此时 Project 目录和 Module 目录是同一个。</li></ul></li><li><p><code>删除模块</code></p><ol><li>选中相应的模块右键 <code>Open Module Setting</code>，点击减号，逻辑删除模块。</li><li>再次选中相应的模块右键 <code>Delete</code>，物理删除模块。</li></ol></li><li><p><code>查看/修改项目配置(File-&gt;Project Structure)</code></p><ul><li>Project  <pre><code class="hljs plaintext">Project name：项目名称Project SDK（Software Development Kit）：JDK配置点击&quot;Edit&quot;按钮,进入SDK的统一管理处,加号可以添加新SDK；减号可以删除光标所选的SDK在开发Java项目过程中，由于IDEA支持管理多个JDK，所以你完全不用担心你系统上不同项目需要不同JDKProject language level：编译级别限定项目编译检查时最低要求的JDK特性我们使用JDK8的时候，我们只能向下兼容JDK8及其以下的特性，所以只能选择8及其以下的language level。当项目使用的是JDK8，但是代码却最多使用了JDK7的特性的时候我们可以选择7 - Diamonds，ARM，multi-catch etcProject compiler output：class输出路径配置</code></pre></li><li>Modules  <pre><code class="hljs plaintext">Sources：可以针对Module选择其他language level，默认选择的是Project language levelSources：一般用于标注类似src这种可编译目录。有时候不单单项目的src目录要可编译，还有其他一些特别的目录也要作为可编译的目录，就需要对该目录进行此标注。只有Sources这种可编译目录才可以新建Java类和包Tests：一般用于标注可编译的单元测试目录。在规范的maven项目结构中，顶级目录是src，maven的src我们是不会设置为Sources的，而是在其子目录main目录下的java目录，我们会设置为Sources。而单元测试的目录是src-test-java，这里的java目录我们就会设置为Tests，表示该目录是作为可编译的单元测试目录。从这一点也可以看出IDEA对maven项目的支持是比较彻底的Resources：一般用于标注资源文件目录。在maven项目下，资源目录是单独划分出来的，其目录为：src-main-resources，这里的resources目录我们就会设置为Resources，表示该目录是作为资源目录。资源目录下的文件是会被编译到输出目录下的Test Resources：一般用于标注单元测试的资源文件目录。在maven项目下，单元测试的资源目录是单独划分出来的，其目录为：src-test-resources，这里的resources目录我们就会设置为Test Resources，表示该目录是作为单元测试的资源目录。资源目录下的文件是会被编译到输出目录下的Excluded：一般用于标注排除目录。被排除的目录不会被IDEA创建索引，相当于被IDEA废弃，该目录下的代码文件是不具备代码检查和智能提示等常规代码功能注：被标注的目录会在右侧有一个总的概括。值得一提的是classes虽然是Excluded目录，但是由于它的特殊性且不可编辑，所以不显示在这里注：如果要去掉目录的标注含义，可以点击打叉按钮进行删除Dependencies：可以针对Module选择其他SDK，默认选择的是Project SDK,以及管理项目的所有依赖包依赖包支持五种操作：加号，表示可以引入新依赖包减号，表示可以去除对应的依赖包向上箭头，表示依赖包可以向上移动位置。依赖包越上面的表示在项目加载的时候越是优先，所以对于同一个依赖包，不同版本，依赖顺序不同，结果也可能会是大不相同的向下箭头，表示依赖包可以向下移动位置，原因同上笔，表示可以编辑依赖包的名称和路径</code></pre></li><li>Libraries  <pre><code class="hljs plaintext">点击&quot;+&quot;号,如java可以把项目的lib作为一个总的依赖包放置到项目Libraries中,这样当我们项目需要添加新依赖包时，我们只要放置在lib目录下即可自动被项目引入，原因就是我们这里引的是目录，而不是一个一个依赖包</code></pre></li><li>Facets  <pre><code class="hljs plaintext">点击&quot;+&quot;号-,如web可以配置web.xml文件,其他框架配置文件也是如此</code></pre></li><li>Artifacts  <pre><code class="hljs plaintext">点击&quot;+&quot;号-,如Web Application:Exploded-&gt;From Modules...,修改Output directory输出目录,配置一个war包展开的输出结构</code></pre></li></ul></li></ul><h2 id="常用设置介绍"><a href="#常用设置介绍" class="headerlink" title="常用设置介绍"></a>常用设置介绍</h2><p>通过 <code>File-&gt;Settings</code> 或者 <code>Ctrl+Alt+S</code> 进入。</p><ul><li><code>Appearance &amp; Behavior(外观和行为)</code><ul><li><strong>设置主题</strong>  <pre><code class="hljs plaintext">Appearance,在&#x27;UI Options&#x27;中选择&#x27;Theme&#x27;的值</code></pre></li><li><strong>设置窗体及菜单的字体及字体大小</strong>  <pre><code class="hljs plaintext">Appearance,在&#x27;UI Options&#x27;中修改&#x27;Overrid default fonts by(not recommended)&#x27;的值</code></pre></li><li><strong>设置内存使用情况显示</strong>  <pre><code class="hljs plaintext">Appearance,在&#x27;Window Options&#x27;中勾选&#x27;Show memory indicator&#x27;    点击内存值后可以进行部分内存的回收</code></pre></li><li><strong>设置启动 IDEA 时可以选择最近打开的某个项目</strong>  <pre><code class="hljs plaintext">System Settings,在&#x27;Shartup/Shutdown&#x27;中选择&#x27;Confirm application exit&#x27;    启动IDEA时,默认会打开上次使用的项目,如果只有一个项目的话,该功能还是很好用的,如果有多个项目的话,建议可以选择最近打开的某个项目</code></pre></li><li><strong>设置另一个项目窗口的打开方式</strong>  <pre><code class="hljs plaintext">System Settings,在&#x27;Project Opening&#x27;中选择    Open project in new window 每次都使用新窗口打开    Open project in the same window 每次都替换当前已打开的项目，这样桌面上就只有一个项目窗口    Confirm window to open project in 每次都弹出提示窗口，让我们选择用新窗口打开或是替换当前项目窗口</code></pre></li><li><strong>设置取消更新</strong>  <pre><code class="hljs plaintext">System Settings-&gt;Updates,去掉&#x27;Automatically check updates for&#x27;选中</code></pre></li></ul></li><li><code>Keymap(快捷键)</code><ul><li><em><strong>详见高级篇</strong></em></li><li><strong>设置基础代码提示、补充快捷键生效</strong>  <pre><code class="hljs plaintext">搜索Basic,将Ctrl+空格改为Ctrl+,</code></pre></li></ul></li><li><h2 id="Editor-编辑器-设置鼠标滚轮控制代码字体大小-设置自动导包功能-设置显示行数及方法间的分隔线-设置显示空格和Tab-设置忽略代码提示区分大小写-设置取消单行显示-tabs-的操作-设置主题字体-设置-Java-代码的单行注释跟随在代码的头部-设置项目文件编码-设置鼠标悬浮提示-设置-Ctrl-E-弹出层显示最近文件的个数-设置指定代码类型进行默认折叠或是展开-设置打开的文件-Tab-个数-设置编辑区主题-修改代码中注释的字体颜色-Inspections-在’Java’-’Serialization’中勾选’Serializable-class-without-serialVersionUID’-在已经继承了Serializable接口的类名上，把光标放在类名上（必须这样做），按-Alt-Enter，即可提示帮你生成serialVersionUID功能-File-and-Code-Templates-在’Includes’中选择’File-Header’修改-Compiler-勾选’Build-project-automatically’和’Compile-indepent-modules-in-parallel’-——————————————-构建就是以我们编写的java代码、框架配置文件、国际化等其他资源文件、JSP-页面和图片等资源作为“原材料”，去“生产”出一个可以运行的项目的过程。-相比较于Eclipse的实时自动编译，IDEA的编译更加手动化-IDEA也支持通过设置开启实时编译，但是不建议，因为太占资源了-——————————————-编译方式介绍-3种-：-Recompile：对选定的目标（Java类文件），进行强制性编译，不管目标是否是被修改过。-Rebuild：对选定的目标（Project），进行强制性编译，不管目标是否是被修改过，由于Rebuild的目标是整个Project，所以Rebuild每次花的时间会比较长。-Build-使用最多的编译操作-：对选定的目标（Project或Module）进行编译，但只编译有修改过的文件，没有修改过的文件不会编译，这样平时开发大型项目才不会浪费时间在编译过程中。-——————————————-编译器的设置和选择：-Compiler下：设置编译heap大小，默认是700，建议使用64位的用户，在内存足够的情况下，建议改为1500-或以上。如果你在编译的时候出错，报：OutOfMemoryError，一般也是要来改这个地方-Compiler-Excludes下：开发过程中，某一个包目录的文件编译无法通过，但是我们又不急着改，那我们就可以考虑把该包加入到排除编译列表中，则项目就可以运行起来-Compiler-Java-Compiler下：IDEA支持常见的几种编译器：Javac、Eclipse、Ajc等。默认是Javac，也推荐使用Javac-Project-bytecode-version-针对项目字节码编译版本，一般选择的是当前项目主JDK的版本。-Per-module-bytecode-version-可以针对Project下各个Module的特殊需求单独设置不同的bytecode-version，前提是电脑上必须有安装对应的JDK版本。-1-配置服务器信息-Deployment-进行服务器信息的配置-包括服务器地址和权限认证-并且在Mapping选项卡完成本地工程与服务器路径的映射。-2-配置Maven打包插件-以SpringBoot应用为例-需要配置”spring-boot-maen-plugin”插件-这样执行”mvn-package”命令时-即可得到一个可运行的Jar。-3-部署Jar包-在”target”目录下找到上一步生成的可执行jar文件右键-依次找到”Deployment-Upload-to-XXX”-就可以上传到远程服务器上。-4-启动应用-在菜单栏”Tools-StartSSH-session”中开启远程服务器的终端-在IDEA下方可以执行远程指令。-也可以在”Tools-Deployment-Browse-Remote-Host”中可视化地浏览服务器上的文件列表-检查应用是否部署成功。-在远程终端中-找到对应的fatjar-执行”java-jar-xxx-jar”-便完成了整个部署流程。-可考虑别一种方案：阿里Cloud-Toolkit插件-Web-Browsers-在’Default-Browser’中选择’Custom-path’并选择程序路径-如果个人有专属的测试浏览器，希望默认从控制台输出的链接是用测试浏览器打开，就可以这样设置-Terminal-在’Application-settings’中将’Shell-path’设置成Git-Bash-可能会出现乱码-可修改Git的安装目录下的etc目录下bash-bashrc文件，在最后一行添加：-解决IDEA下的terminal中文Unicode编码问题-export-LANG-”zh-CN-UTF-8”-export-LC-ALL-”zh-CN-UTF-8”-File-Power-Save-Mode-开启这种模式之后IDEA会关掉代码检查和代码提示等功能。所以一般也可认为这是一种阅读模式，如果你在开发过程中遇到突然代码文件不能进行检查和提示，可以来看看这里是否有开启该功能。-File-Invalidate-Caches-Restart-一般建议点击’Invalidate-and-Restart’-这样会比较干净-本质也就是去删除C盘下的system目录下的对应的文件而已"><a href="#Editor-编辑器-设置鼠标滚轮控制代码字体大小-设置自动导包功能-设置显示行数及方法间的分隔线-设置显示空格和Tab-设置忽略代码提示区分大小写-设置取消单行显示-tabs-的操作-设置主题字体-设置-Java-代码的单行注释跟随在代码的头部-设置项目文件编码-设置鼠标悬浮提示-设置-Ctrl-E-弹出层显示最近文件的个数-设置指定代码类型进行默认折叠或是展开-设置打开的文件-Tab-个数-设置编辑区主题-修改代码中注释的字体颜色-Inspections-在’Java’-’Serialization’中勾选’Serializable-class-without-serialVersionUID’-在已经继承了Serializable接口的类名上，把光标放在类名上（必须这样做），按-Alt-Enter，即可提示帮你生成serialVersionUID功能-File-and-Code-Templates-在’Includes’中选择’File-Header’修改-Compiler-勾选’Build-project-automatically’和’Compile-indepent-modules-in-parallel’-——————————————-构建就是以我们编写的java代码、框架配置文件、国际化等其他资源文件、JSP-页面和图片等资源作为“原材料”，去“生产”出一个可以运行的项目的过程。-相比较于Eclipse的实时自动编译，IDEA的编译更加手动化-IDEA也支持通过设置开启实时编译，但是不建议，因为太占资源了-——————————————-编译方式介绍-3种-：-Recompile：对选定的目标（Java类文件），进行强制性编译，不管目标是否是被修改过。-Rebuild：对选定的目标（Project），进行强制性编译，不管目标是否是被修改过，由于Rebuild的目标是整个Project，所以Rebuild每次花的时间会比较长。-Build-使用最多的编译操作-：对选定的目标（Project或Module）进行编译，但只编译有修改过的文件，没有修改过的文件不会编译，这样平时开发大型项目才不会浪费时间在编译过程中。-——————————————-编译器的设置和选择：-Compiler下：设置编译heap大小，默认是700，建议使用64位的用户，在内存足够的情况下，建议改为1500-或以上。如果你在编译的时候出错，报：OutOfMemoryError，一般也是要来改这个地方-Compiler-Excludes下：开发过程中，某一个包目录的文件编译无法通过，但是我们又不急着改，那我们就可以考虑把该包加入到排除编译列表中，则项目就可以运行起来-Compiler-Java-Compiler下：IDEA支持常见的几种编译器：Javac、Eclipse、Ajc等。默认是Javac，也推荐使用Javac-Project-bytecode-version-针对项目字节码编译版本，一般选择的是当前项目主JDK的版本。-Per-module-bytecode-version-可以针对Project下各个Module的特殊需求单独设置不同的bytecode-version，前提是电脑上必须有安装对应的JDK版本。-1-配置服务器信息-Deployment-进行服务器信息的配置-包括服务器地址和权限认证-并且在Mapping选项卡完成本地工程与服务器路径的映射。-2-配置Maven打包插件-以SpringBoot应用为例-需要配置”spring-boot-maen-plugin”插件-这样执行”mvn-package”命令时-即可得到一个可运行的Jar。-3-部署Jar包-在”target”目录下找到上一步生成的可执行jar文件右键-依次找到”Deployment-Upload-to-XXX”-就可以上传到远程服务器上。-4-启动应用-在菜单栏”Tools-StartSSH-session”中开启远程服务器的终端-在IDEA下方可以执行远程指令。-也可以在”Tools-Deployment-Browse-Remote-Host”中可视化地浏览服务器上的文件列表-检查应用是否部署成功。-在远程终端中-找到对应的fatjar-执行”java-jar-xxx-jar”-便完成了整个部署流程。-可考虑别一种方案：阿里Cloud-Toolkit插件-Web-Browsers-在’Default-Browser’中选择’Custom-path’并选择程序路径-如果个人有专属的测试浏览器，希望默认从控制台输出的链接是用测试浏览器打开，就可以这样设置-Terminal-在’Application-settings’中将’Shell-path’设置成Git-Bash-可能会出现乱码-可修改Git的安装目录下的etc目录下bash-bashrc文件，在最后一行添加：-解决IDEA下的terminal中文Unicode编码问题-export-LANG-”zh-CN-UTF-8”-export-LC-ALL-”zh-CN-UTF-8”-File-Power-Save-Mode-开启这种模式之后IDEA会关掉代码检查和代码提示等功能。所以一般也可认为这是一种阅读模式，如果你在开发过程中遇到突然代码文件不能进行检查和提示，可以来看看这里是否有开启该功能。-File-Invalidate-Caches-Restart-一般建议点击’Invalidate-and-Restart’-这样会比较干净-本质也就是去删除C盘下的system目录下的对应的文件而已" class="headerlink" title="Editor(编辑器)  - 设置鼠标滚轮控制代码字体大小        - 设置自动导包功能        - 设置显示行数及方法间的分隔线        - 设置显示空格和Tab        - 设置忽略代码提示区分大小写        - 设置取消单行显示 tabs 的操作        - 设置主题字体        - 设置 Java 代码的单行注释跟随在代码的头部        - 设置项目文件编码        - 设置鼠标悬浮提示        - 设置 Ctrl+E 弹出层显示最近文件的个数        - 设置指定代码类型进行默认折叠或是展开        - 设置打开的文件 Tab 个数        - 设置编辑区主题        - 修改代码中注释的字体颜色            Inspections,在’Java’-&gt;’Serialization’中勾选’Serializable class without serialVersionUID’          在已经继承了Serializable接口的类名上，把光标放在类名上（必须这样做），按 Alt + Enter，即可提示帮你生成serialVersionUID功能            File and Code Templates,在’Includes’中选择’File Header’修改            Compiler,勾选’Build project automatically’和’Compile indepent modules in parallel’      ——————————————      构建就是以我们编写的java代码、框架配置文件、国际化等其他资源文件、JSP 页面和图片等资源作为“原材料”，去“生产”出一个可以运行的项目的过程。      相比较于Eclipse的实时自动编译，IDEA的编译更加手动化,IDEA也支持通过设置开启实时编译，但是不建议，因为太占资源了      ——————————————      编译方式介绍(3种)：          Recompile：对选定的目标（Java类文件），进行强制性编译，不管目标是否是被修改过。          Rebuild：对选定的目标（Project），进行强制性编译，不管目标是否是被修改过，由于Rebuild的目标是整个Project，所以Rebuild每次花的时间会比较长。          Build(使用最多的编译操作)：对选定的目标（Project或Module）进行编译，但只编译有修改过的文件，没有修改过的文件不会编译，这样平时开发大型项目才不会浪费时间在编译过程中。      ——————————————      编译器的设置和选择：          Compiler下：设置编译heap大小，默认是700，建议使用64位的用户，在内存足够的情况下，建议改为1500 或以上。如果你在编译的时候出错，报：OutOfMemoryError，一般也是要来改这个地方          Compiler-&gt;Excludes下：开发过程中，某一个包目录的文件编译无法通过，但是我们又不急着改，那我们就可以考虑把该包加入到排除编译列表中，则项目就可以运行起来          Compiler-&gt;Java Compiler下：IDEA支持常见的几种编译器：Javac、Eclipse、Ajc等。默认是Javac，也推荐使用Javac              Project bytecode version 针对项目字节码编译版本，一般选择的是当前项目主JDK的版本。              Per-module bytecode version 可以针对Project下各个Module的特殊需求单独设置不同的bytecode version，前提是电脑上必须有安装对应的JDK版本。            1.配置服务器信息          Deployment,进行服务器信息的配置,包括服务器地址和权限认证,并且在Mapping选项卡完成本地工程与服务器路径的映射。      2.配置Maven打包插件          以SpringBoot应用为例,需要配置”spring-boot-maen-plugin”插件,这样执行”mvn package”命令时,即可得到一个可运行的Jar。      3.部署Jar包          在”target”目录下找到上一步生成的可执行jar文件右键,依次找到”Deployment-&gt;Upload to XXX”,就可以上传到远程服务器上。      4.启动应用          在菜单栏”Tools-&gt;StartSSH session”中开启远程服务器的终端,在IDEA下方可以执行远程指令。              也可以在”Tools-&gt;Deployment-&gt;Browse Remote Host”中可视化地浏览服务器上的文件列表,检查应用是否部署成功。          在远程终端中,找到对应的fatjar,执行”java -jar xxx.jar”,便完成了整个部署流程。      可考虑别一种方案：阿里Cloud Toolkit插件            Web Browsers,在’Default Browser’中选择’Custom path’并选择程序路径          如果个人有专属的测试浏览器，希望默认从控制台输出的链接是用测试浏览器打开，就可以这样设置            Terminal,在’Application settings’中将’Shell path’设置成Git Bash      可能会出现乱码,可修改Git的安装目录下的etc目录下bash.bashrc文件，在最后一行添加：          # 解决IDEA下的terminal中文Unicode编码问题          export LANG&#x3D;”zh_CN.UTF-8”          export LC_ALL&#x3D;”zh_CN.UTF-8”        File-&gt;Power Save Mode      开启这种模式之后IDEA会关掉代码检查和代码提示等功能。所以一般也可认为这是一种阅读模式，如果你在开发过程中遇到突然代码文件不能进行检查和提示，可以来看看这里是否有开启该功能。    File-&gt;Invalidate Caches&#x2F;Restart,一般建议点击’Invalidate and Restart’,这样会比较干净,本质也就是去删除C盘下的system目录下的对应的文件而已"></a><code>Editor(编辑器)</code><br>  - <strong>设置鼠标滚轮控制代码字体大小</strong><br>      <pre><code class="hljs plaintext">General,在&#x27;Mouse&#x27;中勾选&#x27;Change font size with Ctrl+Mouse Wheel&#x27;</code></pre><br>  - <strong>设置自动导包功能</strong><br>      <pre><code class="hljs plaintext">General-&gt;Auto Import,在&#x27;Java&#x27;中&#x27;Insert imports on paste&#x27;选择All    Add unambiguous imports on the fly：书写代码时自动导入需要用到的包    Optimize imports on the fly：自动帮我们优化导入的包,比如去掉一些没有用到的包</code></pre><br>  - <strong>设置显示行数及方法间的分隔线</strong><br>      <pre><code class="hljs plaintext">General-&gt;Apperance,勾选&#x27;Show method separators&#x27;和&#x27;Show line numbers&#x27;</code></pre><br>  - <strong>设置显示空格和Tab</strong><br>      <pre><code class="hljs plaintext">General-&gt;Apperance,勾选&#x27;Show whitespaces&#x27;</code></pre><br>  - <strong>设置忽略代码提示区分大小写</strong><br>      <pre><code class="hljs plaintext">General-&gt;Code completion,去掉&#x27;Match case&#x27;选中</code></pre><br>  - <strong>设置取消单行显示 tabs 的操作</strong><br>      <pre><code class="hljs plaintext">General-&gt;Editor Tabs,去掉&#x27;Show tabs in one row&#x27;选中    在打开很多文件的时候，IDEA默认是把所有打开的文件名Tab单行显示的。多行效率比单行高，因为单行会隐藏超过界面部分Tab，这样找文件不方便</code></pre><br>  - <strong>设置主题字体</strong><br>      <pre><code class="hljs plaintext">Font,也可以去Editor-&gt;Color Scheme-&gt;Color Scheme Font/Console Font中分别设置编辑区和控制台的字体</code></pre><br>  - <strong>设置 Java 代码的单行注释跟随在代码的头部</strong><br>      <pre><code class="hljs plaintext">Code Style-&gt;Java,切换到Code Generation,在&#x27;Comment Code&#x27;中去掉&#x27;Line comment at first column&#x27;选中    默认IDEA对于Java代码的单行注释是把注释的斜杠放在行数的最开头，个人觉得这样的单行注释非常丑，整个代码风格很难看，所以一般会设置为单行注释的两个斜杠跟随在代码的头部</code></pre><br>  - <strong>设置项目文件编码</strong><br>      <pre><code class="hljs plaintext">File Encodings,对&#x27;Global Encoding&#x27;,&#x27;Project Encoding&#x27;和&#x27;Properties Files&#x27;进行设置,建议都修改为UTF-8    Transparent native-to-ascii conversion主要用于转换ascii，一般都要勾选，不然Properties文件中的注释显示的都不会是中文</code></pre><br>  - 设置鼠标悬浮提示<br>      <pre><code class="hljs plaintext">General,在&#x27;Other&#x27;中勾选&#x27;Show quick documentation on mouse move&#x27;</code></pre><br>  - 设置 Ctrl+E 弹出层显示最近文件的个数<br>      <pre><code class="hljs plaintext">General,在&#x27;Limits&#x27;中修改&#x27;Recent files limit&#x27;</code></pre><br>  - 设置指定代码类型进行默认折叠或是展开<br>      <pre><code class="hljs plaintext">General-&gt;Code Folding,勾选上的表示该类型的代码在文件被打开的时候默认是被折叠的，去掉勾选则反之</code></pre><br>  - 设置打开的文件 Tab 个数<br>      <pre><code class="hljs plaintext">General-&gt;Editor Tabs,在&#x27;Closing Policy&#x27;中调整&#x27;Tab limit&#x27;的值    当打开的文件超过该个数的时候，早打开的文件会被新打开的替换</code></pre><br>  - 设置编辑区主题<br>      <pre><code class="hljs plaintext">Color Scheme,如果想要更多的主题效果的话，可以到如下的网站下载,对应文件如何安装请查看网站对应的Help页面，都有详细说明的    https://www.riaway.com/theme.php    http://color-themes.com/?view=index导入主题(方式1)：    File–&gt;import setttings–&gt;选中下载的主题jar文件–&gt;一路确认–&gt;重启。重启以后，新主题会自动启用。如果没有启用，可去Editor-&gt;Color Scheme选中导入主题(方式2)：    Editor-&gt;Color Scheme-&gt;齿轮图标-&gt;Import Scheme-&gt;Intellij IDEA color scheme or settings</code></pre><br>  - 修改代码中注释的字体颜色<br>      <pre><code class="hljs plaintext">    Color Scheme-&gt;Language Defaults,选择需要修改的地方进行设置        Doc Comment：修改文档注释的字体颜色        Block comment：修改多行注释的字体颜色        Line comment：修改单行注释的字体颜色    ```      - 设置开启自动生成 serialVersionUID</code></pre><br>      Inspections,在’Java’-&gt;’Serialization’中勾选’Serializable class without serialVersionUID’<br>          在已经继承了Serializable接口的类名上，把光标放在类名上（必须这样做），按 Alt + Enter，即可提示帮你生成serialVersionUID功能<br>      <pre><code class="hljs plaintext">- 修改类头的文档注释信息</code></pre><br>      File and Code Templates,在’Includes’中选择’File Header’修改<br>      <pre><code class="hljs plaintext">- `Plugins(插件)`    - ***详见高级篇***- `Version Control(版本控制)`    - ***详见高级篇***- `Build,Execution,Deployment(构建,执行,部署)`    - **设置自动编译(不建议,太耗资源)**</code></pre><br>      Compiler,勾选’Build project automatically’和’Compile indepent modules in parallel’<br>      ——————————————<br>      构建就是以我们编写的java代码、框架配置文件、国际化等其他资源文件、JSP 页面和图片等资源作为“原材料”，去“生产”出一个可以运行的项目的过程。<br>      相比较于Eclipse的实时自动编译，IDEA的编译更加手动化,IDEA也支持通过设置开启实时编译，但是不建议，因为太占资源了<br>      ——————————————<br>      编译方式介绍(3种)：<br>          Recompile：对选定的目标（Java类文件），进行强制性编译，不管目标是否是被修改过。<br>          Rebuild：对选定的目标（Project），进行强制性编译，不管目标是否是被修改过，由于Rebuild的目标是整个Project，所以Rebuild每次花的时间会比较长。<br>          Build(使用最多的编译操作)：对选定的目标（Project或Module）进行编译，但只编译有修改过的文件，没有修改过的文件不会编译，这样平时开发大型项目才不会浪费时间在编译过程中。<br>      ——————————————<br>      编译器的设置和选择：<br>          Compiler下：设置编译heap大小，默认是700，建议使用64位的用户，在内存足够的情况下，建议改为1500 或以上。如果你在编译的时候出错，报：OutOfMemoryError，一般也是要来改这个地方<br>          Compiler-&gt;Excludes下：开发过程中，某一个包目录的文件编译无法通过，但是我们又不急着改，那我们就可以考虑把该包加入到排除编译列表中，则项目就可以运行起来<br>          Compiler-&gt;Java Compiler下：IDEA支持常见的几种编译器：Javac、Eclipse、Ajc等。默认是Javac，也推荐使用Javac<br>              Project bytecode version 针对项目字节码编译版本，一般选择的是当前项目主JDK的版本。<br>              Per-module bytecode version 可以针对Project下各个Module的特殊需求单独设置不同的bytecode version，前提是电脑上必须有安装对应的JDK版本。<br>      <pre><code class="hljs plaintext">- ***断点调试***    - 详见高级篇- ***部署应用到服务器***</code></pre><br>      1.配置服务器信息<br>          Deployment,进行服务器信息的配置,包括服务器地址和权限认证,并且在Mapping选项卡完成本地工程与服务器路径的映射。<br>      2.配置Maven打包插件<br>          以SpringBoot应用为例,需要配置”spring-boot-maen-plugin”插件,这样执行”mvn package”命令时,即可得到一个可运行的Jar。<br>      3.部署Jar包<br>          在”target”目录下找到上一步生成的可执行jar文件右键,依次找到”Deployment-&gt;Upload to XXX”,就可以上传到远程服务器上。<br>      4.启动应用<br>          在菜单栏”Tools-&gt;StartSSH session”中开启远程服务器的终端,在IDEA下方可以执行远程指令。<br>              也可以在”Tools-&gt;Deployment-&gt;Browse Remote Host”中可视化地浏览服务器上的文件列表,检查应用是否部署成功。<br>          在远程终端中,找到对应的fatjar,执行”java -jar xxx.jar”,便完成了整个部署流程。<br>      可考虑别一种方案：阿里Cloud Toolkit插件<br>      <pre><code class="hljs plaintext">- `Languages &amp; Frameworks(语言和框架)`- `Tools(工具集)`    - 设置默认浏览器</code></pre><br>      Web Browsers,在’Default Browser’中选择’Custom path’并选择程序路径<br>          如果个人有专属的测试浏览器，希望默认从控制台输出的链接是用测试浏览器打开，就可以这样设置<br>      <pre><code class="hljs plaintext">- **设置默认终端**</code></pre><br>      Terminal,在’Application settings’中将’Shell path’设置成Git Bash<br>      可能会出现乱码,可修改Git的安装目录下的etc目录下bash.bashrc文件，在最后一行添加：<br>          # 解决IDEA下的terminal中文Unicode编码问题<br>          export LANG&#x3D;”zh_CN.UTF-8”<br>          export LC_ALL&#x3D;”zh_CN.UTF-8”<br>      <pre><code class="hljs plaintext">## 其他设置介绍- `设置为省电模式`</code></pre><br>  File-&gt;Power Save Mode<br>      开启这种模式之后IDEA会关掉代码检查和代码提示等功能。所以一般也可认为这是一种阅读模式，如果你在开发过程中遇到突然代码文件不能进行检查和提示，可以来看看这里是否有开启该功能。<br>  <pre><code class="hljs plaintext">- `清除缓存和索引`</code></pre><br>  File-&gt;Invalidate Caches&#x2F;Restart,一般建议点击’Invalidate and Restart’,这样会比较干净,本质也就是去删除C盘下的system目录下的对应的文件而已</h2><h2 id="清除索引和缓存会使得IDEA的Local-History丢失-如果你项目没有加入到版本控制，而你又需要你项目文件的历史更改记录，清除前最好备份下LocalHistory目录。-如果你遇到了因为断电、蓝屏引起的强制关机等导致了索引、缓存坏了以至于项目打不开，那也建议你可以直接删除system目录，一般这样都可以很好地解决你的问题。"><a href="#清除索引和缓存会使得IDEA的Local-History丢失-如果你项目没有加入到版本控制，而你又需要你项目文件的历史更改记录，清除前最好备份下LocalHistory目录。-如果你遇到了因为断电、蓝屏引起的强制关机等导致了索引、缓存坏了以至于项目打不开，那也建议你可以直接删除system目录，一般这样都可以很好地解决你的问题。" class="headerlink" title="  清除索引和缓存会使得IDEA的Local History丢失,如果你项目没有加入到版本控制，而你又需要你项目文件的历史更改记录，清除前最好备份下LocalHistory目录。  如果你遇到了因为断电、蓝屏引起的强制关机等导致了索引、缓存坏了以至于项目打不开，那也建议你可以直接删除system目录，一般这样都可以很好地解决你的问题。"></a>  清除索引和缓存会使得IDEA的Local History丢失,如果你项目没有加入到版本控制，而你又需要你项目文件的历史更改记录，清除前最好备份下LocalHistory目录。<br>  如果你遇到了因为断电、蓝屏引起的强制关机等导致了索引、缓存坏了以至于项目打不开，那也建议你可以直接删除system目录，一般这样都可以很好地解决你的问题。</h2>  IDEA首次加载项目的时候，都会创建索引，而创建索引的时间跟项目的文件多少成正比;IDEA的缓存和索引主要是用来加快文件查询，从而加快各种查找、代码提示等操作的速度  <pre><code class="hljs plaintext">- `设置 Project 项目的一些配置为模板`</code></pre>  File-&gt;Other Settings-&gt;Setting for New Projects…<br>  对于默认编码、编译版本、Maven 本地库路径等等,可以被当做一个标准的IDE设置模板保存起来,下次打开新的Projec 就会以这个IDE设置进行  <pre><code class="hljs plaintext">- `自带模拟请求工具 Rest Client`</code></pre>  Tools-&gt;HTTP Client-&gt;Test RESTful web service,在开发时用来模拟请求是非常好用的  <pre><code class="hljs plaintext">- `生成 javadoc`</code></pre>  Tools-&gt;Generate JavaDoc,支持对project,module,file<br>  Locale(输入语言类型)：zh_CN<br>  Other command line arguments：-encoding UTF-8 -charset UTF-8  <pre><code class="hljs plaintext">- `设置代码水平或垂直显示`</code></pre>  文件tab页上,右键选择Split Vertically(垂直分屏)和Split Horizontally(水平分屏),可设置快捷键<br>  一般在对大文件进行修改的时候，有些修改内容在文件上面，有些内容在文件下面，如果来回操作可能效率会很低，用此方法就可以好很多  <pre><code class="hljs plaintext">- `设置代码检查等级`</code></pre>  右下角图标。IDEA对于编辑大文件并没有太大优势，很卡，原因就是它有各种检查，这样是非常耗内存和CPU的，所以在编辑大文件的时候为了能加快大文件的读写，我一般会暂时性设置为None<br>  Inspections：为最高等级检查，可以检查单词拼写，语法错误，变量使用，方法之间调用等<br>  Syntax：可以检查单词拼写，简单语法错误<br>  None：不设置检查<pre><code></code></pre></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial">https://github.com/judasn/IntelliJ-IDEA-Tutorial</a></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jetbrains </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse 札记</title>
      <link href="/2018/12/01/st-eclipse.html"/>
      <url>/2018/12/01/st-eclipse.html</url>
      
        <content type="html"><![CDATA[<h1 id="Eclipse-札记"><a href="#Eclipse-札记" class="headerlink" title="Eclipse 札记"></a>Eclipse 札记</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#Git%E7%9A%84%E4%BD%BF%E7%94%A8">Git 的使用</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>记录 Eclipse 的 常用操作</li></ul><h2 id="Git的使用"><a href="#Git的使用" class="headerlink" title="Git的使用"></a>Git的使用</h2><ul><li>新建工程初始化为本地库(以 Maven 工程为例)  <pre><code class="hljs plaintext">1. Maven工程右键-&gt;&#x27;Java Tools&#x27;-&gt;&#x27;Generate Deployment Descriptor Stub&#x27;,来生成web.xml文件2. Maven工程右键-&gt;&#x27;Team&#x27;-&gt;&#x27;Share Project...&#x27;,选择Git,勾选&#x27;Use or create repository in...&#x27;,选中目标Project后点击&#x27;Create Repository&#x27;3. 在&#x27;Preferences&#x27;-&gt;&#x27;Team&#x27;-&gt;&#x27;Git&#x27;-&gt;&#x27;Configuration&#x27;中,&#x27;Repository Settings&#x27;选项卡能够检测到当前工作空间中的git项目    当前项目本地库配置也可在此配置,例如签名等等4. 在&#x27;Preferences&#x27;-&gt;&#x27;Team&#x27;-&gt;&#x27;Git&#x27;-&gt;&#x27;Label Decorations&#x27;中,能看到各个Git图标的介绍</code></pre></li><li>忽略 Eclipse 特定文件  <pre><code class="hljs plaintext">1. .classpath文件,.project文件,.settings目录下所有文件都是Eclipse为了管理我们创建的工程而维护的文件，和开发的代码没有直接关系。最好不要在Git中进行追踪，也就是把它们忽略    因为同一个团队中很难保证大家使用相同的IDE工具，而IDE工具不同时，相关工程特定文件就有可能不同。如果这些文件加入版本控制，那么开发时很可能需要为了这些文件解决冲突。2. 去GitHub官网(https://github.com/github/gitignore)下载样例文件,并在本地编辑该配置文件，文件名任意    末尾添加.classpath,.project,.settings,target等文件和目录3. 在~/.gitconfig文件中引入上述文件 ,注意这里路径中一定要使用“/”，不能使用“\”    [core]        excludesfile=C:/Users/Lenovo/Java.gitignore4. 在&#x27;Preferences&#x27;-&gt;&#x27;Team&#x27;-&gt;&#x27;Git&#x27;-&gt;&#x27;Configuration&#x27;中,&#x27;User Settings&#x27;选项卡中能看到</code></pre></li><li>提交到本地库  <pre><code class="hljs plaintext">1. Maven工程右键-&gt;&#x27;Team&#x27;-&gt;&#x27;Add to index&#x27;,项目文件都被加入暂存区追踪,也可以通过Ctrl+#打开&#x27;Git Stating&#x27;窗口来操作指定文件加入暂存区追踪    已经被追踪过的文件,再次修改,不会进入&#x27;Unstaged Changes&#x27;中,会进入&#x27;Staged Changes&#x27;2. Maven工程右键-&gt;&#x27;Team&#x27;-&gt;&#x27;Commit...&#x27;,快捷键Ctrl+#(Ctrl+Shift+3),填写相关信息,提交到本地库</code></pre></li><li>推送到远程库(以 GitHub 为例)  <pre><code class="hljs plaintext">1. Maven工程右键-&gt;&#x27;Team&#x27;-&gt;&#x27;Remote&#x27;-&#x27;Push...&#x27;&gt;,填写相关信息提交    填写URI(远程库地址),用户名,密码后next    点击&#x27;Add All Branches Spec&#x27;来检测所有分支,next    填写相关日志信息,finish2. 弹出&#x27;Push Results...&#x27;窗口代表推送成功</code></pre></li><li>从远程库克隆到本地(以 Oxygen 版本为例)  <pre><code class="hljs plaintext">1. 右键&#x27;Import...&#x27;,选择&#x27;Git&#x27;-&gt;&#x27;Projects from Git&#x27;,next后选择&#x27;Clone URI&#x27;    填写URI(远程库地址),用户名,密码后,next选择分支    指定工程的保存位置(Kepler等低版本Eclipse不能保存到当前Eclipse工作空间,需保存到工作空间以外的目录中)    指定工程导入方式，这里只能用：Import as general project,目录下会多出.project文件2. 转换工程类型为Maven    工程右键&#x27;Configure&#x27;-&gt;&#x27;Convert to Maven Project&#x27;,目录下会多出.classpath文件和.settings目录</code></pre></li><li>解决冲突  <pre><code class="hljs plaintext">1. 提交各自的修改至本地库后,然后试着推送到远程库,可能会出现冲突    Maven工程右键-&gt;&#x27;Team&#x27;-&gt;&#x27;Push Branch master&#x27;2. 当弹出窗口提示冲突时,可执行拉取操作,解决冲突后Ctrl+#提交到本地库,最后推送到远程库    Maven工程右键-&gt;&#x27;Team&#x27;-&gt;&#x27;Pull&#x27;    冲突文件右键-&gt;&#x27;Team&#x27;-&gt;&#x27;Merge Tool&#x27;</code></pre></li><li>GitFlow 分支实战(以 hot_fix 为例)  <pre><code class="hljs plaintext">1. 创建分支    工程右键&#x27;Team&#x27;-&gt;&#x27;Switch To&#x27;-&gt;&#x27;New Branch...&#x27;,输入分支名hot_fix,依次提交到本地库和远程库(Push Branch hot_fix)2. 切换分支审查代码    Maven工程右键-&gt;&#x27;Team&#x27;-&gt;&#x27;Pull&#x27;    工程右键&#x27;Team&#x27;-&gt;&#x27;Switch To&#x27;-&gt;&#x27;Other...&#x27;,选择&#x27;Remote Tracking&#x27;-&gt;&#x27;origin/hot_fix&#x27;3. 检出远程新分支    选择&#x27;Check out as New Local Branch&#x27;,检出为本地的一个新的分支4. 切换回master    工程右键&#x27;Team&#x27;-&gt;&#x27;Switch To&#x27;-&gt;&#x27;master5. 合并分支    工程右键&#x27;Team&#x27;-&gt;&#x27;Merge...&#x27;,选择&#x27;Local&#x27;-&gt;&#x27;hot_fix&#x27;,合并成功后把master推送到远程库</code></pre></li></ul><h2 id="Maven的使用"><a href="#Maven的使用" class="headerlink" title="Maven的使用"></a>Maven的使用</h2><p><img src="/2018/12/01/st-eclipse/st-eclipse-001.png" alt="抱歉,图片休息了"> </p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eclipse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS 札记</title>
      <link href="/2018/12/01/af-nodejs.html"/>
      <url>/2018/12/01/af-nodejs.html</url>
      
        <content type="html"><![CDATA[<h1 id="NodeJS-札记"><a href="#NodeJS-札记" class="headerlink" title="NodeJS 札记"></a>NodeJS 札记</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2">发展历史</a></li><li><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">准备工作</a></li><li><a href="#%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85">模块与包</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97">基本模块</a></li><li><a href="#Web%E5%BC%80%E5%8F%91">Web开发</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Node.js 是一个能够在<strong>服务器端</strong>运行 JavaScript 的开源、 跨平台 <strong>JavaScript 运行环境</strong>。</li><li>Node.js 采用 Google 开发的 V8 引擎运行 js 代码，使用<strong>事件驱动</strong>、<strong>非阻塞</strong>和<strong>异步 I&#x2F;O</strong> 模型等技术来提高性能，可优化应用程序的传输量和规模。</li><li>特点：<ul><li>非阻塞、异步的 I&#x2F;O</li><li>事件和回调函数</li><li>单线程（主线程单线程，后台 I&#x2F;O 线程池）</li><li>跨平台</li></ul></li><li>用途：<ul><li>Web 服务 API，比如 REST</li><li>实时多人游戏</li><li>在后台编写单线程的服务器</li><li>基于 Web 的应用</li><li>多客户端的通信，如即时通信</li></ul></li></ul><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><ol><li>2004 年，非科班出身的Ryan Dahl(瑞安·达尔)，在纽约的罗彻斯特大学数学系读博士。</li><li>2006 年，也许是厌倦了读博的无聊，他产生了”世界那么大， 我想去看看”的念头，做出了退学的决定，然后一个人来到智利的 Valparaiso 小镇。</li><li>从那起，Ryan Dahl 不知道是否因为生活的关系，他开始学习网站开发了，走上了码农的道路。</li><li>那时候 Ruby on Rails(Ruby 的一个 web 框架)很火，他也不例外的学习了它，后来的 Node.js 也是借鉴了它才写出来的。</li><li>从那时候开始，Ryan Dahl 的生活方式就是接项目，然后去客户的地方工作，在他眼中，拿工资和上班其实就是去那里旅行。</li><li>Ryan Dahl 经过两年的工作后，成为了高性能 Web 服务器的专家，从接开发应用到变成专门帮客户解决性能问题的专家。</li><li>期间他开始写一些开源项目帮助客户解决 Web 服务器的高并发性能问题，他尝试了很多种语言，发现很多语言虽然同时提供了同步 IO 和异步 IO，但是开发人员一旦用了同步 IO，他们就再也懒得写异步 IO 了，所以，最终，Ryan瞄向了 JavaScript。<ul><li>对于高性能，异步 IO、事件驱动是基本原则。</li><li>JavaScript 是单线程执行，根本不能进行同步 IO 操作，所以，JavaScript 的这一“缺陷”导致了它只能使用异步 IO。</li></ul></li><li>选定了开发语言，还要有运行时引擎，他曾考虑过自己写一个，不过明智地放弃了，因为 V8 就是开源的 JavaScript引擎。让 Google 投资去优化 V8，他只负责改造一下拿来用，还不用付钱，这个买卖很划算。</li><li>2009 年 2 月，他开始着手编写 web.js，目的是用 JavaScript 去编写一个高性能的 Web 服务器。</li><li>同年，Ryan Dahl 正式推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为Node.js，并在GitHub上发布最初版本。<ul><li>虽然名字很土，但是 Node.js 第一次把 JavaScript 带入到后端服务器开发，加上世界上已经有无数的 JavaScript 开发人员，所以 Node.js 一下子就火了起来。</li><li>在 Node.js 上运行的 JavaScript 相比其他后端开发语言，最大的优势是借助 JavaScript 天生的事件驱动机制加 V8 高性能引擎，使编写高性能 Web 服务轻而易举。</li></ul></li><li>2010 年 1 月，Node.js 的包管理器 npm 诞生。</li><li>2010 年 12 月，Joyent 公司(美国的一个服务器供应商)赞助 Node.js 的开发，Ryan Dahl 加入旗下，全职负责 Node.js。</li><li>2011 年 7 月，Node.js 在微软的帮助下发布了 windows 版本。</li><li>2011 年 11 月，Node.js 超越 Ruby on Rails，称为 GitHub 上关注度最高的项目。</li><li>2012 年 1 月，Ryan Dahl 离开 Node.js 项目。</li><li>2014 年 12 月，Node.js 虽然由社区推动，但幕后一直由 Joyent 公司资助，由于一群开发者对 Joyent 公司的策略不满，Fedor Indutny 从 Node.js 项目 fork 出了 io.js 项目，决定单独发展，但两者实际上是兼容的。</li><li>2015 年 1 月，Joyent 公司感觉势头不对，Node.js感觉要完，于是联合 IBM、Intel、微软成立了 Node.js 基金会。</li><li>2015 年 9 月，正所谓”分久必合，合久必分”，分家后没多久，Joyent 公司表示要和解，于是 io.js 项目又决定回归 Node.js，Node.js 4.0发布。<ul><li>奇数版为开发版本,偶数版为稳定版本。</li></ul></li><li>2016 年，Node.js 6.0 发布。</li><li>2017 年，Node.js 8.0 发布。</li></ol><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>下载与安装<ul><li>在 Git Bash 中输入 <code>node -v</code> 打印版本号即成功。</li></ul></li><li>IDEA 中安装 NodeJS 插件，方便在 js 文件中右键调试代码<ul><li>也可以在 Terminal 中输入 <code>node js文件名</code> 运行js文件。</li><li>可在 <code>settings-&gt;Lnaguages &amp; Frameworks-&gt;Node.js and NPM</code>中勾选<code>Coding assistance for Node.js</code>，来打开 Node.js 的核心代码提示。</li></ul></li></ul><h2 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h2><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul><li>ECMAScript 标准的缺陷<ul><li>ES5 中没有原生支持模块化，我们只能通过 script 标签引入js文件来实现模块化(ES6 有了)。</li><li>标准库较少。</li><li>没有标准接口。</li><li>缺乏管理系统。</li></ul></li><li>CommonJS 规范<ul><li>CommonJS 规范的提出，主要是为了弥补当前 JavaScript 没有模块化标准的缺陷。</li><li>CommonJS 规范为 JS 指定了一个美好的愿景， 希望 JS 能够在任何地方运行。</li><li>在 Node.js 中为了对模块管理，引入了 CommonJS 规范，<strong>从而大大提高了代码的复用性和可维护性。</strong></li><li>CommonJS 规范对模块的定义十分简单：<strong>模块定义</strong>，<strong>模块引用</strong>，<strong>模块标识</strong>。</li></ul></li><li>模块定义<ul><li><strong>在 Node.js 中，一个 js 文件就是一个模块。</strong></li><li>在 Node.js 中，默认情况下每一个 js 文件中的 js 代码都是独立运行在一个函数中。<ul><li>而不是全局作用域，所以一个模块的中的变量和函数在其他模块中无法访问。</li><li>实际上模块中的代码都是包装在一个函数中执行的，并且在函数执行时，同时传递进了5个实参  <pre><code class="hljs plaintext">var load = function (exports, require, module, __filename, __dirname) &#123;    //js文件内容    ...    // 参数解释    exports        - 该对象用来将变量或函数暴露到外部    require        - 函数，用来引入外部的模块    module        - module 代表的是当前模块本身        - exports 就是 module 的属性        - 既可以使用 exports 导出，也可以使用 module.exports 导出    __filename        - 当前模块的完整路径    __dirname        - 当前模块所在文件夹的完整路径&#125;</code></pre>  <pre><code class="hljs plaintext">导出变量和函数    - 通过exports只能使用.的方式来向外暴露内部变量或函数        exports.xxx = xxx    - 通过module.exports既可以使用.的形式，也可以直接赋值        module.exports.xxx = xxx        module.exports = &#123;xxx:xxx,xxx:xxx,...&#125;</code></pre>  <pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">callee</span> + <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">//这个属性保存的是当前执行的函数对象</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>); <span class="hljs-comment">//5</span></code></pre></li></ul></li><li>在 Node.js 中有一个全局对象 global，它的作用和网页中 window 类似。<ul><li>在全局中创建的变量都会作为global的属性保存</li><li>在全局中创建的函数都会作为global的方法保存  <pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;b = <span class="hljs-number">20</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">global</span>.<span class="hljs-property">a</span>); <span class="hljs-comment">//undefined</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">global</span>.<span class="hljs-property">b</span>); <span class="hljs-comment">//20</span></code></pre></li></ul></li></ul></li><li>模块引用<ul><li>在 Node.js 中，<strong>通过 require()函数来引入外部的模块</strong>，该函数会返回一个对象，这个对象代表的是引入的模块。</li><li>格式：var 变量 &#x3D; require(“模块的标识”);</li></ul></li><li>模块标识<ul><li>**模块的标识就是模块的名字(去掉.js后缀的文件名)或文件路径(绝对路径,相对路径)**，也就是传递给 require()方法的参数。</li><li>对于<strong>核心模块</strong>（npm 中下载的模块或者 Node.js 引擎提供的模块），直接使用模块的名字对其进行引入。  <pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);</code></pre></li><li>对于<strong>文件模块</strong>(用户自己创建的模块)，使用文件的路径来对其进行引入，如果是相对路径必须以.&#x2F;或 ..&#x2F;开头。  <pre><code class="hljs javascript"><span class="hljs-keyword">var</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./router&quot;</span>);</code></pre></li></ul></li></ul><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><ul><li>CommonJS 的包规范允许我们将一组相关的模块组合到一起，形成一组完整的工具。<ul><li><strong>将多个模块组合为一个完整的功能，就是一个包。</strong></li><li><strong>增强版的模块。</strong></li></ul></li><li>CommonJS 的包规范由包结构和包描述文件两个部分组成。 <ul><li>包结构：用于组织包中的各种文件  <pre><code class="hljs plaintext">包实际上就是一个压缩文件，解压以后还原为目录。符合规范的目录，应该包含如下文件：        – package.json 包的描述文件，必须的     – bin 二进制可执行文件，一般都是一些工具包中才有    – lib js文件     – doc 文档     – test 测试代码</code></pre></li><li>包描述文件：描述包的相关信息，类似于简历，以供外部读取分析  <pre><code class="hljs plaintext">它是一个json格式的文件，在它里面保存了包各种相关的信息，里面不能写注释    - name 包名    - version 版本    - dependencies 依赖    - devDependencies 开发依赖    - main 包的主文件    - maintainers 主要贡献者    - keywords 关键字,方便搜索该包</code></pre></li></ul></li><li>NPM(Node Package Manager) ：Node.js 的包管理器<ul><li>CommonJS 包规范是理论，NPM 是其中一种实践。 </li><li>通过 NPM 可以对 Node.js 中的第三方模块进行上传发布、下载安装、搜索和依赖等操作。</li><li><strong>NPM 会在安装完 Node.js 以后，自动安装。</strong></li><li>NPM 常用命令  <pre><code class="hljs plaintext">npm      //帮助说明npm -v      //查看npm的版本npm version      //查看所有模块的版本npm config list      //查看npm配置信息npm s/search 包名      //搜索模块包,需联网-------------------------------------npm init      //初始化项目（创建package.json）,安装包时根据 package.json 是否存在来识别当前目录是一个包,不然可能会安装到其他地方npm i/install      //安装当前项目所依赖的包npm i/install 包名      //在当前目录安装指定的包npm i/install 包名 --save      //在当前目录安装指定的包并在package.json中添加依赖npm i/install 包名 --save-dev      //在当前目录安装指定的包并在package.json中添加开发依赖npm i/install 包名 -g       //全局模式安装指定的包（一般都是一些工具）,可以供命令行使用npm i/install 包名 -registry=地址      //从镜像源安装npm i/install 文件路径      //从本地安装npm r/remove 包名      //删除一个模块包npm r/remove 包名 --save     //删除一个模块包,并在package.json中移除依赖关系npm r/remove 包名 --save-dev     //删除一个模块包,并在package.json中移除开发依赖关系npm r/remove 包名 -g      //删除一个全局模式安装的模块包npm update 包名      //更新指定的已安装模块包的版本npm update 包名 -g      //更新指定的全局安装模块包的版本-------------------------------------npm config get prefix      //查看默认的全局安装路径npm config get cache      //查看默认的全局安装缓存路径npm config set prefix &quot;E:\Ebook\JavaSE\develop\nodejs\node_global&quot;      //设置默认的全局安装路径,需重新修改环境变量npm config set cache &quot;E:\Ebook\JavaSE\develop\nodejs\node_cache&quot;      //设置默认的全局安装缓存路径npm ls/list -g --depth 0      //查看全局安装过的包</code></pre></li><li>通过 NPM 下载的包都放到 node_modules 文件夹中，直接通过包名引入即可(<strong>全局模式安装的需要配置NODE_PATH环境变量</strong>)。  <pre><code class="hljs plaintext">Node.js 在使用模块名字来引入模块时，它会首先在当前目录的 node_modules 中寻找是否含有该模块    如果有则直接使用，如果没有则去上一级目录的 node_modules 中寻找;    如果有则直接使用，如果没有则再去上一级目录寻找，直到找到为止;    直到找到磁盘的根目录，如果依然没有，则报错.</code></pre></li></ul></li><li>CNPM ：淘宝 NPM 镜像<ul><li>这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。  <pre><code class="hljs plaintext">使用说明    - 你可以使用我们定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:        $ npm install -g cnpm --registry=https://registry.npm.taobao.org    - 或者你直接通过添加 npm 参数 alias 一个新命令:        $ alias cnpm=&quot;npm --registry=https://registry.npm.taobao.org \            --cache=$HOME/.npm/.cache/cnpm \            --disturl=https://npm.taobao.org/dist \            --userconfig=$HOME/.cnpmrc&quot;        # Or alias it in .bashrc or .zshrc        $ echo &#x27;\n#alias for cnpm\nalias cnpm=&quot;npm --registry=https://registry.npm.taobao.org \            --cache=$HOME/.npm/.cache/cnpm \            --disturl=https://npm.taobao.org/dist \            --userconfig=$HOME/.cnpmrc&quot;&#x27; &gt;&gt; ~/.zshrc &amp;&amp; source ~/.zshrc</code></pre></li></ul></li></ul><h2 id="基本模块"><a href="#基本模块" class="headerlink" title="基本模块"></a>基本模块</h2><h2 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501245426ad4b91f2b880464ba876a8e3043fc8ef000">Node.js - 廖雪峰的官方网站</a></li><li><a href="https://npm.taobao.org/">淘宝 NPM 镜像</a></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 开发语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 札记</title>
      <link href="/2018/12/01/dl-markdown.html"/>
      <url>/2018/12/01/dl-markdown.html</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-札记"><a href="#Markdown-札记" class="headerlink" title="Markdown 札记"></a>Markdown 札记</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95">常用语法</a></li><li><a href="#%E5%86%99%E4%BD%9C%E9%A3%8E%E6%A0%BC">写作风格</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>宗旨：实现 <code>易读易写</code></li><li>百度百科：<blockquote><p>Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p></blockquote><blockquote><p>Markdown 具有一系列衍生版本，用于扩展 Markdown 的功能（如表格、脚注、内嵌HTML等等），这些功能原初的 Markdown 尚不具备，它们能让Markdown 转换成更多的格式，例如 LaTeX，Docbook。Markdown 增强版中比较有名的有 Markdown Extra、MultiMarkdown、Maruku 等。这些衍生版本要么基于工具，如 Pandoc；要么基于网站，如 GitHub 和 Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p></blockquote></li><li>维基百科：<blockquote><p>Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p></blockquote><blockquote><p>由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，目前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge 等。甚至 Markdown 能被使用来撰写电子书。</p></blockquote></li></ul><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><ul><li><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3></li></ul><p>MarkDown 支持 1~6 级标题，通过加在标题文字前的 # 来区分。例如，</p><pre><code class="hljs plaintext"># 这是一级标题## 这是二级标题...###### 这是六级标题</code></pre><p>Tips：# 和标题文字之间是有一个空格的。</p><ul><li><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3></li></ul><p>一行文字就是一个段落。例如，</p><pre><code class="hljs plaintext">这是一行文字，MarkDown 中的段落。</code></pre><p>Tips：如果要换行，那么两行之间要隔一个空行或者在第一行末尾敲2个空格或者<code>&lt;br&gt;</code>。</p><ul><li><h3 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h3></li></ul><p>Markdown 中字体的粗体和斜体用 * ** 表示。例如，</p><pre><code class="hljs plaintext">*这里是斜体***这里是粗体*****这里是粗体 + 斜体***</code></pre><ul><li><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3></li></ul><p>可能有一部分编辑器不支持这个元素,可用 <code>&lt;del&gt;</code> 标签来替代。删除线用 ~ 定义。例如，</p><pre><code class="hljs plaintext">~~我来了木森~~</code></pre><p>Tips：删除线要用两个 ~ 来包裹文字。</p><ul><li><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3></li></ul><p>在一行文字前添加大于号 &gt; 来使用引用格式。例如，</p><pre><code class="hljs plaintext">&gt; 这里是引用句子。</code></pre><p>引用可以嵌套使用，例如，</p><pre><code class="hljs plaintext">&gt;&gt; 这里使用了嵌套引用。</code></pre><p>也可以嵌套其他格式。例如，</p><pre><code class="hljs plaintext">&gt; ## 嵌套一个二级标题。&gt; *嵌套斜体字。*&gt; **嵌套粗体字。**</code></pre><p>Tips：想要结束引用可以空一行。</p><ul><li><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3></li></ul><p>列表分为无序列表和有序列表以及任务列表。<br>无序列表使用加号、减号和星号来标记，后面需跟 <code>空格</code>。例如，</p><pre><code class="hljs plaintext">+ 加号列表+ 加号列表+ 加号列表- 减号列表- 减号列表- 减号列表* 星号列表* 星号列表* 星号列表</code></pre><p>有序列表使用自然数加上英文句点来标记，后面需跟 <code>空格</code>。例如，</p><pre><code class="hljs plaintext">1. 有序列表2. 有序列表3. 有序列表</code></pre><p>任务列表是标记为[ ]或[x]（未完成或完成）的项目的列表。例如：</p><pre><code class="hljs plaintext">- [ ] 这是一个任务列表项- [ ] 需要在前面使用列表的语法- [ ] normal **formatting**, @mentions, #1234 refs- [ ] 未完成- [x] 完成</code></pre><p>Tips：二级列表只需在一级列表前面使用 <code>Tab</code> 键。</p><ul><li><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3></li></ul><p>有两种风格，原生和 Github 。<br>原生风格，首行缩进四个空格。例如，</p><pre><code class="hljs plaintext">这是一个原生风格代码块。</code></pre><p>Github 风格，代码块的前后用三个反引号独占一行来标记。例如，</p><pre><pre><code class="hljs java">这是一个GitHub风格代码块。</code></pre></pre><p>Tips：Github风格可在开头的 &#96;&#96;&#96; 后面跟上语言名称，例如java等。</p><ul><li><h3 id="标亮-内联代码"><a href="#标亮-内联代码" class="headerlink" title="标亮(内联代码)"></a>标亮(内联代码)</h3></li></ul><p>内联代码用反引号 &#96; 表示。例如，</p><pre><code class="hljs plaintext">`请把我标亮`</code></pre><p>Tips：有的编辑器用单个 <strong>`** 不起作用，只好用两个 **`</strong> 将代码包裹起来。</p><ul><li><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3></li></ul><p>分割线可以用三个以上的星号、减号或者下划线来标识，行内不能有其他东西，但是可以插入空格。例如，</p><pre><code class="hljs plaintext">**** * * ---- - - ____ _ _</code></pre><ul><li><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3></li></ul><p>链接用下面的格式标识。例如，</p><pre><code class="hljs plaintext">[链接要显示的文字](链接URL &quot;鼠标箭头放到链接上的提示文字，可以不写，与链接之间留有空格&quot;)</code></pre><p>还可以用另外的格式标识，效果也是一样的，例如，</p><pre><code class="hljs plaintext">[链接要显示的文字][id][id]:链接URL &quot;鼠标箭头放到链接上的提示文字，可以不写，与链接之间留有空格&quot;</code></pre><p>Tips：如果链接的地址和要显示的文字一样的话，可以用尖括号将其包裹形成自动连接。</p><ul><li><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3></li></ul><p>图片的标识语法与链接类似。例如，</p><pre><code class="hljs plaintext">![图片不存在时的提示文字](图片URL &quot;鼠标箭头放到图片上的提示文字&quot;)</code></pre><p>图片的 Markdown 标识与 HTML 标签有对应的关系，关系如下，</p><pre><code class="hljs plaintext">![img alt 属性](img 地址 “img title 属性”)&lt;img src=&#x27;img 地址&#x27; alt=&#x27;img alt 属性&#x27; title=&#x27;img title 属性&#x27; width=&quot;16&quot; height=&quot;16&quot; align=&quot;center&quot;&gt;</code></pre><p>Tips：MD 文件中可采用 <code>&lt;img&gt;</code> 标签写法控制图片大小。</p><ul><li><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3></li></ul><p>使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。<br>原本是 Github 风格的语法，大部分编辑器都支持。例如，</p><pre><code class="hljs plaintext">| 语言 | 时间 | 备注 ||----|----:|:------:||Java|3年|学不动||Python|2年|好学||Golang|1年|不好学|</code></pre><p>Tips:第一行表头可以不要，第二行必须要有，第二行的冒号标识表中内容居左、居右还是剧中，如果不加冒号默认居左。</p><ul><li><h3 id="内嵌-HTML"><a href="#内嵌-HTML" class="headerlink" title="内嵌 HTML"></a>内嵌 HTML</h3></li></ul><p>Markdown 保留了内嵌 HTML 的语法，用来设置纯 Markdown 不支持的内容，标签中的内容都会输入到结果中。例如，</p><pre><code class="hljs plaintext">&lt;html&gt;  &lt;body&gt;    &lt;div&gt;        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=4877755&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;      &lt;/div&gt;   &lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="hljs plaintext">&lt;font color=&quot;red&quot; size=&quot;8&quot;&gt;我是红色放大字&lt;/font&gt;</code></pre><h2 id="写作风格"><a href="#写作风格" class="headerlink" title="写作风格"></a>写作风格</h2><ul><li><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><ul><li>中文与英文之间需要有空格，例如：Apple Watch 将于下周开始接受预订。</li><li>中文与数字之间需要有空格，例如：下午跑步 1 小时。</li><li>数字与单位之间需要有一个空格，例如：是 5 GB 而不是 5GB。</li><li>全角标点符号与其他字符之间不需要空格。例如：第一行表头可以不要，第二行。</li></ul></li><li><h3 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h3><ul><li>只有中文或中英文混排中，一律使用中文&#x2F;全角标点。</li><li>中英文混排中如果出现整句英文，则在这句英文中使用英文&#x2F;半角标点。</li><li>中文标点与其他字符间一律不加空格。</li><li>尽量避免重复使用标点（尤其是叠加感叹号、问号等），例如！！！等。</li></ul></li><li><h3 id="段落-1"><a href="#段落-1" class="headerlink" title="段落"></a>段落</h3><ul><li>段落开头不要留出空白字符，顶格写。</li><li>段落之间使用一个空行隔开或者在第一行末尾敲2个空格。</li></ul></li><li><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><ul><li>文件夹：英文小写（多个英文减号连接）。<pre><code class="hljs plaintext">正确：copywriting-guide错误：copywriting_guide、copywritingGuide、CopywritingGuide、copywriting guide</code></pre></li><li>Markdown 文件：英文小写（多个英文减号连接）。<pre><code class="hljs plaintext">正确：copywriting-guide.md错误：copywriting_guide.md、copywritingGuide.md、CopywritingGuide.md、copywriting guide.md</code></pre></li></ul></li><li><h3 id="目录标题"><a href="#目录标题" class="headerlink" title="目录标题"></a>目录标题</h3><ul><li>目录标题与每篇文章的标题要一致。</li></ul></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.appinn.com/markdown/">Markdown 语法说明 (简体中文版)</a></li><li><a href="https://support.typoraio.cn/zh/Markdown-Reference/">Typora 的 Markdown 语法</a></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 开发语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人网址导航</title>
      <link href="/1970/01/01/git-navi.html"/>
      <url>/1970/01/01/git-navi.html</url>
      
        <content type="html"><![CDATA[<h1 id="个人网址导航"><a href="#个人网址导航" class="headerlink" title="个人网址导航"></a>个人网址导航</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%88%97%E8%A1%A8">列表</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>记录一些常用的网址，方便查找。</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="精华帖…"><a href="#精华帖…" class="headerlink" title="精华帖…"></a>精华帖…</h3><ul><li><p><a href="https://mp.weixin.qq.com/s/hnwABWOmd3q77Nb6_Qvgww">P站上，一个华人AV厂牌正在冉冉升起</a></p></li><li><p><a href="https://fulibus.net/liuyue.html">P站华人第一女星刘玥采访记录</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NzU0NjIxMQ==&mid=2247483999&idx=1&sn=ef00be257ea70d9c4f4ece882369582d">今日分析：美国为何炸死伊朗将军的全方位解读（万字分析）美国这么做背后有更深的缘由</a></p></li><li><p><a href="https://www.x6d.com/i-wz-8375.html">关于这一个月刀网停更说明</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/iMr8wHPBFcQxij2jre0_ow">男性的「高潮」是啥样？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/X4esFde5wgIhRp71UeK6tQ">第一次下片儿，是每个男孩的成人礼</a></p></li><li><p><a href="https://www.jiemian.com/article/3696848.html">【特写】一位脑瘫女孩和一款特殊输入法的“奇遇人生”</a></p></li><li><p><a href="https://user.guancha.cn/main/content?id=193740&page=0">不敢上厕所，不敢住酒店，你永远不知道韩国的偷拍有多变态…</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/OKzKpgw8diN7WV2PdC9BgA">我的工作，是帮女孩们找出卧室里的针孔摄像头</a></p></li><li><p><a href="https://new.qq.com/rain/a/20191031A0QD7M">亲子鉴定师：入行16年，亲眼看见上万男人戴上绿帽子</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/uuzvPpcYoNO5zZc_3pNsiA">重庆魔楼红鼎国际六天五夜奇幻游记</a></p></li><li><p><a href="http://doudoubbs.yxsyj.com/forum.php?mod=viewthread&tid=17838&page=1&authorid=5429">戒毒十年慢慢说</a></p></li><li><p><a href="http://www.sohu.com/a/270138940_115207">通过淘宝“买家秀”，我花8000块睡到了喜欢的coser</a></p></li><li><p><a href="https://www.williamlong.info/archives/5567.html">中国2018社会热点大事记-月光博客</a></p></li><li><p><a href="http://tech.sina.com.cn/i/2019-01-01/doc-ihqhqcis2043090.shtml">罗振宇2018“时间的朋友”跨年演讲精华版全文|罗振宇|时间的朋友|演讲_新浪科技_新浪网</a></p></li><li><p><a href="http://renjian.163.com/18/1123/14/E1A8RTTI000181RV.html" title="一个越南19岁少女被卖到了中国，做家务，生孩子，用她后来赚的钱偿还了父亲买她时花的钱。她的女儿记录了母亲被卖到中国这26年发生的故事。想不到当今的社会买新娘这种事在偏远地区如此平常，希望作者的文章能够引起社会关注。">一个越南新娘在中国的26年</a></p></li><li><p><a href="https://bbs.hupu.com/24236799.html" title="虎扑用户发布，写的很长，文采也不错。">结婚十年被绿的彻底  后续2 就是这么狗血（文章较长） - 步行街主干道 - 虎扑社区</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2018/12/tencent.html">腾讯的历史 - 阮一峰的网络日志</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/Ak_Me0a4ADrOISIeqj-iXQ">如何开始零基础学英语,是先学音标,还是先看语法,还是先背单词？</a></p></li><li><p><a href="https://weibo.com/ttarticle/p/show?id=2309404325189360998090">妻子举报大连海关“科级”丈夫：睡了14名“代购”，其中1人是处女</a></p></li><li><p><a href="http://www.1905.com/special/filmfest/91thoscars/">第91届奥斯卡金像奖全程回顾_电影节专题_电影网_1905.com</a></p></li></ul><h3 id="知乎-豆瓣…"><a href="#知乎-豆瓣…" class="headerlink" title="知乎&amp;&amp;豆瓣…"></a>知乎&amp;&amp;豆瓣…</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/36093761">天天“性生活”，偶尔打个胎，一个色情服务人员的自诉</a></li><li><a href="http://www.zhihufans.com/index.php">知乎封神榜 - 您的知乎之旅从此开始</a></li><li><a href="http://jandan.net/new" title="煎蛋以译介方式传播网络新鲜资讯">煎蛋 - 地球上没有新鲜事</a></li></ul><hr><ul><li><a href="https://www.douban.com/gallery/topic/50680/">你听说过哪些连小说中都不敢写的狗血真实事件</a></li><li><a href="https://www.douban.com/group/topic/149586712/">说说你见过的知道的最乱的事</a></li><li><a href="https://www.douban.com/note/715956852/">在去和男友约会路上与滴滴司机C震！性开放时代C轨C震有错？</a></li><li><a href="https://music.douban.com/annual/2019">豆瓣2019年度音乐榜单</a></li><li><a href="https://book.douban.com/annual/2019">豆瓣2019年度读书榜单</a></li><li><a href="https://movie.douban.com/annual/2019">豆瓣2019年度电影榜单</a></li><li><a href="https://movie.douban.com/annual/2018">豆瓣2018年度电影榜单・携程冠名</a></li><li><a href="https://movie.douban.com/annual/2017">豆瓣2017年度电影榜单</a></li><li><a href="https://movie.douban.com/annual2016">豆瓣2016年度电影榜单</a></li><li><a href="https://movie.douban.com/annual2015">豆瓣2015年度电影榜单</a></li><li><a href="https://movie.douban.com/review2014">豆瓣2014年度电影榜单</a></li></ul><hr><ul><li><a href="https://www.zhihu.com/question/264019472">如何评价deepfakes用深度学习技术所合成的明星AV?</a></li><li><a href="https://www.zhihu.com/question/37161602" title="美图欣赏：https://movie.douban.com/celebrity/1363672/">水野朝阳哪位大神能评价下以及预测发展？</a></li><li><a href="https://www.zhihu.com/question/28753270" title="为什么男人和女人都喜欢丝袜呢？首先是因为人类的的原始欲望，喜欢全身被覆盖。其次穿着丝袜能够展示身材，对男性是一种性暗示。">超级超级贵的丝袜到底有什么不一样的地方？</a></li><li><a href="https://www.zhihu.com/question/27884620">文学作品里有哪些经典开场白？</a></li><li><a href="https://www.zhihu.com/question/37006507">有一个漂亮的室友是一种什么样的体验？</a></li><li><a href="https://www.zhihu.com/question/20771438">风清扬和东方不败的武功谁更厉害？</a></li><li><a href="https://www.zhihu.com/question/65992444">美国人在日常生活中浏览的是哪些网站？</a></li><li><a href="https://www.zhihu.com/question/51671791">有哪些是你踏入社会才明白的道理？</a></li><li><a href="https://www.zhihu.com/question/28870980">撞见父母啪啪啪怎么办？</a></li><li><a href="https://www.zhihu.com/question/31329403">什么是好的开放式厨房设计？</a></li><li><a href="https://www.zhihu.com/question/20247512">郭靖和杨过谁厉害？</a></li><li><a href="https://www.zhihu.com/question/29874865">如何评价秀色、冰恋、慕残？</a></li><li><a href="https://www.zhihu.com/question/25527623">女生被外科男医生检查肛门，觉得难堪心里过不去坎怎么办？</a></li><li><a href="https://www.zhihu.com/question/34942339">你们有刮阴毛的习惯吗？长期刮好吗？</a></li><li><a href="https://www.zhihu.com/question/267460120">有哪些不知名的女生照片让你特别心动念念不忘珍藏至今，一直想知道她的名字？</a></li><li><a href="https://www.zhihu.com/question/36527695">享受日本风俗店的服务，是种怎样的体验？</a></li><li><a href="https://www.zhihu.com/question/26297181">大胸女生如何穿衣搭配？</a></li><li><a href="https://www.zhihu.com/question/29115889">为什么部分很漂亮的女性会去当性工作者？</a></li><li><a href="https://www.zhihu.com/question/19982269">大三学生手头有 6000 元，有什么好的理财投资建议？</a></li><li><a href="https://www.zhihu.com/question/39689716">如何评价微博出现的各种福利姬？</a></li><li><a href="https://www.zhihu.com/question/28753270">超级超级贵的丝袜到底有什么不一样的地方？</a></li></ul><h3 id="微博福利…"><a href="#微博福利…" class="headerlink" title="微博福利…"></a>微博福利…</h3><ul><li><a href="https://weibo.com/5998187176/H8ANUbDYU">第一届女子健身身材大赛</a></li><li><a href="https://weibo.com/5998187176/H6LFZdJ3K">第一届120斤肉肉女孩大赛！只要身体健康，瘦和胖一样很美，自信的女孩最可爱！</a></li><li><a href="https://weibo.com/5998187176/H3gQy0DSt" title="微博colouration前几天新开的主题，第一届男孩子女孩子正装大赛。这次玩起了制服诱惑，参加的美女们质量都不错哦。既然博主吸引了一帮美女粉丝，那么不管是比基尼还是正装，穿上去都好看咯。">第一届男孩子女孩子正装大赛！！正装太迷人了！ </a></li><li><a href="https://weibo.com/5998187176/GFJtB7vVr">第一届最甜笑容大赛！！甜甜的笑容超治愈！！</a></li><li><a href="https://weibo.com/5998187176/H6joz97Dc">第一届宠物大赛！！来晒晒自己的宝贝！！</a></li><li><a href="https://weibo.com/1740806873/Guauhitiu">你最性感而又不失保守的照片是哪张？ ​​​​</a></li><li><a href="https://weibo.com/6514368732/Hgd5Qitmj">网友：看看胸 女：滚 网友：美胸比赛 女：[图片消息] </a></li></ul><hr><ul><li><a href="https://weibo.com/tv/v/HgaNTlNgG?fid=1034:4338546413377740">比特币和区块链啥原理?矿机挖矿咋回事?李永乐老师讲比特币第一集</a></li><li><a href="https://weibo.com/tv/v/HgkzP4q2d?fid=1034:4338921413505538">比特币交易如何防伪?私钥公钥地址啥意思?李永乐老师讲比特币第二集</a></li></ul><hr><ul><li><a href="https://h5.m.taobao.com/ocean/privatenode/shop.html?sellerId=2193570902" title="比如搜索商品关键字，找到商品卡片页中的店铺名称，复制名字中的连接，包含有店铺ID的一串数字,替换即可">买家秀</a></li><li><a href="https://h5.m.taobao.com/ocean/privatenode/shop.html?sellerId=50852803">买家秀</a></li><li><a href="https://h5.m.taobao.com/ocean/privatenode/shop.html?sellerId=673336836">淘宝官方出品图片墙，撩汉出品买家秀汇总</a></li><li><a href="https://h5.m.taobao.com/ocean/privatenode/shop.html?sellerId=109043255">淘宝官方出品图片墙，妖怪森林买家秀汇总</a></li><li><a href="https://market.m.taobao.com/apps/abs/9/41/index?wh_weex=true&pageId=6273&wx_navbar_hidden=true&wx_navbar_transparent=true&accountId=1994013081&content_id=217303897213">媚媚内衣实验室</a></li></ul><h3 id="B站-纪录片…"><a href="#B站-纪录片…" class="headerlink" title="B站&amp;&amp;纪录片…"></a>B站&amp;&amp;纪录片…</h3><ul><li><a href="javascript:void(0);" title="日文看不懂不要禁，打开弹幕看野生字幕组翻译。第一次见面就接吻，会坠入爱河吗。">岛国的无节操综艺节目</a><ul><li><a href="https://www.bilibili.com/video/av17848815" title="【第①弹】【高能预警/霓虹节目】刚见面就接吻的话，会迅速堕入爱河吗？职业选手就是不一般！_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili">第一弹</a></li><li><a href="https://www.bilibili.com/video/av18666545" title="【第③弹】【高能预警/霓虹节目】刚见面就接吻的话，会迅速堕入爱河吗？超辣女大学生vs肌肉男_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili">第三弹（推荐）</a></li><li><a href="https://www.bilibili.com/video/av18718674" title="【第④弹】【高能预警/霓虹节目】刚见面就接吻的话，会迅速堕入爱河吗？『职场同僚版』_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili">第四弹</a></li></ul></li><li><a href="https://v.qq.com/detail/f/fw4hh6seulgqm3k.html" title="讲述中国历史上一所传奇大学的历史。一所仅存八年的大学，却涵盖了中国当代在学术上的所有名人。">西南联大</a></li></ul><h3 id="福利吧"><a href="#福利吧" class="headerlink" title="福利吧"></a>福利吧</h3><ul><li><a href="http://fulibus.net/website5.html">全网趣味网站分享第五期：影视搜索&#x2F;任正非讲话资料&#x2F;保险万事通&#x2F;IPFS客户端&#x2F;捷径大全</a></li><li><a href="http://fulibus.net/zxgk.html">生活必备的查询网址：查征信、婚姻、交友借钱明明白白</a></li><li><a href="http://fulibus.net/shengchengqi.html">在线工具：趣味生成器，好玩停不下来！</a></li><li><a href="http://fulibus.net/bhvip.html">【安卓、PC】BhVip团队破解福利软件更新合集</a></li><li><a href="http://fulibus.net/tiktok.html">安卓：日本版抖音+美国版抖音（破解版不锁区）</a></li><li><a href="http://fulibus.net/m3u8.html">网页视频嗅探插件猫抓+m3u8视频批量下载合并</a></li><li><a href="http://fulibus.net/tumblthree.html">功能强大的TUMBLR批量搬运软件–TumblThree</a></li><li><a href="http://fulibus.net/viewer.html">安卓神器JAViewer更新2.0版本，可在线播放</a></li><li>福利吧论坛<ul><li><a href="http://www.wnflb.com/thread-126092-1-1.html">[林正英电影合集全46集][1981-1994 1080P&#x2F;720P x264 AAC MKV][国粤中字][152G]</a></li><li><a href="http://www.wnflb.com/thread-125569-1-1.html">m3u8资源在线看，工具+资源</a></li><li><a href="http://www.wnflb.com/thread-126140-1-1.html">[周星驰高清电影合集][1988-2008 蓝光1080P MKV][国粤双语&#x2F;中字][654G]</a></li></ul></li></ul><h3 id="在线工具站"><a href="#在线工具站" class="headerlink" title="在线工具站"></a>在线工具站</h3><ul><li><a href="http://www.atool.org/">在线工具 - aTool - 最全面的工具集合</a></li><li><a href="https://tool.gifhome.com/">GIF在线压缩_GIF裁剪制作工具_视频转GIF软件_GIF之家</a></li><li><a href="https://tinypng.com/" title="或者https://tinyjpg.com/,方便各位压缩各种图片，压缩比例超过60%，完全免费！一次最多可压缩20张图片！">Tinypng工具用于压缩你的图片，减少服务器占用</a></li><li><a href="https://tool.lu/css/" title="将复制好的css粘贴进去，点击压缩；压缩完成后，全选复制压缩后的css代码。">Css在线解压缩&#x2F;整理&#x2F;格式化 - 在线工具</a></li><li><a href="https://tool.lu/js/" title="将复制好的js 粘贴进去，点击净化；需要注意的是，有些js代码压缩后，会无效，所以请自行尝试！">Javascript在线解压缩 - 在线工具</a></li><li><a href="https://www.icontuku.com/" title="收录了99832个免费的PPT图标ICON素材及网页设计图标资源，具有按分类、色系、标题、系列搜索图标的功能，帮助您以最快的速度找到喜欢的图标ICONS。">IconPng.com 爱看图标网，免费中文图标搜索引擎！</a></li><li><a href="https://e.mezw.com/" title="将普通网站的链接转换为emoji链接。emoji源自日本，中文称作表情符号，QQ、微信、iMessage等沟通中都会使用emoji。">emoji短网址 - MEZW</a></li><li><a href="https://ai.binwang.me/couplet/" title="V2EX原贴：用深度学习做了一个自动对对联的系统(https://www.v2ex.com/t/401537?p=3)">王斌给您对对联 !</a></li><li><a href="http://www.yingjingtu.com/">Gif图片添加字幕 - 应景图</a></li><li><a href="https://jikipedia.com/" title="很多流行的词语还没有收录到各大词典，却可以在小鸡词典搜索到;不少词条搞笑无厘头，撰写词条还会获得红包。">小鸡词典 - 最全的网络流行语词典</a></li><li><a href="http://www.sdmz.net/" title="这是一个关于地理的网站，介绍了四大名著西游、三国、红楼、水壶中的地图、人物关系图等，电子地图还可以进行互动。">四大名著，中国四大名著，四大名著小说</a></li><li><a href="https://www.logoko.com.cn/" title="强大的免费在线LOGO生成工具，输入品牌或名字，选择所在行业，系统会自动根据设定设计LOGO风格，当然你也可以后期修改。">免费在线logo设计，标志设计，网站标志设计，公司标志设计，免费</a></li></ul><h3 id="番茄站"><a href="#番茄站" class="headerlink" title="番茄站"></a>番茄站</h3><ul><li><a href="https://web.archive.org/" title="用于备份网络上所有网站的内容，包括网站内的其他链接url。它会扫描机会所有网站，并每隔一段时间对每个网站进行备份，存在它自己的服务器上。目前，它已经存储了600多亿条url。">Wayback Machine</a></li><li><a href="https://teddysun.com/486.html">Shadowsocks 一键安装脚本（四合一）  |  秋水逸冰</a></li><li>Youtube<ul><li><a href="https://www.youtube.com/watch?v=wZsdOvwkfCY">北京老大爷谈性张口就来，黄段子才是顺口溜！电影院里还那啥~</a></li><li><a href="https://www.youtube.com/watch?v=USTtGV1Vyac&t=19s">和陌生人说话完整版 20180927期 “小混混”搏命伊拉克：我只有死在那儿才值400万</a></li><li><a href="https://www.youtube.com/watch?v=DjYdo0dNW8Y">东北饭店，你瞅啥，瞅你咋地，劝都劝不住，直接酒瓶的轮上，满脑出血</a></li><li><a href="https://www.youtube.com/playlist?list=PLasRUr-dn8CkU7d7g8EpHIX9uVwqxxxGD">铁牛私房课-性爱教学</a></li></ul></li><li>Pornhub<ul><li><a href="https://www.pornhub.com/view_video.php?viewkey=ph5c51d89ae6c70">JAPANESE ANAL MASTURBATION SOLO GIRL</a></li><li><a href="https://www.pornhub.com/model/ziaxnoa">ZIAxNOA</a></li><li><a href="https://www.pornhub.com/view_video.php?viewkey=ph5c1b804ad3492">BLOWJOB SKILL</a></li><li><a href="https://www.pornhub.com/view_video.php?viewkey=ph5ab787f0f0bc7">Y GIRLFRIEND IS HARD ON ME IN BED, AND MY GIRLFRIEND IS EXCITED</a></li><li><a href="https://www.pornhub.com/users/qiezishipin">qiezishipin’s Profile</a></li><li><a href="https://cn.pornhub.com/video/search?search=wmaf">Wmaf</a></li><li><a href="https://jp.pornhub.com/view_video.php?viewkey=ph5c86bccc7dfb7">SENSITIVE EXPLORE MY FORESKIN DAY 1 BJ AND FORESKIN WEEK -DICKFORLILY</a></li><li><a href="https://jp.pornhub.com/view_video.php?viewkey=ph5be0b9c86867a">COZY SOLO DILDO CUM</a></li><li><a href="https://jp.pornhub.com/model/chessie-rae">Chessie Rae</a></li></ul></li><li>Twitter<ul><li><a href="https://twitter.com/287076147/">森罗万象</a></li></ul></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>未完待续…</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
